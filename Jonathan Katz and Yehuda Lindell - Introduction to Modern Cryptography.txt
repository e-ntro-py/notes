Chapter 1 
1.1
JGRMQOYGHMVBJWRWQFPWHGFFDQGFPFZRKBEEBJIZQQOCIBZKLFAFGQVFZFWWE
OGWOPFGFHWOLPHLRLOLFDMFGQWBLWBWQOLKFWBYLBLYLFSFLJGRMQBOLWJVFP
FWQVHQWFFPQOQVFPQOCFPOGFWFJIGFQVHLHLROQVFGWJVFPFOLFHGQVQVFILE
OGQILHQFQGIQVVOSFAFGBWQVHQWIJVWJVFPFWHGFIWIHZZRQGBABHZQOCGFHX
QVF -> the
cryptographicsystemsareextremelydifficulttobuildneverthelessf
orsomereasonmanynonexpertsinsistondesigningnewencryptionschem
esthatseemtothemtobemoresecurethananyotherschemeonearththeunf
ortunatetruthhoweveristhatsuchschemesareusuallytrivialtobreak

1.2
mono-alphabetic:
    Gen: gives a random bijection f: Z26 -> Z26
    Enc: a homomorphism (Z26)* -> (Z26)* based on f 
    Dec: a homomorphism (Z26)* -> (Z26)* based on the inversion of f
Vigenere:
    Gen: gives a random string in (Z26)*
    Enc: a length preserving function (Z26)* -> (Z26)* that for input w = w1w2...wn and key k:
         output is x = x1x2...xn that
         xi = (wi + k[i mod |k|]) mod 26
    Dec: the same as Enc except
         xi = (wi - k[i mod |k|]) mod 26

1.3
characters in position i, i+t, i+2t is in a mono-alphabetic permutation, and t can be tested with statistics
then the problem reduces to breaking t mono-alphabetic permutation

1.4
a.  substract ki + j modulo 26
b.  the repeating bi or trigram is 26 times less frequent
    since they have to occur in the (modulo 26) same position in the key and jth block
    requires longer ciphertext to determine the period
c.  since the encryption method is open
    substract j for characters in jth block modulo 26 and it's now an ordinary Vigenere cipher

1.5
shift:  all it needed is a single character to calculate the shift
substitution:   a segment containing all 26 characters then the permutation is known
Vigenere:   any text with length at least t, then the key can be calculated

1.6
shift:  a single character
substitution:   a string of length 25, "ab..y"
Vigenere:   a length t string of repeating "a", when t unknown just any reasonable length < 100

Chapter 2 
2.1
if Π = (Gen, Enc, Dec) is perfectly secret
    Pr[M = m | C = c] = Pr[M = m]
    Pr[M = m ∧ C = c] / Pr[C = c] = Pr[M = m]
multiply both sides with Pr[C = c] / Pr[M = m]
    Pr[M = m ∧ C = c] / Pr[M = m] = Pr[C = c]
    Pr[C = c | M = m] = Pr[C = c]

2.2
by perfect secrecy
    Pr[M = m | C = c] = Pr[M = m]
    Pr[M = m' | C = c] = Pr[M = m']
so if Pr [M = m | C = c] = Pr[M = m' | C = c], then
    Pr[M = m] = Pr[M = m']
what only holds if the distribution over M is uniform, so refute

2.3
by outruling k = 0^l, |K| = |M| - 1 < |M|, so this encryption is no longer perfectly secret
first, it's a very low possibility of choosing k = 0^l, namely 1/2^l
second, for all possible m ∈ M and c ∈ C, there exists a key encrypts m to c
that means any meaningful sentence can be the ciphertext of any other plaintext
an adversary seeing some meaningful ciphertext cannot tell the difference between:
    1. the key is 0^l
    2. the plaintext is encrypted to meaningful ciphertext by chance
the probability of the two event are roughly the same

2.4
a.  |C| = |M| = |K| = 26, and for any character x and any cipher character y, there exists a unique key that:
        x + k ≡ y (mod 26)
    so by Shannon's theorem, if k is chosen uniformly from Z26 this encryption method is perfectly secret
b.  let M = strings of length 26 with non-repeating characters
    then |M| = |K| = 26!
    also |C| = |M| = 26!, in fact C = M
    for any c ∈ C and m ∈ M, define a function k that maps every character in m to every character in c in order
    then k is an bijection Z26 -> Z26, k ∈ K, Enc(k, m) = c
    by Shannon's theorem, if k is chosen uniformly from K, then this encryption is perfectly secret
    since |K| >= |M| for any perfectly secret encryption, this is the biggest |M| possible
c.  for M = {w | w is a word of length t}, |M| = |K| = t^26 
    since Vigenere cipher is length preserving, and for any string c of length t 
        Enc(c, a^26) = c
    so C = M and |C| = |M| = |K|
    also for any c, m ∈ C = M, define k = k1k2..kt that
        ki = (ci - mi) mod 26
    then Enc(k, m) = c
    by Shannon's theorem, if k is chosen uniformly from K, then this cipher is perfectly secret
all attacks in Chapter 1 relies on some form of statistics, which is infeasible with so small data
only exception be the exhausting search for shift cipher, which doesn't make sense with only one character

2.5
refute. Modify shift cipher with a message space of one character strings that 
    discard generated key and always shift the plaintext by 3
then
    Pr[C = d | M = a] = 1
    Pr[C = e | M = a] = 0 != 1
so this cipher is not perfectly secret, but it meets all requirements the problem states 

2.6
thanks https://cstheory.stackexchange.com/questions/11476#answer-11479
try doing it in some different setup
let M' = {m | Pr[M = m] > 0}, N = M - M', define a new distribution Pr' that
    Pr'[M = m] = Pr[M = m] / 2 for m ∈ M'
    Pr'[M = m] = some arbitrary non-zero real number for m ∈ N and make
    ∑m∈N Pr'[M = m] = 1/2
then ∑m∈M Pr'[M = m] = 1 is a proper distribution
and since Pr' assigns non-zero probability to all m, the scheme under Pr' is perfectly secret
for m ∈ M',
    Pr'[M = m, C = c]   = Pr'[C = c | M = m] * Pr'[M = m]
when m fixed, the probability Pr'[C = c | M = m] only affected by the randomness of Gen and Enc, not Pr or Pr' so
    Pr'[C = c | M = m] = Pr[C = c | M = m]
and
    Pr'[C = c | M = m] * Pr'[M = m] = Pr[C = c | M = m] * Pr[M = m] / 2
                                    = Pr[M = m, C = c] / 2
while ∑m∈N Pr'[C = c, M = m]    = ∑m∈N Pr'[C = c | M = m] * Pr'[M = m]
                                = ∑m∈N Pr'[C = c] * Pr'[M = m]  // by perfect secrecy
                                = Pr'[C = c](∑m∈N Pr'[M = m])
                                = Pr'[C = c] / 2
combined with Pr'[C = c] = ∑m∈M Pr'[C = c, M = m] and M = M' + N, it makes
    ∑m∈M' Pr'[C = c, M = m] = Pr'[C = c] - ∑m∈N Pr'[C = c, M = m]
                            = Pr'[C = c] / 2
that means
    Pr'[C = c] / 2  = ∑m∈M' Pr'[C = c, M = m]
                    = ∑m∈M' Pr[M = m, C = c] / 2
                    = Pr[C = c] / 2
so the distribution of ciphertext is the same with either Pr or Pr' and for m ∈ M':
Pr[M = m | C = c]   = Pr[M = m, C = c] / Pr[C = c]
                    = 2Pr'[M = m, C = c] / Pr'[C = c]
                    = 2Pr'[M = m | C = c]
                    = 2Pr'[M = m]   // by perfect secrecy
                    = 2 * Pr[M = m] / 2
                    = Pr[M = m]
for m ∈ N, Pr[M = m | C = c] = Pr[M = m] = 0
so the encryption scheme is still perfectly secret with some m assigned zero probability
for any M' ⊂ M, define Pr[M = m] = 0 for m ∈ M - M' then the distribution has been extended to M
for all m ∈ M, perfect secrecy holds

2.7
Since perfect secrecy is true for all distribution, it is also true for a distribution that
    Pr[M = m0] = Pr[M = m1] = 1/2
and a message space M = {m0, m1}
then Pr[C = c | M = m0] = Pr[C = c | M = m1]
no matter what m0, m1 the adversary has chosen, the ciphertext is totally indifferent to the adversary

2.8
if Π is not a scheme of perfect secrecy, then for some message m0, m1 and some ciphertext c:
    Pr[C = c | M = m0] != Pr[C = c | M = m1]
assume Pr[C = c | M = m0] > Pr[C = c | M = m1] (otherwise symmetric)
then
    Pr[C = c, M = m0] / Pr[M = m0] > Pr[C = c, M = m1] / Pr[M = m1]
if Pr[C = c] = 0, Pr[C = c | M = m0] = Pr[C = c | M = m1] = 0, so Pr[C = c] != 0
since Pr[M = m0] = Pr[M = m1] = 1/2, multiply both sides with Pr[C = c] / 2:
    Pr[C = c, M = m0] / Pr[C = c] > Pr[C = c, M = m1] / Pr[C = c]
    Pr[M = m0 | C = c] > Pr[M = m1 | C = c]
as M = {m0, m1}, Pr[M = m0 | C = c] + Pr[M = m1 | C = c] = 1, which means
    Pr[M = m0 | C = c] > 1/2
let the adversary outputs m0 and m1 at step 1
at step 3, if the ciphertext is c, A outputs 0, otherwise A outputs either 0 or 1 with equal probability
    Pr[PrivK(eav, A, Π) = 1]    = Pr[b' = b]
                                = Pr[b' = b | C = c] * Pr[C = c] + Pr[b' = b | C != c] * Pr[C != c]
obviously Pr[b' = b | C != c] = 1/2, as b' is chosen randomly that case
since A outputs 0 when C = c,
    Pr[b' = b | C = c]  = Pr[b = 0 | C = c]
                        = Pr[M = m0 | C = c]
                        > 1/2
    Pr[PrivK(eav, A, Π) = 1]    = Pr[b' = b | C = c] * Pr[C = c] + (1/2) * Pr[C != c]
                                = 1/2 + (Pr[b' = b | C = c] - 1/2) * Pr[C = c]
since Pr[b' = b | C = c] > 1/2, Pr[C = c] > 0, Pr[PrivK(env, A, Π) = 1] > 1/2

2.9
when m != m', c = c', Pr[C = c] > 0, Pr[M = m] > 0, Pr[M' = m'] > 0
Pr[C = c, C' = c'] = Pr[C = c]^2 > 0, Pr[M = m, M' = m'] = Pr[M = m] * Pr[M' = m'] > 0
but Pr[M = m, M' = m' | C = c = C'] = 0
otherwise the encryption scheme encrypts two different plaintext to the same ciphertext with the same key
that makes effective decryption impossible

2.10
use mono-alphabetic cipher on the message space of a single character
then the key is effectively a bijection k: Z26 -> Z26,
    Gen = choose such a bijection from all |K| = 26! bijections
    Enc(k, m) = k(m)
    Dec(k, m) = k^-1(m)
    M = C = Z26
then 
    Pr[M = m, M' = m' | M != M']    = Pr[M = m, M' = m', M != M'] / Pr[M != M']
                                    = Pr[M = m, M' = m'] / Pr[M != M']  // M != M' is trivial when m != m'
    Pr[M = m, M' = m' | C = c, C' = c'] = Pr[M = m, M' = m', C = c, C' = c'] / Pr[C = c, C' = c']

2.11
since Gen needs no input except the uniformly chosen random tape r, k <- Gen outputs k ∈ K with a probability p(k)
make d_Gen the deterministic algorithm that take a random tape r as the input and outputs a k ∈ K
now define a new encryption scheme with key generating algorithm Gen' that take a random tape r and output it directly
    R <- Gen'
the new encryption algorithm Enc'(r, m) = Enc(d_Gen(r), m) to encrypt the message, Dec' similarly defined
now Gen' is uniformly distributed, and Pr[d_Gen(R) = k] = Pr[K = k] since it's the definition of K
Pr[C = c | M = m] is only determined by the randomness of key thus unchanged for the new scheme
so Pr[C = c | M = m0] = Pr[C = c | M = m1] ∀m0, m1 ∈ M, the new scheme is still perfectly secret
and the new encryption scheme has a uniformly distributed key space now

2.12
consider a message space {0, 1} and t = 1
the key space is empty: Gen outputs nothing, or identically Gen always outputs the same k which is unused
Enc discards the input and randomly output 0 or 1
Dec discards the input and randomly output 0 or 1
then Pr[M = m | C = c] = Pr[M = m], since ciphertext is totally independent to the message 
also Pr[Enc(Dec(m))] = Pr[Enc = m] = 1/2
the lower bound of |K| maybe |M| / 2^t

2.13
consider a message space M that follows uniform distribution
for a fixed c, M(c) <= |K|
assume |K| < |M| * (1 - ε), then for more than ε|M| messages c may not decrypt to them
since ∑m∈M(c) Pr[M = m | C = c] = 1, there exists at least one m0 such that 
    Pr[M = m0 | C = c]  >= 1 / |M(c)|
                        >= 1 / |K|
                        > 1 / (1 - ε)|M|
where Pr[M = m0] = 1 / |M|, so
    Pr[M = m0 | C = c] - Pr[M = m0] > 1 / (1 - ε)|M| - 1 / |M|
                                    = ε / (1 - ε)|M|
also for some m1 ∉ M(c):
    Pr[M = m0] - Pr[M = m1 | C = c] = Pr[M = m0]
                                    = 1 / |M|
take |M| = 2, for the scheme to be almost perfectly secret with a margin ε, it must has 
    ε > 1 / 2
but also
    ε / 2(1 - ε) < ε
    1 / 2(1 - ε) < 1
    (1 - ε) > 1/2
which is not possible, so |K| must >= |M| * (1 - ε)

Chapter 3
3.1
a.  if negl1 and negl2 are negligible functions, then for some n1 and n2:
        for any polynomial p, negl1(n) < 1/p(n) and negl2(n) < negl2(n) for n >= max(n1, n2)
    let negl3(n) = negl1(n) + negl2(n)
    for any polynomial p and n >= max(n1, n2):
        negl3(n)    < 1/(2 * p(n)) + 1/(2 * p(n))  // since 2 * p(n) still a polynomial
                    = 1/p(n)
    so negl3 is negligible
b.  for negl4(n) = p(n) * negl1(n) and any polynomial q:
        negl4(n)    < p(n) / p(n)q(n)   // since p(n)q(n) still a polynomial
                    = 1 / q(n) for n >= n1

3.2
n > 3767.76

3.3
for a random plaintext m chosen from {0,1}^n, Pr[|Enc(m)| <= n - i] <= 1/2^(i-1)
since Dec is deterministic and there are 2^(n-i+1) - 1 strings in {0,1}^(n-i), at most
    2^(n-i+1) - 1 / 2^n < 1/2^(i-1)
fraction of strings in {0,1}^n can ever be encrypted to a shorter ciphertext, or Dec(Enc(m)) != m for some |m| = n
the encryption scheme is assumed to be efficient, so there is a polynomial upper bound q that
    |Enc(m)| <= q(|m|+|k|)
both |k| = n, |m| and the encryption method are known to the adversary, so q(|k|+|m|) can be computed efficiently
let A outputs two message, m0 ∈ {0, 1} and m1 uniformly sampled from {0, 1}^(q(n+1) + 2)
A output 0 if the ciphertext c has length |c| <= q(n+1) and 1 otherwise
then
    Pr[PrivKeav(A, Π) = 1]  = Pr[b' = b]
                            = Pr[b' = b | b = 0] / 2 + Pr[b' = b | b = 1] / 2
when m0 is encrypted, |c| <= q(n+1) and A will output 0, makes b' = b 
when m1 is encrypted, Pr[|Enc(m1)| <= q(n+1)] <= 1/2 by the previous argument
    Pr[b' = b | b = 1] = Pr[|Enc(m1)| > q(n+1)] > 1/2
    Pr[PrivKeav(A, Π) = 1]  > 1/2 + (1/2)/2
                            = 3/4
so Definition 3.8 cannot be satisfied

3.4
define Π = (Gen, Enc, Dec) that
    Gen: uniformly sample k from {0, 1}^n on input 1^n
    Enc: for input m,
        pad m to length l(n) with leading 0s
        prepend b(|m|), the binary presentation of |m|, also padded to |b(l(n))| with leading 0s
        encrypt m' defined above with k and a legit stream cipher
    Dec: for input c,
        decrypt c with k to m'
        read first |b(l(n))| bit to get the length of the real message
        truncate m' to the specified length to recover m
then an experiment in this encryption scheme is more powerful than an experiment in the stream cipher
since for any m0, m1 outputted by A, m0', m1' are of the same length
and if A may succeed with m0 and m1 in this scheme with non-negligible probability
A also may succeed with m0' and m1' in the stream cipher, thus contradicts with the assumption

3.5
Pr[PrivKeav(A, Π, n) = 1]   = Pr[output(PrivKeav(A, Π, n, b)) = b]
                            = Pr[output(PrivKeav(A, Π, n, b)) = b | b = 0] * Pr[b = 0] +
                              Pr[output(PrivKeav(A, Π, n, b)) = b | b = 1] * Pr[b = 1]
                            = Pr[output(PrivKeav(A, Π, n, 0)) = 0] * 1/2 +
                              Pr[output(PrivKeav(A, Π, n, 1)) = 1] * 1/2
                            = (1/2) * (1 - Pr[output(PrivKeav(A, Π, n, 0)) = 1] + Pr[output(PrivKeav(A, Π, n, 1)) = 1])
                            = 1/2 + (Pr[output(PrivKeav(A, Π, n, 1)) = 1] - Pr[output(PrivKeav(A, Π, n, 0)) = 1])
                            = 1/2 + (Pr[output(PrivKeav(A, Π, n, 1)) = 1] - Pr[output(PrivKeav(A, Π, n, 0)) = 1])
shorthands: Priv(A, n) and Priv(A, n, b)
1.  if Pr[output(Priv(A, n, 1)) = 1] - Pr[output(Priv(A, n, 0)) = 1] = f(n) for some positive non-negligible function f,
    Pr[Priv(A, n) = 1] = 1/2 + f(n) and Π is not indistinguishable
2.  if Pr[output(Priv(A, n, 0)) = 1] - Pr[output(Priv(A, n, 0)) = 1] = f(n) for some positive non-negligible function f,
    define A' that outputs 1 when A outputs 0 and vice versa
    then Pr[Priv(A', n, 0) = 1] = Pr[Priv(A, n, 0) = 0] = 1 - Pr[Priv(A, n, 0) = 1]
    Pr[output(Priv(A', n, 1)) = 1] - Pr[output(Priv(A', n, 0)) = 1] = f(n)
    Pr[Priv(A', n) = 1] = 1/2 + f(n), Π is not indistinguishable
since |Pr[output(Priv(A, n, 0)) = 1] - Pr[output(Priv(A, n, 1)) = 1]| = f(n) implies 1 or 2, Def 3.8 => Def 3.9
reversely, if Pr[Priv(A, n) = 1] = 1/2 + f(n) for some non-negligible function f,
Pr[output(Priv(A, n, 1)) = 1] - Pr[output(Priv(A, n, 0)) = 1] = f(n)
so Def 3.9 => Def 3.8

3.6
a.  if there is a distinguisher D can distinguish r from G'(s) with non-negligible probability,
    it can also tell the difference between r and G(s') when the s' = s0^|s| for some s
    but Pr[s' = s0^|s|] = 1/2^(|s|/2) and such case is itself negligible
    so G can still be a proper pseudorandom generator even though G' is not
b.  if there is a distinguisher D can tell the difference between r and G'(s) with non-negligible probability,
        |Pr[D(r) = 1] - Pr[D(G'(s)) = 1]| = f(n), s uniformly picked from {0, 1}^n
        |Pr[D(r) = 1] - Pr[D(G(s')) = 1]| = f(n), s' = s1..sn/2
    so equivalently s' is uniformly picked from {0, 1}^(n/2), and D is a distinguisher for G as well
    thus indistinguishability of G implies indistinguishability of G'

3.7
define Π = (Gen, Enc, Dec) identical to construction 3.24 except:
    1.  it prepends F(k, k) to every ciphertext
    2.  Enc(F(k, k)) = k, Dec(k) = F(k, k) as special cases
        not ambiguous since Enc(F(k, k)) will be the only ciphertext of length n (2n otherwise)
    3.  otherwise Dec(c) strips the first n bits from the ciphertext and decrypts the remaining as construction 3.24
since F is a pseudorandom function, it's polynomial time indistinguishable from a random function f <- Func(n)
F(k, k) appearently is just some random string from {0, 1}^n, not predictable from the encryption scheme without the key
an adversary in a multiple-message experiment have to prepare sequences of messages before receiving any ciphertext
it may send F(k, k) as one of the messages by chance, but not with non-negligible probability (by name, 1/2^n)
however a adversary with an encryption oracle can take the first n bits from any previous ciphertext and get F(k, k)
and query the oracle with F(k, k) to get k, the only hidden part in the encryption scheme

3.8
F(m) = F(k, m) maps strings in {0, 1}^d -> {0, 1}^d, where d = O(log(n)) and |k| = O(p(n)) for some polynomial p
as 3.6.1, strings of length d * 2^d are in one-to-one correspondence with functions in Func(d)
d = O(log(n)) => d * 2^d    = O(log(n)) * 2^O(log(n))
                            < c1(log(n)) * 2^c2(log(n))
                            = c1(log(n)) * n^c2
                            = O(n^c2log(n)) for some c2
so the key required to build a truely random function in Func(d) has length polynomial in n
and the scheme permits a key of polynomial length, thus permits truely random functions

3.9
Given a pseudorandom function F that requires a key k of length n, for any polynomial l:
    uniformly sample a random string s ∈ {0, 1}^n
    uniformly sample another random string ctr ∈ {0, 1}^n, regard ctr as a number in binary
    for i from 0 to l(n) / n, compute F(s, (ctr + i) mod 2^n)
    a single F(s, ctr') have length n, combined has length l(n) in total
    concatenate and truncate the result to get G(s, 1^l(|s|))
if F is a pseudorandom function, from the perspect of a polynomial time adversary:
    F(s, ctr + i) and F(s, ctr + j) for any different i, j should be totally random and independent
since l is a polynomial, l(n) / n < 2^n, all (ctr+i) mod 2^n will be pairwise different
if a distinguisher D can distinguish r from G(s, 1^|r|) for |r| = l(|s|),
    |Pr[D(r) = 1] - Pr[D(Gl(s)) = 1]| = ε(n) 
where ε is non-negligible and s <- {0, 1}^n, r <- {0, 1}^l(n)
then another distinguisher D' can distinguish Fk from f <- Func(n), constructed as:
    uniformly sample a random string ctr ∈ {0, 1}^n
    query O(ctr + i) for i = 0 to l(n) / n
    concatenate the result and feed it to D, output 1 if D outputs 1, vice versa
if the oracle of D' is f <- Func(n), then O(ctr), O(ctr+1), .., O(ctr + l(n) / n) is equivalent to r <- {0, 1}^l(n)
    Pr[D'(f, n) = 1] = Pr[D(r) = 1]
if the given oracle is F(s) = F(k, s), then D' is equivalent to G and
    Pr[D'(Fk, n) = 1] = Pr[D(G(k)) = 1], k <- {0, 1}^n
that means
    |Pr[D'(f, n) = 1] - Pr[D'(Fk, n) = 1]| = ε(n)
so by contradiction, such a distinguisher D cannot exist, G is a variable-length pseudorandom generator

3.10
define a distinguisher D as:
    query O(0^n), get c1
    query O(1^n), get c2
    if c1 = ~c2, output 1; otherwise output 0
for any Fk, G'(k) is fixed and 
    G'(k) xor 0^n = G'(k)
    G'(k) xor 1^n = ~G'(k)
so D will always output 1, Pr[D(Fk, n) = 1] = 1
for f <- Func(n), f(1^n) and f(0^n) are independent strings in {0, 1}^n
so Pr[D(f, n) = 1] = Pr[f(0^n) = ~f(1^n)] = 1/2^n
|Pr[D(Fk, n) = 1] - Pr[D(f, n) = 1]| = 1 - 1/2^n is non-negligible, F is not pseudorandom

3.11
for a pseudorandom permutation F and a random permutation f <- Perm(n)
for any polynomial time distinguisher D, there exists a negligible function ε that
    |Pr[D(f, n) = 1] - Pr[D(Fk, n) = 1]| <= ε1(n)
the only way to distinguish a random permutation and a random function is to find some x, y that f(x) = f(y)
but for q different queries, the probability of finding such x and y is:
    coll(q, |{0,1}^n|) <= q^2 / 2^(n+1)
when q is polynomial, this probability is negligible, that means for any polynomial time distinguisher D:
    |Pr[D(f, n) = 1] - Pr[D(g, n) = 1]| <= ε2(n)
where f <- Func(n), g <- Perm(n), ε2 is a negligible function
thus f, g sampled as above:
    |Pr[D(f, n) = 1] - Pr[D(Fk, n) = 1]|    <= |Pr[D(f,n) = 1] - Pr[D(g,n) = 1]| + |Pr[D(g,n) = 1] - Pr[D(Fk,n) = 1]|
                                            <= ε1(n) + ε2(n), which is negligible
so Fk is also indistinguishable from a random function, Fk is a pesudorandom function

3.12
a encryption scheme Π = (Gen, Enc, Dec) has perfect CPA secrecy if for any adversary with unlimited computation power:
    Pr[PrivK(A, Π, n) = 1] = 1/2
while A has access to an oracle Enck, so this condition is stronger than normal perfect secrecy
construct an adversary that
    1. output two messages m0 = 0^n and m1 = 1^n
    2. on receiving the challenge ciphertext c, encrypt m0 with the oracle once and compare the result to c
    3. if the query in step 2 results c, output 0; otherwise output 1
assume b = 1:
    since the key is fixed in the experiment, 
    result of step 2 cannot be c or m0, m1 encrypts to the same ciphertext with the same key
    so A always successfully output b' = b = 1, Pr[b' = 1 | b = 1] = 1
assume b = 0:
    the challenge ciphertext and the oracle query is encrypted independently
    with probability Pr[C = c | M = m0]^2 = Pr[C = c]^2 (by normal perfect secrecy) they will be the same ciphertext
    as c is given as the challenge ciphertext, Pr[C = c] > 0 => Pr[b' = 0 | b = 0] = Pr[C = c]^2 > 0 
accordingly:
    Pr[PrivK(A, Π, n) = 1]  = Pr[b' = b]
                            = Pr[b' = 0 | b = 0] * Pr[b = 0] + Pr[b' = 1 | b = 1] * Pr[b = 1]
                            = Pr[b' = 0 | b = 0] / 2 + 1/2
                            > 1/2
thus no encryption scheme can be perfectly CPA secret

3.13
let F be a pseudorandom permutation, define F' to be
    F'(k, k) = 0^|k|
    F'(k, F^-1(0^|k|)) = F(k, k)
    F'(k, m) = F(k, m) otherwise
then F' is still a permutation as F' just swapped the corresponding value between k and F^-1(0^|k|)
if F is indistinguishable, so is F'
because F' and F only differ at 2/2^n unknown fraction of their domain (both k and F^(0^|k|) unknown to some D)
that makes F and F' indistinguishable in polynomial time
by the transitivity of indistinguishability (in problem 3.11), F' and a random permutation are indistinguishable
but with oracle access of F'^-1, the key can be easily got by F'k^-1(0^|k|) = k
with the key, compare the oracle O(m) with F(k, m) for some input m
F' and f <- Perm(n) are distinguishable with probability 1 - ε(n) for some negligible ε

3.14
Dec: compute F^-1(k, c) and take the last n/2 bits
define an alternative scheme Π' by replacing Fk with a random permutation f
in scheme Π', f(rm) for any m is totally random, and for an adversary A that querys the oracle g(n) times:
a.  if no query result equals to the challenge ciphertext, D gained no information about f^-1(c), A can only guess
b.  if any query O(m) = c, m is the plaintext been encrypted in the experiment, A then compare it to m0 and m1 for b'
    this only happens when m = mb and the two encryption used the same r, with probability p(n) <= 1/2^|r| = 1/2^(n-1)
accordingly, 
    Pr[PrivK(A, Π', n) = 1] <= Pr[b' = b | no O(m) = c] * (1 - p(n)) + Pr[b' = b | some O(m) = c] * p(n)
                            = 1/2 * (1 - p(n)) + 1 * p(n)
                            = 1/2 + p(n) / 2
                            <= 1/2 + 1/2^n
if an adversary can succeed with non-negligible probability with scheme Π, it can distinguish Fk and f
this scheme do not perform the xor operation in construction 3.24, but requires F to be a keyed permutation

3.15
a.  assuming G(k) being a pseudorandom generator, G'(k) = G(k)G(k+1) is not necessarily a pseudorandom generator
    let G be a pseudorandom generator {0, 1}^n -> {0, 1}^l(n), l(n) >= n + 2, define G': {0, 1}^(n+1) -> {0, 1}^l(n):
        G'(s||0) = G(s)
        G'(s||1) = G(s)
    if some D can distinguish G'(s) and r <- {0, 1}^l(n), s <- {0, 1}^n+1
        Pr[D(G'(s)) = 1]    = Pr[D(G'(s)) = 1 | s = s'||0]*Pr[s = s'||0] + Pr[D(G'(s)) = 1 | s = s'||1]*Pr[s = s'||1]
                            = Pr[D(G(s')) = 1] / 2 + Pr[D(G(s')) = 1] / 2
                            = Pr[D(G(s')) = 1] for s' <- {0, 1}^n
        |Pr[D(r) = 1] - Pr[D(G'(s)) = 1]| = |Pr[D(r) = 1] - Pr[D(G'(s')) = 1]|
    D is also a distinguisher of G, by contradiction, D may not exist => G' is a pseudorandom generator
    but for every even s, G'(s) = G'(s + 1)
    if the adversary output m0 = 0^(2n+2), m1 = 0^(n+1)1^(n+1)
    by comparing the first and last half of the ciphertext, it may succeed with probability nearly 3/4
b.  key space is empty, no way to be secure
c.  indistinguishable, for f <- Func(n), f(0^n) is random, makes the scheme analogous to one time pad
    if an adversary can break the scheme, it can distinguish Fk and f
    not CPA-secure, Enc is not probabilistic
d.  analogous to CTR mode of operation, thus CPA-secure

3.16
from the second encryption, the scheme is no longer probabilistic, thus cannot be CPA-secure
namely let the adversary calculate m2 = (IV+1) xor (IV xor m0) and query it, get c', compare c' with c
if mb = m0, c' = c
if mb = m1, c' != c
the adversary can break the scheme with certainty

3.17
ECB:    mi = F^-1(k, ci)
CBC:    m1 = F^-1(k, c1) xor IV
        mi = F^-1(k, ci) xor ci-1
OFB:    m1 = F(k, IV) xor c1
        mi = F(k, IVi-1) xor c1, IVi = F(k, IVi-1)
CTR:    mi = F(k, ctr + i) xor ci
ECB and CTR are fully parallelizable, OFB partially

3.18
if an adversary A can break this scheme, define a distinguisher D that:
    give A 1^n, A outputs m0 and m1
    sample b <- {0, 1}, sample ctr <- {0, 1}^n
    encrypt mb as CTR mode of operation but replace Fk with queries to O with ctr+i
    if A queries Enck, sample a new ctr' <- {0, 1}^n and do the encryption with O(ctr'+i)
    A outputs b'
    outputs 1 if b = b'; 0 otherwise
if O = Fk, A is running PrivK(A, Π, n), Pr[D(n) = 1] = Pr[PrivK(A, Π, n) = 1] = 1/2 + ε(n)
if O = f, A is running PrivK(A, Π', n), Pr[D(n) = 1] = Pr[PrivK(A, Π', n) = 1] <= 1/2 + 2q(n)^2 / 2^n
then |Pr[D(Fk, n) = 1] - Pr[D(f, n) = 1]|   = |ε(n) - 2q(n)^2 / 2^n|
if ε(n) is non-negligible, there is a distinguisher of F, by contradiction Π must be CPA-secure

3.19
a.  for Fk to be a pseudorandom function, 
    Fk should be indistinguishable from a random function f: {0, 1}^lin(n) -> {0, 1}^lout(n) in polynomial time
    again assume the adversary's running time is bounded by a polynomial q
        q(n)/max(lin(n), lout(n)) is an upper bound of the number of queries
        q(n) is an upper bound of the length of any query string
    ctr* <- {0, 1}^lin(n) for the encryption of m0 and m1, ctri <- {0, 1}^lin(n) for ith query to the encryption oracle
    lin(n) may not be logarithm, or 2^lin(n) will be polynomial and for big enough q overlap is guarenteed
        Pr[Overlapi] = (2q(n) - 1) / 2^lin(n)
        Pr[Overlap] <= ∑Pr[Overlapi]
                    = (q(n) / max(lin(n), lout(n))) * (2q(n) - 1) / 2^lin(n)
                    <= 2q(n)^2 / (max(lin(n), lout(n)) * 2^lin(n))
    if Π is CPA-secure, Pr[Overlap] have to be negligible
    thus 1 / (lout(n) * 2^lin(n)) has to be negligible, lin(n) may not be logarithm
    it doesn't matter how small lout(n) is: 
    even lout(n) = 1 it's a totally random bit, can be concatenated to totally random stream assuming no overlap of ctr
b.  for fixed length message of length l(n), for a adversary whose running time is bounded by a polynomial q(n):
        l(n) is an upper bound of the length of any query string 
        q(n) / max(lin(n), l(n)) is an upper bound of the number of queries
    if l(n) / lout(n) >= 2^lin(n), an overlap is guaranteed to happen during a single encryption
    for two choices of ctr1 and ctr2, there is an overlap iff:
        ctr2 - l(n) / lout(n) <= ctr1 <= ctr2 + l(n) / lout(n)
        Pr[Overlapi]    <= 2l(n) / (lout(n) * 2^lin(n))
        Pr[Overlap]     <= (q(n) / max(lin(n), l(n))) * (2l(n) / (lout(n) * 2^lin(n)))   
                        = 2q(n)l(n) / (max(lin(n), l(n)) * lout(n) * 2^lin(n)) 
    if Π is indistinguishable encryption, l(n) / lout(n) < 2^lin(n) for every n > 1
    if Π is CPA-secure, Pr[Overlap] is negligible, lin(n) cannot be logarithm

3.20
a.  if there is a D that distinguishes Fk and f with oracle Fk$ and f$, construct D' as:
        D' runs D as a subroutine
        every time D queries g$:
            sample r <- {0, 1}^n
            query g(r)
            output <r, g(r)> to D
        if D outputs 1, output 1; otherwise output 0
    then 
        Pr[D'(Fk, n) = 1] = Pr[D(Fk$, n) = 1]
        Pr[D'(f, n) = 1] = Pr[D(f$, n) = 1]
        |Pr[D'(Fk, n) = 1] - Pr[D'(f, n) = 1]| = |Pr[D(Fk$, n) = 1] - Pr[D(f$, n) = 1]|
    if D' can distinguish Fk$ and f$, then D can distinguish Fk and f
    if F is a pseudorandom function, F is also a weakly pseudorandom function
b.  F is not pseudorandom, since for any odd seed x
        F(k, x) = F(k, x+1) 
    which only happens with negligible probability for a real random function f
    with a weaker oracle Fk$, the difference is only noticeable when ri = rj + 1 for some ri, rj <- {0, 1}^n
    consider x = x + 1 for odd x, then the problem reduced to the birthday problem and 
        coll(q, N) <= q^2 / 2N <= q^2 / 2^n, q is the total number of queries
    since D is efficient, q is polynomial and coll(q, N) is negligible
    thus F is weakly pseudorandom
c.  consider the weak pseudorandom function F from part b
    F(k, x) = F(k, x+1) for every odd x
    define an adversary A that:
        outputs m0 = 0^2n, m1 = 0^n1^n
        on receiving the challenge ciphertext c, parse c = c1 || c2, compare c1 and c2
        if ctr is odd:
            if c1 = c2, output 0, otherwise 1
        if ctr is even:
            output b <- {0, 1}
    if ctr is odd and b = 0, c1 = F(k, ctr) xor 0^n = F(k, ctr+1) xor 0^n = c2, b' = 0
    if ctr is odd and b = 1, c1 != c2
    if ctr is even, Pr[b' = b] = 1/2
    so A succeeds with probability 3/4, this scheme does not have indistinguishable encryptions
d.  OFB mode with a weak pseudorandom function is CPA-secure, if the message length is fixed as n
    a distinguisher D can 
        sample IV <- {0, 1}^n
        output <IV, F(k, IV) xor m>
    i.e. supply all it needs to break the scheme for some adversary A
    then if A can break the scheme, D can distinguish Fk with the weaker oracle

3.21
define a new scheme Π that:
Gen:    sample k1, k2 <- {0, 1}^n, set k1, k2 as the key for Π1 and Π2, k = <k1, k2>
Enc:    for |m| = n:
        sample r <- {0, 1}^n 
        encrypt m1 = r, m2 = m xor r seperately with Π1 and Π2, get c1 and c2
        (which one encrypted by which scheme doesn't matter)
        output <c1, c2> as the ciphertext 
Dec:    
        on receiving <c1, c2>, decrypt seperately with Π1 and Π2, get m1 and m2
        calculate m = m1 xor m2
an encryption oracle of Enck is equivalent to two encryption oracle Enc1k1 and Enc2k2 combined
if some adversary A1 can break Π1 with an oracle Enc1k1
    Pr[PrivK(A1, Π1, n) = 1] = 1/2 + ε1(n) and ε1 is non-negligible
and Π2 is CPA-secure
if any adversary A can break Π with oracle Enck,
    Pr[PrivK(A, Π, n) = 1] = 1/2 + ε(n) and ε is non-negligible
define an adversary A2 that, with an oracle Enc2k2:
    sample k1 <- {0, 1}^n
    simulate an oracle Enc1k1 and run A to get m0', m1' (Enck equivalent to Enc1k1 and Enc2k2 combined)
    sample r <- {0, 1}^n, define m0 = r xor m0', m1 = r xor m1', output m0 and m1
    on receiving the challenge ciphertext c, give A <Enc1(k1, r), c> and <Enc1(k1, r), Enc2(k2, m0)>
    answer following queries of A as before, until A outputs b'
    outputs b' as well 
if b = 0, c and Enc2(k2, m0) is completely indistinguishable and Pr[b' = b] = 1/2 for any A
if b = 1, A is running in experiment PrivK(A, Π, n), Pr[b' = b] = 1/2 + ε(n)
so Pr[PrivK(A2, Π2, n) = 1] = 1/2 + ε(n)/2, Π2 is not CPA-secure, by contradiction Π is CPA-secure
by a symmetric argument, if Π is not CPA-secure, neither of Π1 nor Π2 can be CPA-secure
so if one of Π1 and Π2 is CPA-secure, Π is CPA-secure

3.22
all of them are block ciphers with plain IV
an adversary can require the decryption of <IV, c1> to get the first n bits of the message mb, thus determine b

Chapter 4
4.1
if t(n) = O(log(n)), there are only 2^t(n) = O(n^c) possible tags
if an adversary outputs (m, t) for random m <- {0,1}^n and t' <- {0,1}^t(n)
    Pr[Mac-forge(A, Π, n) = 1]  = ∑t Pr[Mac(k, m) = t ∧ t = t' | M = m]
                                = ∑t Pr[Mac(k, m) = t | M = m] * Pr[t = t' | M = m] // independent events
                                = ∑t Pr[Mac(k, m) = t | M = m] * Pr[t = t'] // t' independent from m
Pr[t = t'] = 1 / 2^t(n) for any t
∑t Pr[Mac(k, m) = t | M = m] = 1 implies there must be some t that Pr[Mac(k, m) = t | M = m] >= 1 / 2^t(n)
    Pr[Mac-forge(A, Π, n) = 1]  >= 1 / (2^t(n))^2
since 2^t(n) is polynomial, 1 / 2(2^t(n))^2 is non-negligible and Π is not secure

4.2
by authenticate two message m0||m1 and m2||m3, an adversary can get tags of m2||m1 and m0||m3

4.3
can break with exactly the same method in problem 4.2

4.4
a.  for any message m = m0||m1, m0 = m1, |m0| = |m1| = n 
    the computed tag will be F(k, m0) xor F(k, m1) = 0^n
b.  define an adversary that:
        sample m0 <- {0,1}^n
        query m0||m0, get <r, t0>
        define m1 = ~m0 
        output <m1||m1, <r, t0>>
    F(k, r) xor F(k, m0) xor F(k, m0) = F(k, r), so t0 = F(k, r)
    replace m0 with m1 won't change the tag
c.  it's still easy to forge messages that <1>||m0 = <2>||m1
    choose different m0, m1 <- {0,1}^(n/2 - 2) and query for <<1>||m0||01, <2>||m0||10> to recover some F(k, r)
    then the adversary in part b can be reused

4.5
a.  analogous to CCA-security
    define this stronger message authentication experiment Mac-forge-vrfy(A, Π, n) as:
        1.  a random key k is generated by running Gen(1^n)
        2.  the adversary A is given input 1^n and oracle accesses to Mac(k, _) and Vrfy(k, _, _)
            the adversary eventually outputs a pair (m, t)
            let Q denote the set of all messages that A asked to either oracle
        3.  the output of the experiment is defined to be 1 iff Vrfy(m, t) = 1 and m ∉ Q
    A message authentication code Π is secure if for all polynomial-time adversary A there is some negligible function
        Pr[Mac-forge-vrfy(A, Π, n) = 1] <= negl(n)
    a real-world application may be the receiving party acts visibly differently on receiving valid and invalid tags
    like the recent attack on shadowsocks
b.  assume an adversary A with two oracles can break Π with probability ε(n)
    the number of queries it makes to vrfy oracle is bounded by a polynomial q
    define a new adversary A' with access to only Mac oracle that:
        run A as a subroutine 
        pass input 1^n to A
        sample i <- {1 .. q(n)}
        when A queries the Mac oracle, query its own Mac oracle and forward the result to A
        when A queries the Vrfy oracle with (m, t):
            if m is previously queried in Mac oracle and the result is t, return 1 to A
            if m is never queried before and this is the ith query to the vrfy oracle, output (m, t)
            otherwise pass 0 to A
        output whatever A outputs
    define event Vrfy as A will ever query vrfy oracle with a fresh message and get positive answer
    then A' simulates A correctly if i is the first time Vrfy occurs and Π has unique tags
        negl(n) >= Pr[Mac-forge(A', Π, n) = 1] >= Pr[Vrfy] / q(n)
        Pr[Vrfy] <= q(n) / negl(n)
    if Vrfy never happens, either A never queries vrfy oracle or all such queries have result 0
    define another adversary A* that:
        run A as a subroutine
        pass 1^n to A
        when A queries the Mac oracle, query its own Mac oracle and forward the result to A
        when A queries the vrfy oracle with (m, t):
            if m is previously queried in Mac oracle and the result is t, return 1 to A
            otherwise return 0
        output whatever A outputs
    again
        negl(n) >= Pr[Mac-forge(A*, Π, n) = 1]  >= Pr[Mac-forge-vrfy(A, Π, n) = 1 ∧ ¬Vrfy]
        Pr[Mac-forge-vrfy(A, Π, n) = 1] <= Pr[Vrfy] + Pr[Mac-forge-vrfy(A, Π, n) = 1 ∧ ¬Vrfy]
                                        <= q(n) / negl1(n) + negl2(n)
    thus security and unique tags implies this stronger definition of security
c.  thanks https://people.seas.harvard.edu/~salil/cs127/fall13/ps8.pdf
    let Π = (Gen, Mac, Vrfy) be the secure authentication code defined in construction 4.3
    define Π' = (Gen, Mac', Vrfy') that
        Mac':   on input m, let t = Mac(k, m), output t||0^n
        Vrfy':  on input <m, t>, parse t = t'||pad, where |pad| = n = |k|
                output 1 if Vrfy(k, m, t') = 1 and pad = 0^n or #1(pad)-th bit of the key is 1
                output 0 otherwise
    since the adversary have to both satisfy the vrfy algorithm and guess one bit of the key,
        Pr[Mac-forge(A, Π', n) = 1] <= Pr[Mac-forge(A, Π, n) = 1] <= negl(n)
    but with a vrfy oracle, an adversary can:
        query the Mac oracle for some m and get <m, t||0^n>
        make n queries to the vrfy oracle of <m, t||1^i0^(n-i)> to recover the key
        calculate t for some new m', output <m', t>
    and break the stronger sense of security with certainty

4.6
no
again use the weak pseudorandom function define in part b of problem 3.20
F(k, m||0) = F(k, m||1) for every m <- {0,1}^(n-1)
an adversary only need to query some m||0, get <m||0, t> and output <m||1, t>
by the definition <m||1, t> is valid

4.7
the only part changed in the proof of Theorem 4.6 is the proof of claim 4.8:
    Pr[Mac-forge(A, Π, n) = 1 ∧ ¬Repeat ∧ ¬Forge] = 0 
let <m, t> is the output, m = m1 .. md, t = <r, t1 .. td>
again it has 3 cases:
    1.  the identifier r is different from all identifiers used by the Mac oracle: unchanged
    2.  the identifier was used in exactly one of the Mac tag obtained by A from Mac oracle
        let <m', t'>, m' = m'1 .. m'd', t' = <r, t1' .. t'd'> be result of that query:
        a.  |m'| < |m|, m contains more blocks than m', obviously some block r||b||i||mi was never authenticated
        b.  |m'| > |m|, then the last block r||1||d||md was never authenticated
            the only block in t' with b = 1 is the last block r||1||d'||md', and d != d'
        c.  |m'| = |m|, then there is some i that mi != m'i, then r||b||i||mi was never authenticated
    3.  r was used in more than one of the Mac tags obtained by A from its oracle: again can't happen
the tags are slightly shorter this time

4.8
for messages of length n, Mac(k, m) = F(k, 0^n xor m) = F(k, m)
an adversary can query for some message m, obtain <m, t> and output <m||0^n, Mack(t)>
and Mac(k, m||0^n) = F(k, Mac(k, m) xor 0^n) = F(k, t) = Mac(k, t)

4.9
a.  for messages of length n, Mac(k, m) = F(k, IV xor m)
    define an adversary A that:
        sample m <- {0,1}^n 
        query m, obtain IV||t
        calculate m' = ~m, IV' = ~IV 
        output <m', IV'||t>
    since IV xor m = IV' xor m', F(k, IV' xor m') = F(k, IV xor m) = t
    A breaks the authentication code with certainty
b.  define an adversary A that:
        sample m1, m2 <- {0,1}^n
        query m = m1||m2, obtain t = t1||t2
        calculate m1' = t1 xor m2, m2' = t2 xor m1
        output <m1'||m2', t2||t1>
    t1' = F(k, t1 xor m2) = t2 
    t2' = F(k, t1' xor m1') = F(k, t2 xor t2 xor m1) = F(k, m1) = t1
    thus A succeeds if m1||m2 != m1'||m2'
    as F is pseudorandom, m1 = m1' = t1 xor m2 only happends with negligible probability
    A succeeds with probability 1 - negl(n)

4.10
define the second pre-image finding experiment Hash-sec-pre(A, Π, n):
    1.  A key s is generated by running Gen(1^n), an input x <- {0,1}* is sampled
    2.  The adversary A is given s and x, outputs x' ∈ {0,1}*
    3.  The output of the experiment is defined to be 1 iff x != x' and H(s, x) = H(s, x')
a hash function Π = (Gen, H) is second pre-image resistant if for all polynomial time adversary A:
    Pr[Hash-sec-pre(A, Π, n) = 1] <= negl(n)
define the preimage finding experiment Hash-pre(A, Π, n):
    1.  A key s is generated by running Gen(1^n), an input x <- {0,1}* is sampled, y = H(s, x)
    2.  The adversary A is given s and y, outputs x' ∈ {0,1}*
    3.  The output of th experiment is defined to be 1 iff H(s, x') = y
a hash function Π = (Gen, H) is pre-image resistent if for all polynomial time adversary A:
    Pr[Hash-pre(A, Π, n) = 1] <= negl(n)
if for some hash function Π, there is some A that 
    Pr[Hash-sec-pre(A, Π, n) = 1] = ε(n)
define another A' that:
    run A as a subroutine
    upon input s, sample x <- {0,1}* and pass s, x to A
    when A outputs x', output x and x'
A' perfectly simulates A, success of A implies success of A'
    Pr[Hash-coll(A, Π, n) = 1] = Pr[Hash-sec-pre(A, Π, n) = 1] = ε(n)
if ε(n) is non-negligible, Π is not collision-resistent
thus collision-resistance implies second pre-image resistance
if for some hash function Π, there is some A that
    Pr[Hash-pre(A, Π, n) = 1] = ε(n)
the domain of Hs is infinite and the range is finite
with only negligible probability a x <- {0,1}* will be mapped to a Hs(x) with finite pre-image
so it's safe to assume for a uniformly sampled x <- {0,1}*, H(s, x) has infinite pre-image
since A is only given y = H(s, x), x' and x are independent pre-image of Hs and
    Pr[x = x']  = Pr[x = x' | Hs(x) has finite pre-image] * Pr[Hs(x) has finite pre-image]
                + Pr[x = x' | Hs(x) has infinite pre-image] * Pr[Hs(x) has infinite pre-image]
                <= negl(n)
define another A' that:
    run A as a subroutine 
    upon input s, sample x <- {0,1}*, define y = H(s, x), pass s, y to A
    when A outputs x', output x' as well
then Pr[Hash-sec-pre(A, Π, n) = 1]  = Pr[Hash-pre(A, Π, n) = 1 ∧ x != x']
                                    = Pr[Hash-pre(A, Π, n) = 1] - Pr[Hash-pre(A, Π, n) = 1 ∧ x = x']
                                    >= ε(n) - Pr[x = x']
                                    = ε(n) - negl(n)
if ε(n) is non-negligible, A' breaks second pre-image resistance
thus second pre-image resistance implies pre-image resistance

4.11
a.  obviously, a collision in Π is directly a collision in Π1 and Π2 with corresponding keys
    if an adversary A can break Π with non-negligible probability, deifine a new adversary A1 for Π1 that:
        upon receiving s1, generate s2 <- Gen2(1^n) (1^n is implicit in s1)
        run A with (s1, s2), A outputs x and x'
        output x and x'
    if x and x' is a collision in Π,
        H1(s1, x)||H2(s2, x) = H1(s1, x')||H2(s2, x')
        H1(s1, x) = H1(s1, x')
    so x and x' is also a collision in Π1 and
        Pr[Hash-coll(A1, Π1, n) = 1] >= Pr[Hash-coll(A, Π, n) = 1]
    by a symmetric argument,
        Pr[Hash-coll(A2, Π2, n) = 1] >= Pr[Hash-coll(A, Π, n) = 1]
    if Π is not collision resistent, neither Π1 nor Π2 is
    thus if either Π1 or Π2 is collision resistant, Π is collision resistant
b.  a second pre-image x' in Π is obviously a second pre-image in Π1 and Π2
    but when given H1(s1, x), x cannot be calculated and A1 cannot give H1(s1, x)||H2(s2, x) to A
    the break cannot be transferred from A to A1 by the same idea
    namely if Π1 is pre-image resistent and Π2 just outputs x
    upon receiving H1(s1, x)||H2(s2, x) = H1(s1, x)||x
    an adversary can just output x can break pre-image resistance with certainty

4.12
let Π' = (Gen, H^2), if an adversary A' can break Π' with non-negligible probability, define A for Π that:
    upon receiving s, run A' with s, A' outputs (x, x')
    if H(s, x) = H(s, x'), output (x, x')
    if H(s, x) != H(s, x'), output (H(s, x), H(s, x'))
if x, x' is a collision in Π', H(s, H(s, x)) = H(s, H(s, x')) and x != x'
    if H(s, x) = H(s, x'), then x, x' is a collision in Π
    if H(s, x) != H(s, x'), then H(s, x), H(s, x') is a collision in Π as they hashes to the same result
then 
    Pr[Hash-coll(A, Π, n) = 1] >= Pr[Hash-coll(A', Π', n) = 1]
and the collision resistance of Π implies the collision resistance of Π'

4.13
assume an adversary A can break Π = (Gen, H) with non-negligible probability, define A' for (Gen, h) that:
    upon receiving s, pass s to A and A outputs (x, x')
    pad x and x' to multiply of l(n), parse the result as l(n) bit blocks x = x1 .. xb and x' = x'1 .. x'b'
    define z0 = 0^l(n)
    for i = 1 .. b, calculate every zi = h(s, zi-1||xi)
    for j = 1 .. b', calculate every wj = h(s, wj-1||x'j)
    if there exists some i and j that zi-1||xi != wj-1||x'j but zi = wj, output zi-1||xi and wj-1||x'j
    otherwise output 0, 1
as in proof of Theorem 4.14:
if x != x' and H(s, x) = H(s, x'), there must be some collision between different zi-1||xi and wj-1||x'j
thus
    Pr[Hash-coll(A', (Gen, h), n) = 1] >= Pr[Hash-coll(A, Π, n) = 1]
and the collision resistance of (Gen, h) implies the collision resistance of (Gen, H)

4.14
pad and parse the input to B blocks of length l'(n) - l(n), define z0 = 0^l(n) as well 
then |zi-1||xi| = l'(n) is a valid input to hs, |zi| = l(n) for all i
the proof of its collision resistance unchanged

4.15
a.  x and x padded with 0 to a multiply of l(n) hashes to the same result now 
b.  if (x, x') is a collision in this code, zb||L = z'b'||L', zb = z'b' and L = L'
    then h(s, zb||L) = h(s, z'b'||L') and (x, x') is also a collision in (Gen, H)
    so the collision resistance of (Gen, H) implies collision resistance of this code
c.  a collision (x, x') in this scheme implies IV||zb+1 = IV'||z'b+1, the two application chooses the same IV
    since the IV in (Gen, H) can be replaced by any constant, define z0 = IV and (x, x') is also a collision in (Gen, H)
    so the collision resistance of (Gen, H) implies collision resistance of this code 
d.  if (x, x') is a collision in this code, h(s, zb||L) = h(s, z'b'||L')
    if L != L', (zb||L, z'b'||L') is a collision in (Gen, h)
    if L = L', there exists some i that xi != x'i, and zi-1||xi != z'i-1||x'i
    let i* be the maximal of such i, then there must be some i* <= j <= b+1 that
        zj-1||xj != z'j-1||x'j and h(s, zj-1||xj) = h(s, z'j-1||x'j)
    and that's a collision in (Gen, h)
    so the collision resistance of (Gen, h) implies collision resistance of this code
e.  for a collision resistant hash function (Gen, g), define a new hash function (Gen, h) that:
        h(s, <2l(n)>||x) = <l(n)> for some fixed x ∈ {0,1}^n
        h(s, x) = 1g(s, x) otherwise
    where gs: {0,1}^2l(n) -> {0,1}^(l(n)-1) and <k> is the binary representation of k padded to l(n) bits
    then hs: {0,1}^2l(n) -> {0,1}^l(n), <2l(n)> starts with 0 as 2l(n) < 2^l(n)
    <l(n)> is the only hash code starts with 0, a collision in (Gen, h) must be a collision in (Gen, g)
    implies (Gen, h) is collision resistant
    then for any message x' ∈ {0,1}^l(n),
        H(s, x||x') = h(s, h(s, <2l(n)>||x)||x') = h(s, <l(n)>||x') = H(s, x')
    and (x, x||x') is a collision in (Gen, H)

4.16
let (Gen', h) be a fixed-length collision-resistant hash function, hs: {0,1}^l'(n) -> {0,1}^l(n)
let (Gen', H) be the result of applying the Merkle-Damgard transform described in problem 4.14 to (Gen, h)
let IV be fixed constant string of length l(n), opad and ipad be fixed constant strings of length l'(n) - l(n)
define a MAC as:
    Gen:    generate s <- Gen'(1^n), sample k <- {0,1}^(l'(n) - l(n)), output (s, k)
    Mac:    on input m of length L, output the tag:
                t = H(s, (k xor opad)||H(s, k xor ipad)||m)
            using the fixed IV
    Vrfy:   on input (m, t), output 1 iff t = Mac((s, k), m)

4.17
s is not kept secret, and adversary can calculate
even if s is secret, collision resistance puts no restriction on the distribution of s, and the distribution is public
the underlying hash function (Gen', h) may not have that much variation of s <- Gen'(1^n)
if there is only few s may ever be generated by Gen'(1^n)
h(s, m) can be computed correctly with non-negligible probability
assume |k| = l(n), an adversary can query for Mac(k, ε) = H(s, k) = h(s, h(s, IV||k)||<l(n)>) = tk
then it can calculate h(s, tk||<2l(N)>) = tb, and
    Mac(k, <l(n)>) = H(s, k||<l(n)>)    = h(s, h(s, h(s, IV||k)||<l(n)>)||<2l(n)>)
                                        = h(s, tk||<2l(n)>)
                                        = tb
so if the adversary correctly outputs (<l(n)>, tb), it breaks the MAC
if for some s' that Pr[s = s'] is polynomial, the probability of tb to be correct is non-negligible by guessing s = s'
thus the adversary can break the MAC with non-negligible probability

4.18
for Construction 4.5, if for some valid (m, t)
assume an adversary A with oracle access to Mack but cannot query for m can find another different valid tag t' for m
then it must have find Mac(k, m) with a different identifer r' that
    t' = r', t'1 .. t'd
    t'i = Mac'(k, r'||l||i||mi)
since for any different m' != m A queried, a fresh r is chosen and a collision event ri = rj is negligible
assuming all such queries using different r (true with 1 - negl(n) probability),
only one query m' can have the same identifier as t'
    if |m| != |m'|, every block r||l||i||mi are different
    if |m| = |m'|, as m' != m, at least on one position i, mi != m'i
but then A have effectively forged a fresh pair (r'||l||i||mi, t'i) and breaks Π'
so A cannot success with non-negligible probability
since the encryption scheme in Construction 4.19 is CPA-secure,
encrypting a different message m' will never give Enck(m) or decryption is impossible
encrypting the same message m polynomial times will only give the same ciphertext c with negligible probability
(or an adversary has non-negligible probability to differ Enck(m0) and Enck(m1))
so an adversary attacking CCA-security, with 1 - negl(n) probability, is in the same (or weaker) situation to A
such an adversary only have negligible probability to find another valid tag when given (c, t)
denote the event it find another valid tag for any (c, t) as ValidTag
then
    Pr[PrivK(A, Π', n) = 1] <= Pr[ValidQuery ∧ ¬ValidTag]
                            + Pr[ValidTag] 
                            + Pr[PrivK(A, Π', n) = 1 ∧ ¬ValidQuery ∧ ¬ValidTag]
Pr[ValidTag] <= negl(n)
where Pr[ValidQuery ∧ ¬ValidTag] = Pr[ValidQuery] in the original proof
(if no (c, t') with fresh and valid t' is queried, the proof of Claim 4.21 remains true)
and Pr[PrivK(A, Π', n) = 1 ∧ ¬ValidQuery ∧ ¬ValidTag] = Pr[PrivK(A, Π', n) = 1 ∧ ¬ValidQuery] in the original proof
(similar for Claim 4.22)
thus Pr[PrivK(A, Π', n) = 1] <= 1/2 + negl(n) even if Π' uses MAC from Construction 4.5

4.19
if MAC has unique tags, authenticating a message twice will give the same tag
authenticating two different messages will only give the same tag with negligible probability
proof: if for some m0 and m1, Pr[Mac(k, m0) = Mac(k, m1)] = ε(n)
define an adversary A:
    query for m0, get t
    output (m1, t1)
then A succeeds with probability ε(n) and ε(n) must be negligible for secure MAC
define adversary A attacking CPA-security of encrypt-and-authenticate:
    outputs m0 and m1
    upon receiving c = (c', t), query for Enck(m0), get (c'', t')
    if t = t', output 0; otherwise output 1
then Pr[PrivK(A, Π, n) = 1] = Pr[t' = t | b = 0] / 2 + Pr[t' != t | b = 1] / 2
                            = 1/2 + (1 - Pr[t' = t | b = 1]) / 2
                            = 1/2 + (1 - negl(n)) / 2
                            = 1 - negl(n) / 2
thus Π is not CPA-secure

4.20
the encryption scheme in problem 3.14
it's CCA-secure (the problem text claimed so)
but for all ciphertext c there is a corresponding r||m that Fk(r||m) = c as F being a pseudorandom permutation
so there is Deck(c) = m for every c and there is no authenticated communication

4.21
let MAC be any authentication method, and Enc(k, m) just outputs plain m
then EncMac((k1, k2), m) = <m, t> with encryption-and-authenciation method
oracle access to EncMack is equivalent to Mack, Auth(A, Π', n) is equivalent to Mac-forge(A, ΠM, n)
obviously Pr[Auth(A, Π', n) = 1] = Pr[Mac-forge(A, ΠM, n) = 1] <= negl(n)
but the scheme is not secure at all

4.22
in any valid encryption scheme, different messages never encrypt to the same ciphertext
so if at the end of experiment Auth(A, Π', n), the adversary outputs (c, t) and Dec(k, (c, t)) = m != ⊥, m ∉ Q
then for any previous query m' to EncMack, EncMac(k, m') = (c', t'), c' != c
assume Pr[Auth(A', Π', n) = 1] = ε(n) for some A'
define an adversary A attacking experiment Mac-forge(A, ΠM, n) that:
    sample k1 <- GenE(1^n)
    run A' as a subroutine, when A' queries EncMack with m:
        calculate c = Enc(k, m)
        query Mack2(c) = t
        pass <c, t> to A'
    when A' outputs <c, t>, outputs <c, t> as well
denote all queries to Mack2 in this experiment by QM
if Dec(k1, <c, t>) = m != ⊥, m ∉ Q, then c ∉ QM and Vrfy(k2, c, t) = 1
    negl(n) >= Pr[Mac-forge(A, ΠM, n) = 1] >= Pr[Auth(A', Π', n) = 1] = ε(n)
and this scheme has authenticated communication
combined with Theorem 4.20, it's a secure message transmission scheme

Chapter 5
5.1
assume an adversary A can recover key with 100 queries to oracle Fk
define a distinguisher D with oracle access to a (potentially random) function f that:
    run A as a subroutine
    when A queries Fk with m, query f(m) and pass result to A
    denote Q = {m | m is queried so far}
    if A reports an error, output 0
    when A outputs a key k, choose a random m ∉ Q and calculate F(k, m), compare it to f(m)
    if F(k, m) = f(m), output 1; otherwise output 0
when f = Fk, D simulates A and A outputs k correctly, makes Pr[D(Fk, 1^n) = 1] = Pr[F(k, m) = f(m)] = 1
for invalid inputs (f(m) when f is not Fk), A either reports an error or output a wrong result 
if A reports error, only 2^n (those equal to some Fk) in all n! permutations in Perm(n) will not report an error, so
    Pr[D(f, 1^n) = 1 | A reports error] = 0
2^n / n! is negligible so 1 - 2^n / n! is not
if A gives wrong (random) answer, F(k, m) and f(m) is totally independent, makes 
    Pr[D(f, 1^n) = 1 | A gives wrong answer] = Pr[F(k, m) = f(m)] = 1 / 2^n
thus
    Pr[D(Fk, 1^n) = 1] - Pr[D(f, 1^n) = 1]  = 1 - (0 + 1 / 2^n)
is not negligible, F is not pseudorandom

5.2
using 8 S-boxes of 8 bits, the 4-bit α1 may be influenced by 4 S-boxes and 32 bits in ka
then combined with 4 bits from kb, 2^36 possibilities has to be tested
the probability of false positive is still 1/16, roughly 9 input/output pairs are needed to narrow down the answer
9 * 2^36 * 16 < 2^44 in total
if block size is 128 bits, the key must be extended to 256 bits or there is some dependency between ka and kb
the first 4 bits in the result of the first round still only influenced by 32 bits in ka
the probability of false positive still 1/16
but now there's twice the number of portions of ka have to be tested
complexity 9 * 2^36 * 32 < 2^45 in total

5.3
if Fk is 3-round substitution permutation network described in section 5.1
a one-bit difference in input in known position will be propagated to about 8 bits of the result in known position
when ctr is even, ctr and ctr+1 will only be different at the least significant bit, which is known
F(k, ctr) and F(k, ctr+1) will only be different at 8 known position
by choosing m0 = 0^2n and m1 = 0^n1^n, observe c1 and c2
if they are equal except that 8 bits, m0 must be encrypted, the adversary outputs 0; otherwise it outputs 1
if ctr is even, the adversary outputs 0 or 1 randomly
an adversary using this strategy always succeeds when ctr is odd, or with roughly 3/4 possibility in total

5.4
r permutations in a row is equivalent to a single permutation
r key-mixing, when the scheme is open, is equivalent to a single key-mixing
r substitution with a S-box Si is equivalent to one substitution with a S-box defined as Si^r
this construction is equivalent to a one-round substitution-permutation network
private key can be easily recovered in this construction

5.5
a.  (Lr, Rr) = (L0, R0) if r is even, (R0, L0) if r is odd
    a single round computes Li+1 = Ri, Ri+1 = Li xor 0^n = Li, effectively swaps the position of Li and Ri
b.  (L1, R1) = (R0, L0 xor R0)
    (L2, R2) = (L0 xor R0, R0 xor L0 xor R0) = (L0 xor R0, L0)
    (L3, R3) = (L0, L0 xor R0 xor L0) = (L0, R0)
    thus for any r, (Lr, Rr) = (Lk, Rk), k = r mod 3

5.6
in every round of DES
    E(~m) = ~E(m) as E only duplicates some bits, regardless of their exact value
    ~E(m) xor ~ki = E(m) xor ki by the definition of xor
    so f(~ki, ~m) = f(ki, m) for any sub-key
    assume (L'i, R'i) = (~Li, ~Ri)
    L'i+1 = ~Ri = ~Li+1
    R'i+1 = ~Li xor f(~ki, ~Ri) = ~Li xor f(ki, Ri) = ~(Li xor f(ki, Ri)) = ~Ri+1
    (L'i+1, R'i+1) = (~Li+1, ~Ri+1)
by induction, for all r ∈ N, an r round DES(k, x) = ~DES(~k, ~x)

5.7
query c0 = DESk(0^64) and c1 = DESk(1^64)
brute-force search for any key in {0,1}^56, but for every trial k':
    test if DES(k', 0^64) = c0 and if ~DES(k', 0^64) = c1
    if the first equation holds, with high probability k = k'
    if the second equation holds, by problem 5.6 with high probability k = ~k'
thereby one calculation DES(k', 0^64) can rule out 2 possible keys k' and ~k'
and only 2^56 / 2 = 2^55 calculation is necessary

5.8
for one round in the computation of DESk:
    Li+1 = Ri 
    Ri+1 = Li xor f(ki, Ri)
for one round in the computation of DESk^-1:
    Li = Ri+1 xor f(ki, Li+1)
    Ri = Li+1
swap the roles of L and R in DESk^-1 then:
    L'i = Ri 
    R'i = Li
    L'i = R'i+1
    R'i = L'i+1 xor f(ki, L'i+1)
and the result of the final round in DESk^-1 is swapped to get (R'0, L'0) = (L0, R0)
the only difference between DESk and DESk^-1 is the order of ki applied

5.9
a.  when k = 0^56, every sub-key chosen as a portion of k is also 0^48
    every ki = kj and by problem 5.8, DESk = DESk^-1, DES(k, DES(k, m)) = m
    an adversary can always query DESk(c) on receiving a previous query (m, c)
    if DESk(c) = m, with high probability k is some special value
b.  1^56
    0^28||1^28
    1^28||0^28
c.  asymptotically not, only with 1 / 2^54 probability the four keys will be chosen
    also these keys are problematic in any encryption/permutation scheme
    they are highly regular and must be in some rainbow table
    
5.10
a.  in this variation of DES:
        Li+1 = Ri 
        Ri+1 = Li xor ki xor Ri
    then obviously the i-th bit of any sub-key will only affect the i-th bit in L and R
    for a 16-round DES, the first bit in 16 sub-keys can be tested with the first bit in L16 and R16
    there are 2^16 possibilities, with false positive 1/4
    every bit position in sub-keys can be tested independently, thus the total time required to recover all sub-keys is
        2^16 * log(4, 2^16) * 32 = 2^25
b.  define SWAP(L||R) = (R||L) for |L| = |R|
    for an oracle f, define F'(c) = SWAP(f(SWAP(c)))
    by problem 5.8, if every sub-key is the same, SWAP(DES(k, SWAP(DES(k, m)))) = m
    a distinguisher D can first query for some (m, c), and test if F'(c) = m, output 1 if the equation holds
    if f = DESk, D success with certainty
    if f <- Perm(n), F'(c) will be random and Pr[F'(c) = m] = 1 / 2^n
        |Pr[D(DESk, 1^n) = 1] - Pr[D(f, 1^n) = 1]|  = 1/2 + 1/2 * (1 - 1 / 2^n)
                                                    = 1 - 1 / 2^(n+1)

5.11
after acquired 2^12 candidates for both kl and kr, with a new input/output pair (x', y')
each kl can be tested independent to kr by comparing the XOR of round function outputs
the false positive rate is again 1 / 2^16, and this time with high probability only one kl will be valid
so 2^12 tests is necessary to decide kl or kr, 2 * 2^28 + 2 * 2^12 in total

5.12
a.  since F is a block cipher (pseudorandom permutation)
    when k is known, both F(k, m) and F^-1(k, m) can be efficiently computed
    with a known pair (x, y), an adversary can brute-force all k1 ∈ {0,1}^n
    F^-1(k2, F(k1, m)) and F(k1, m) is computable when k1 is known
    all possible k2 can be computed since both input and output of F^-1(k2, F(k1, m)) is known
    assume Fk maps input to random output, for a given pair (x, y)
    roughly 2^n pairs (k1, k2) will be valid among all 2^2n
    by testing another two input/output pairs, with more than 1 - 2^n probability only one pair will remain valid
b.  for all k2 ∈ {0,1}^n, calculate m = F^-1(k2, 0^n) and store k2 in linked lists in a hash table keyed by m
    then for input m, the linked list contains all k2 that F^-1(k2, 0^n) = m can be queried as a table entry
c.  calculate x = F^-1(k1, 0^n), query for x to get (x, y)
    calculate y' = F^-1(k1, y), then y' = F^-1(k2, F(k1, x)) = F^-1(k2, 0^n)
    then all valid k2 can be determined in constant time after the pre-process step
    if there are multiple k2, false positives can be eliminated with further queries to F' in constant time
d.  do the pre-process step in part b
    brute-force all k1 ∈ {0,1}^n, for every k1 query x = F^-1(k1, 0^n)
    total time 2^n + 2^n = O(2^n)

5.13
let i and j be two indexes starting from 0, l0 and l1 denote the two sorted lists
group the elements of l1 by their first entry z, as l1 is sorted this can be done in linear time
then l1' is a list of elements (z, {k2 | F^-1(k2, y) = z})
while i < len(l0):
    while j < len(l1) and l0[i].1 >= l1'[j].1:
        if l0[i].1 = l1'[j].1: 
            add all {(l0[i].2, k2) | k2 ∈ l1'[i].2} to S
        j++
    i++
runtime linear in 
    1. the combined length of the two lists
    2. the combined size of all l1'[j].2 added to S, i.e. all matches

5.14
a variation of meet-in-the-middle attack
query a input/output pair (x, y)
for all kl ∈ {0,1}^28:
    calculate z = the result of DES(kl||0^28, x) after 8 rounds
    store and sort all (z, kl) in a list 
for all kr ∈ {0,1}^28:
    calculate z' = the result of DES^-1(0^28||kr, y) after 8 rounds
    store and sort (z', kr) in another list
then if z = SWAP(z'), kl||kr is a valid private key for the pair (x, y)
as in the case of double encryption, this attack can be carried out in roughly 2 * 2^28 time

5.15
a.  0^112 and 1^112, both h(x) = 0^64
b.  fix some x1 and calculate y' = DES^-1(x1, y)
    brute-force to find x2 that DES(x2, 0^64) = y'
    total runtime 2^56 + 1
c.  given a value y ∈ {0,1}^64, sample x <- {0,1}^56, calculate z = DES^-1(x, y) and z' = DES(x, 0^64)
    let t and t' be two hashtable indexed by z ∈ {0,1}^64
    set t[z] = t'[z'] = x
    if t[z'] or t'[z] is defined, output t[z]||t'[z] (or t[z']||t'[z']); otherwise sample another x and repeat
    since DES is designed as a pseudorandom permutation
    both DES^-1(x1, y) and DES(x2, 0^64) will effectively be random value in {0,1}^64
    thereby the process is roughly equivalent to finding a collision after sampling z <- {0,1}^64 multiple times
    by A.4, this succeeds with probability greater than q(q-1) / (4 * 2^64) for q independent sample
    when q = 2^32, this strategy succeeds with probability 2^32(2^32 - 1) / 2^66 ≒ 1/4

Chapter 6
6.1
for a sum w (assuming no leading 0), take x = 10^(|w|-1), y = w xor x, then f(x, y) = w
by a binary search, inverse of f(x) = x^2 can be find in time O(log(2^|x^2|)) = O(|x|)

6.2
since f is one-way, for any polynomial time algorithm A there is a negligible function negl:
    Pr(x <- {0,1}^n)[A(f(x)) ∈ f^-1(f(x))] <= negl(n)
for every n
define f' on f that:
    f'(0^n) = 0^n 
    f'(x) = f(x) when x != 0^n for some n
then for all A':
    Pr(x <- {0,1}^n)[A'(f'(x)) ∈ f'^-1(x)]  <= Pr[f'(x) = 0^n] 
                                            + Pr[A'(f'(x)) ∈ f'^-1(x) | f'(x) != 0^n] * Pr[f'(x) != 0^n]
                                            <= Pr[f'(x) = 0^n] + Pr[A'(f(x)) ∈ f^-1(x) | f(x) != 0^n]
    Pr[f'(x) = 0^n] = Pr[f'(x) = 0^n | x = 0^n] * Pr[x = 0^n] + Pr[f'(x) = 0^n | x != 0^n] * Pr[x != 0^n]
                    = 1 / 2^n + Pr[f(x) = 0^n | x != 0^n] * (1 - 1 / 2^n)
if Pr[f(x) = 0^n | x != 0^n] = ε(n) is not negligible, an adversary that:
    on input f(x) = 0^n, sample x' <- {0,1}^n / 0^n and output x'
Pr[f(x) = 0^n] >= Pr[f(x) = 0^n | x != 0^n] * Pr[ x != 0^n] = ε(n) * (1 - 1 / 2^n)
Pr[f(x') = 0^n] = ε(n)
as x and x' are independent, this adversary succeeds with probability ε(n)^2 - negl(n)
if ε(n) is not negligible, this probability is not too, in contradiction to the assumption that f is one-way
thereby ε(n) is negligible and Pr[f'(x) = 0^n] <= 1 / 2^n + ε(n) is negligible
    Pr[A'(f(x)) ∈ f^-1(x)]  >= Pr[A'(f(x)) ∈ f^-1(x) | f(x) != 0^n] * Pr[f(x) != 0^n]
                            = Pr[A'(f(x)) ∈ f^-1(x) | f(x) != 0^n] * (1 - ε(n))
if Pr[A'(f(x)) ∈ f^-1(x) | f(x) != 0^n] = ε'(n) is non-negligible
Pr[A'(f(x)) ∈ f^-1(x)]  >= ε'(n) - negl(n) is also non-negligible, in contradiction to f being one-way
thus Pr(x <- {0,1}^n)[A'(f'(x)) ∈ f'^-1(x)]  <= ε(n) + ε'(n) is negligible for all n
therefore f' is one-way
for infinite x, f is trivially invertible 
but such x only exists uniquely in every probability space x <- {0,1}^n, not infinitely
the one-wayness only consider one probability space a time, so infinite invertible x doesn't matter

6.3
errata: length-preserving => length-regular https://www.cs.umd.edu/~jkatz/imc/errata.pdf
since f is a one-way function, it's efficiently computable
the time required to compute f(x) is bounded by some polynomial p(|x|)
define f'(x) = f(x)||10^(p(|x|) - |f(x)|), then for every input x, 
    |f'(x)| = p(|x|) + 1
so f' is length-regular
if some algorithm A' can invert f' with probability ε(n), define A as:
    on input 1^n and f(x), pass f'(x) = f(x)||10^(p(n) - |f(x)|) to A'
    output whatever A' outputs
obviously |x| = n and A simulates A', a correct output of A' is a correct output of A
    Pr[Invert(A, f, n) = 1] = Pr[Invert(A', f, n) = 1] = ε(n) <= negl(n)
thereby f' is one-way

6.4
assume an algorithm A inverts g(x1, x2) correctly with probability ε(2n) (let |x1| = |x2| = n)
define another algorithm A' that:
    on input f(x1), x1 <- {0,1}^n, sample x2 <- {0,1}^n
    pass 1^2n, (f(x1), x2) to A
    when A outputs (x1', x2'), output x1'
A' perfectly simulates A in experiment Invert(A, g, 2n)
when A succeeds, g(x1', x2') = (f(x1'), x2') = (f(x1), x2), f(x1') = f(x1), A also successfully inverts f
then
    negl(n) >= Pr[Invert(A', f, n) = 1] >= Pr[Invert(A, g, 2n) = 1] = ε(2n)
a negligible function is asymptotically smaller than any 1 / p(n) when p is a polynomial, then 
    ∀p∃N, ∀n > N, negl(n) < 1 / p(n)
define p'(n) = p(2n), then p' is also a polynomial, therefore
    ∀p∃N, ∀n > N, negl(n) < 1 / p'(n) = 1 / p(2n)
that means negl(n) is also asymptotically smaller than any 1 / p(2n) when p is a polynomial
if ε(2n) is non-negligible, there is some polynomial p that ε(2n) is not asymptotically smaller than 1 / p(2n)
but it's impossible as negl(n) >= ε(2n) and negl(n) is asymptotically smaller than any 1 / p(2n)
thus ε(2n) is negligible, g is one-way

6.5
assume f is a length-preserving one-way function
define f'(x1, x2) = f(x1)||0^n, |x1| = |x2| = n
|f'(x1, x2)| = |f(x1)| + |x2| = |x1||x2|
if there is an algorithm A that can invert f' with probability ε(2n)
drop the last n bits (that is x2) from the result then A inverts f(x1), that makes negl(n) >= ε(2n)
as proved in problem 6.4, ε(2n) is negligible, f' is one way and length-preserving
but now G(x) = (f'(x), hc(x)) always has 0s at known positions
an distinguisher D that:
    upon input w = w1 .. w2n+1, if wn+1 = .. = w2n = 0 outputs 1; otherwise 0
Pr[D(G(x)) = 1] = 1, Pr[D(r) = 1] = 1 / 2^n
G is not a pseudorandom generator

6.6
=>  let f' be a one-way function defined on {0,1}* -> {0,1}*
    define Π = (Gen, Samp, f) as a family of functions that:
        Gen(1^n) outputs I = 1^n
        Samp(1^n) samples x <- {0,1}^n
        f(I, x) = f'(x)
    then the experiment Invert(A, Π, n) is equivalent to Invert(A, f', n)
    the one-wayness of f' implies the one-wayness of Π
<=  thanks https://people.seas.harvard.edu/~salil/cs127/fall13/lec9.pdf
    as Π = (Gen, Samp, f) is efficiently computable, I <- Gen at most expands 1^n polynomial times
    there must be a polynomial p = c1 * n^c2 that:
        on input 1^n to Gen, both Gen and Samp won't consume more than p(n) coins
    define
        f'(r1, r2) = (I, f(Samp(I; r2))), where 
        |r1| = |r2| = n and I = Gen(1^n'; r1)
        n' is the biggest integer that p(n') <= n
        (as p(n) = c1 * n^c2, p(n) is monotonic and n' can be find with binary search, in time linear to |n|)
    then f' is deterministic, and if an algorithm A can invert f', define another A' attacking Invert(A', Π, n) that:
        on input I and y, run A(I, y) to get (r1, r2)
        output x = Samp(I; r2)
    if A successfully inverts f'(r1, r2) = (I, y), y = f(Samp(I; r2)) = f(x), A' successfully inverts f(I, y)
        negl(n) >= Pr[Invert(A', Π, n) = 1] >= Pr[Invert(A, f', n) = 1] = ε(2n)
    therefore f' must be one-way
    do not work for one-way permutations as f'(r1, r2) is not length-preserving

6.7
if an algorithm A inverts g(x) with non-negligible probability
an other algorithm A' on input f(x) can calculate f(f(x)) and invert it with A
A' succeeds if A succeeds, thus g(x) must be one-way
the same idea also applies to g(x) = (f(x), f(f(x)))

6.8
a.  assume f is a one-way function
    define a non-deterministic machine that, given input 1^n and y:
        guess a 0 or 1, append it to the previous guesses (ε if this is the first guess)
        check if the current guess x makes f(x) = y
        if that is the case, output x and halt
    |x| = n and f(x) can be calculated in time polynomial to |x|
    then this machine solves inversion problem in nondeterministic polynomial time
    if P = NP, a deterministic machine M can simulate this machine in polynomial time
    M inverts f in polynomial time, in contradiction to the assumption
    thus existance of one-way function implies P != NP
    a more formal proof: https://crypto.stackexchange.com/questions/39878
b.  define f on input x ∈ {0,1}^n as:
        calculate n' as biggest integer that n'^2 + n' <= |x|
        (n' can be calculated by binary search, runtime linear in |x|)
        if x = 0^(|x| - n'^2 - n')||x', calculate g(x') where g is subset-sum function defined in 6.1.2
        otherwise f(x) = 0
    for big enough n, n'^2 + n' <= |x| <= (n'+1)^2 + n', |x| = Θ(n'^2), |x'| = Θ(n'^2) = Θ(|x|)
    for any n, inverting f(x) on some input requires solving subset-sum problem on input size Θ(n)
    when P != NP, this cannot be done in polynomial time, Pr[f(A(f(x))) = f(x)] != 1
    but for infinitely many n = n'^2 + n' + 1, define an algorithm that:
        output x' = 10^(n-1)
    with 1/2 probability, x <- {0,1}^n starts with 1 and f(x) = 0 = f(x')
    therefore f is not one-way

6.9
thanks http://u.cs.biu.ac.il/~lindell/89-856/exercise1-solutions-89-856.pdf
(log function in this proof is actually f(x) = ceiling(log(x)), which has integer range)
for a one-way function f, define f' as:
    on input w, calculate n' be the biggest integer that n' + log(n') <= |w|
    parse w = x||i||pad, |x| = n', |i| = log(n'), pad is the reminding bits
    calculate and output f(x)||i||b||pad
    where |i| = log(n') is a binary number in {0 .. |x| - 1}, b is the (i+1)th bit of x
if there is A' probabilistically inverts f'(x, i), define A as:
    on input 1^n and f(x), sample i <- {0 .. n-1}
    run w0 = A'(1^(n + log(n)), f(x)||i||0) and w1 = A'(1^(n + log(n)), f(x)||i||1)
    define x0, x1 as the first n bits of w0 and w1
    if f(x0) = f(x), output x0; otherwise output x1
if A'(f(x)||i||b) for the correct b succeeds, A succeeds too, thereby f' must be one-way
let n' again be the biggest integer that n' + log(n') <= n
then n' + log(n') <= n <= n' + 1 + log(n'+1)
define algorithm Ai guessing ith bit of x <- {0,1}^n from f'(x) as:
    parse f'(x) = f(x)||i'||b||pad as before
    if i > n' + log(n'), output (i - n' + log(n'))th bit in pad
    if n'+1 <= i <= n' + log(n'), output (i - n')th bit in the repsentation of i'
    if i <= n':
        if i = i'+1, output b
        if i != i'+1, output 1 or 0 randomly
obviously, as both i' and pad is encoded in the output, when i > n' Ai always succeeds
when i <= n' and i = i'+1, ith bit of x is encoded in the output and Ai succeeds
when i <= n' and i != i'+1, Ai succeeds with probability 1/2
as i' is randomly chosen from {0 .. n'-1}, Pr[i = i'+1] = 1/n'
therefore
    Pr[f'(A(f'(x))) = xi]   >= 1/n' + (1/2) * (1 - 1/n')
                            = 1/2 + 1/2n'
                            >= 1/2 + 1/2n

6.10
x != y => f(x) != f(y)
f has a hard-core predicate that for all polynomial time algorithm A:
    Pr(x <- {0,1}^n)[A(f(x)) = hc(x)] <= 1/2 + negl(n)
if an algorithm A' can invert f(x), it must be able to calculate x since f is one-to-one
another algorithm then can run A' and calculate hc(x), which succeeds when A' succeeds
if A' succeeds with non-negligible probability, it's in contradiction to hc being a hard-core predicate of f
thus f must be one-way

6.11
by randomly sampling r <- {0,1}^n, Pr[A(y xor r) xor A(y, r xor ei) = gl(x, ei)] >= 1/2 + ε(n)
let gl(x, ei) = b, by taking m independent sample r and take the majority b':
    Pr[b' != b] <= 1 / (4ε(n)^2m)
                = p(n)^2 / 4m   // ε(n) = 1 / p(n)
take m = p(n)^2 / 2:
    Pr[b' != b] <= 1/2
    Pr[b' = b] >= 1/2
therefore is A' repeats step 1a at least p(n)^2 / 2 times, A' succeeds with probability greater than 1/2
by assumptions, p(n) is polynomial

6.12
analogous to Claim 6.16, the constant plays no roles in the proof
define s(x) = Pr(r <- {0,1}^n)[A(f(x), r) = gl(x, r)]
let Sn = {x | s(x) >= 1/2 + ε(n)/2}, then 
    Pr(x, r)[A(f(x), r) = gl(x, r)] = Pr(x, r)[A(f(x), r) = gl(x, r) | x ∈ Sn] * Pr[x ∈ Sn]
                                    + Pr(x, r)[A(f(x), r) = gl(x, r) | x ∉ Sn] * Pr[x ∉ Sn]
                                    <= Pr[x ∈ Sn] + Pr(x, r)[A(f(x)), r) = gl(x, r) | x ∉ Sn]
    Pr[x ∈ Sn]  >= Pr(x, r)[A(f(x), r) = gl(x, r)] - Pr(x, r)[A(f(x), r) = gl(x, r) | x ∉ Sn]
when x ∉ Sn, Pr(r)[A(f(x), r) = gl(x, r)] < 1/2 + ε(n)/2 by definition of Sn
then
    Pr(x, r)[A(f(x), r) = gl(x, r) | x ∉ Sn]    = (1 / |~Sn|) * ∑(x ∈ ~Sn)Pr(r)[A(f(x), r) = gl(x, r)]
                                                < (1 / |~Sn|) * |~Sn| * (1/2 + ε(n))
                                                = 1/2 + ε(n)/2
    Pr(x ∈ Sn)  >= 1/2 + ε(n) - (1/2 + ε(n)/2)
                = ε(n)/2
as x <- {0,1}^n, |Sn| >= 2^n * ε(n)/2

6.13
let l be the expansion factor of G
define Gi(y1|| .. ||yi||xi+1|| .. ||xn) = y1|| .. ||yi||G(xi+1)|| .. ||G(xn)
where yi <- {0,1}^l(n), xi <- {0,1}^n
the output of all Gi has the same length nl(n)
let si be the input to Gi, si <- {0,1}^(i * l(n) + (n-i) * n)
G0 = G' and Gn takes input r <- {0,1}^nl(n) then output it
if there is some D can distinguish G' and r,
    |Pr[D(G'(s0)) = 1] - Pr[D(r) = 1]| = ε(n)
    = |∑(i ∈ {0 .. n-1})Pr[D(Gi(si)) = 1] - ∑(i ∈ {1 .. n})Pr[D(Gi(si)) = 1]|
    <= ∑(i ∈ {0 .. n-1})|Pr[D(Gi+1(si+1)) = 1] - Pr[D(Gi(si)) = 1]|
so there must be some i' that
    |Pr[D(Gi'+1(si'+1)) = 1] - Pr[D(Gi'(si')) = 1]| >= ε(n)/n
define another D' that takes input |w| ∈ {0,1}^l(n) as:
    sample i <- {0 .. n-1}
    sample y1 .. yi <- {0,1}^l(n)
    sample xi+2 .. xn <- {0,1}^n
    compute s = y1|| .. ||yi||w||G(xi+2)|| .. ||G(xn)
    run D(s), output whatever it outputs
then if i = i':
    if w = G(x), x <- {0,1}^n, D'(w) is equivalent to D(Gi'(si'))
    if w = r, r <- {0,1}^l(n), D'(w) is equivalent to D(Gi'+1(si'+1))
thereby
    |Pr[D'(G(s)) = 1] - Pr[D'(r) = 1]|  >= |Pr[D(Gi'(si')) = 1] - Pr[D(Gi'+1(si'+1)) = 1] * Pr[i = i']
                                        >= (ε(n) / (n-1)) * 1 / (n-1)
                                        >= ε(n) / n^2
since G is a pseudorandom generator, ε(n) / n^2 <= negl(n) and ε(n) must be negligible
G' must be a pseudorandom generator

6.14
G is a pseudorandom generator with expansion factor l(n) = 2n, define G(s) = (G0(s)||G1(s))
then G0, G1: {0,1}^n -> {0,1}^n are two length-preserving functions
G': {0,1}^n -> {0,1}^4n is defined as:
    G'(s) = G0(G0(s))||G0(G1(s))||G1(G0(s))||G1(G1(s))
define a function H: {0,1}^2n -> {0,1}^4n:
    H(s0||s1) = G0(s0)||G0(s1)||G1(s0)||G1(s1)
if some D can distinguish G'(s') and H(s):
    |Pr[D(G'(s')) = 1] - Pr[D(H(s)) = 1]| = ε(n)
    s' <- {0,1}^n, s <- {0,1}^2n
define another D' that:
    take input w ∈ {0,1}^2n, parse w = s0||s1, |s0| = |s1| = n
    calculate w' = G0(s0)||G0(s1)||G1(s0)||G1(s1)
    run D(w'), output whatever it outputs
when w = G(s), s <- {0,1}^n, D' simulates D(G'(s))
when w = r <- {0,1}^2n, D' simulates D(H(w))
    |Pr[D'(G(s)) = 1] - Pr[D'(r) = 1]|  = |Pr[D(G'(s)) = 1] - Pr[D(H(r)) = 1]|
                                        = ε(n) <= negl(n)
thereby G'(s) and H(r) are indistinguishable
by rearranging the result, H'(s0||s1) = G0(s0)||G1(s0)||G0(s1)||G1(s1) = G(s0)||G(s1)
by theorem 6.37, H' is a pseudorandom generator
if some D can distinguish H(s), s <- {0,1}^2n and r <- {0,1}^4n
    |Pr[D(H(s)) = 1] - Pr[D(r) = 1]| = ε(n)
H'(s) and r can be easily distinguished with the same probability, in contradicton to H' being pseudorandom
therefore H(s) and r are indistinguishable
by transitivity of indistinguishability, G'(s) and r are indistinguishable, G' is a pseudorandom generator

6.15
such a distinguisher D can:
    query x1 = f(1)
    query x11 = f(11)
    if x11 = G1(x1), output 1; otherwise output 0
if f = Fk, f(1) = G1(k), f(11) = G1(G1(k)), D always outputs 1
if f <- Func(n), f(1) and f(11) are independent strings in {0,1}^n, Pr[D(f, 1^n) = 1] = Pr[x1 = x11] = 1/2^n
therefore
    |Pr[D(Fk, 1^n) = 1] - Pr[D(f, 1^n) = 1]| = 1 - 1/2^n

6.16
define a keyed function F'(k1|| .. ||kn, x) = F(k1, x)|| .. ||F(kn, x)
k = k1|| .. ||kn, |ki| ∈ {0,1}^n, x ∈ {0,1}^p(n)
let fi be a uniformly chosen function {0,1}^p(n) -> {0,1}^i
define oracles Fi with key k = ki+1|| .. ||kn as:
    calculate r = fi(x)
    output r||F(ki+1, x)|| .. ||F(kn, x)
then F0 = F' and Fn = f
assume some D can distinguish F' and f <- {0,1}^p(n) -> {0,1}^n, then:
    |Pr[D(F', 1^n) = 1] - Pr[D(f, 1^n) = 1]| = ε(n)
    = |Σ(i∈{0 .. n-1})Pr[D(Fi, 1^n) = 1] - Σ(i∈{1 .. n})Pr[D(Fi, 1^n) = 1]|
    <= Σ(i∈{0 .. n-1})|Pr[D(Fi, 1^n) = 1] - Pr[D(Fi+1, 1^n) = 1]|
then there must be some i' that:
    |Pr[D(Fi', 1^n) = 1] - Pr[D(Fi'+1, 1^n) = 1]| >= ε(n)/n
both probability defined over all randomly chosen fi: {0,1}^p(n) -> {0,1}^n and k = ki+1|| .. ||kn
define another distinguisher D' with access to an oracle f: {0,1}^p(n) -> {0,1} that:
    sample i <- {0 .. n-1}
    sample ki+2, .. , kn <- {0,1}^n
    when D queries x
        if x is never queried: sample r <- {0,1}^i, calculate w = r||f(x)||F(ki+2, x)|| .. ||F(kn, x), record (x, w)
        if x is queried before: output the previously recorded w
    output whatever D outputs
by sample and record random r, D' effectively constructs a random f: {0,1}^p(n) -> {0,1}^i
if f is a randomly chosen function {0,1}^p(n) -> {0,1}:
    r||f(x) is random (but deterministic to input) string in {0,1}^(i+1)
    f'(x) = r||f(x) is a uniformly chosen function from {0,1}^p(n) -> {0,1}^(i+1)
    D' simulates D(Fi+1, 1^n)
if f = Fk for k <- {0,1}^n:
    k concatenated with randomly sampled ki+2 .. kn is a random key to Fi
    D' simulates D(Fi, 1^n)
thereby
    |Pr[D'(Fk, 1^n) = 1] - Pr[D'(f, 1^n) = 1]|  >= |Pr[D(Fi', 1^n) = 1] - Pr[D(Fi'+1, 1^n) = 1] * Pr[i = i']
                                                >= ε(n)/n * 1/n = ε(n)/n^2 <= negl(n)
therefore ε(n) must be negligible, F' is a pseudorandom function                                                

6.17
refer 3.13

6.18
for a 2-round Feistel network P with pseudorandom function F and two independent key k1, k2
    L2 = R1 = L0 xor F(k1, R0)
    R2 = L1 xor F(k2, R1) = R0 xor F(k2, L0 xor F(k1, R0))
define a distinguisher D with access to oracle P:
    sample two random x1, x2, x3 <- {0,1}n, define x = (x1, x3), x' = (x2, x3)
    query P(x) = (L2, R2), P(x') = (L2', R2')
    if L2 xor x1 = L2' xor x2, output 1; otherwise output 0
by definition, L2 = x1 xor F(k, x3), L2' = x2 xor F(k, x3), L2 xor x1 = L2' xor x2
which only happens with negligible probability if P is truly random
    |Pr[D(P, 1^n) = 1] - Pr[D(p, 1^n) = 1]| = 1 - negl(n)

6.19
thanks https://crypto.stackexchange.com/questions/32974
the original proof on the page mistakenly used the inversion function of Feistel network in DES
which swaps L and R after the last round, makes P and P^-1 be the same function with reversed order of keys
for a 3-round Feistel network P with pseudorandom function F and three independent key k1, k2, k3
    L1 = R0
    R1 = L0 xor F(k1, R0)
    L2 = R1
    R2 = L1 xor F(k2, R1)
    L3 = R2 
    R3 = L2 xor F(k3, R2)
    L3 = R0 xor F(k2, L0 xor F(k1, R0))
    R3 = L0 xor F(k1, R0) xor F(k3, R0 xor F(k2, L0 xor F(k1, R0)))
P^-1 is defined as:
    R2 = L3
    L2 = R3 xor F(k3, R2)
    R1 = L2 
    L1 = R2 xor F(k2, R1)
    R0 = L1
    L0 = R1 xor F(k1, R0)
    L0 = R3 xor F(k3, L3) xor F(k1, L3 xor F(k2, R3 xor F(k3, L3)))
    R0 = L3 xor F(k2, R3 xor F(k3, L3))
denote F(ki, x) as Fi(x)
define a distinguisher D that:
    query P^-1(0^2n) = (a, b)
    query P(0^n||b) = (c, d)
    query P^-1(c||(a xor d)) = (e, f)
    if f = c xor b, output 1; otherwise output 0
by definitions of P and P^-1:
    b = F2(F3(0^n))
    a = F3(0^n) xor F1(F2(F3(0^n))) = F3(0^n) xor F1(b)
    c = b xor F2(F1(b))
    d = F1(b) xor F3(b xor F2(F1(b))) = F1(b) xor F3(c)
    a xor d = F3(0^n) xor F3(c)
    f   = c xor F2(a xor d xor F3(c))
        = c xor F2(F3(0^n)) 
        = c xor b
if P is a 3-round Feistel network, D outputs 1 with certainty
if P = p <- Perm(2n), f and c xor b are independent strings in {0,1}^n, Pr[D(p) = 1] = 1/2^n
    |Pr[D(P, 1^n) = 1] - Pr[D(p, 1^n) = 1]| = 1 - 1/2^n
therefore P is not strongly pseudorandom 

6.20
errata: pseudorandom function => pseudorandom generator https://www.cs.umd.edu/~jkatz/imc/errata.pdf
for all polynomial time distinguisher D:
    |Pr[D(G(s)) = 1] - Pr[D(r) = 1]| <= negl(n)
    s <- {0,1}^n, r <- {0,1}^(n+1)
if an algorithm can invert G:
    |Pr[A(G(s)) ∈ G^-1(G(s))]| = ε(n)
define a new D' as:
    on input w ∈ {0,1}^(n+1), run A(w) = s
    if G(s) = w, output 1; otherwise output 0
when w = G(s'), s' <- {0,1}^n, only when A succeeds, s ∈ G^-1(s'), G(s) = G(s'), D' succeeds
when w <- {0,1}^(n+1)
    if w is in the range of G, w = G(s') for some s', again D' succeeds iff A succeeds
    if w is not in the range of G, no matter A succeeds or not, G(s) != w, D' outputs 0
as G takes input s ∈ {0,1}^n, the range of G has size at most 2^n,
    Pr(w <- {0,1}^(n+1))[w in the range of G] <= 2^n / |{0,1}^(n+1)| = 1/2
thereby
    Pr[D'(G(s)) = 1] = ε(n)
    Pr[D'(w) = 1] = ε(n) * Pr[w in range of G] <= ε(n)/2
    negl(n) >= |Pr[D'(G(s)) = 1] - Pr[D'(w) = 1]|  >= |ε(n) - ε(n)/2| = ε(n)/2
ε(n) is negligible and G is one-way

6.21
a.  assume for some polynomial time distinguisher D:
        |Pr[D(1^n, A(Xn)) = 1] - Pr[D(1^n, A(Yn)) = 1]| = ε(n)
    define another distinguisher D' as:
        on input 1^n and w, run D(1^n, A(w)), output whatever it outputs
    both A and D are polynomial time algorithms, thereby D' is polynomial time too
    when w <- Xn, D' simulates D(A(Xn))
    when w <- Yn, D' simulates D(A(Yn))
        negl(n) >= |Pr[D'(1^n, Xn) = 1] - Pr[D'(1^n, Yn) = 1]| = |Pr[D(1^n, A(Xn)) = 1] - Pr[D(1^n, A(Yn)) = 1] = ε(n)
    {Xn} and {Yn} are computationally indistinguishable
b.  let G be a pseudorandom generator with expansion factor 2n
    let Xn be the distribution of G(s), s <- {0,1}^n
    let Yn be the distribution r <- {0,1}^2n
    then {Xn} and {Yn} are computationally indistinguishable
    but is A has unbounded computational power, on input w ∈ {0,1}^2n, A can try every possible G(s)
    if any G(s) = w, A outputs 1; otherwise output 0
    then A always outputs 1 for every Xn
    for w <- Yn, A outputs 1 when w is in the range of G, which happens with probability at most 2^n / 2^2n = 1/2^n
    thereby
        Pr[A(Xn) = 1] = 1
        Pr[A(Yn) = 1] <= 1/2^n
    an distinguisher D on input A(w) ∈ {0,1} can output A(w) directly, which gives:
        |Pr[D(A(Xn)) = 1] - Pr[D(A(Yn)) = 1]|   = |Pr[A(Xn) = 1] - Pr[A(Yn) = 1]| >= 1 - 1/2^n
    D doesn't have to compute A(w) itself and runs in constant time
    therefore {A(Xn)} and {A(Yn)]} are not computationally indistinguishable

Chapter 7
7.1
assume there are two identities e1 and e2 for an abelian group G
then for every element g in G:
    e1 + g = g, e2 + g = g
    e1 + e2 = e1, e1 + e2 = e2
therefore e1 = e2
assume there are two inverse g'1, g'2 for an element g
    g'1 + g = 0
    g'2 + g = 0
    g'2 + (g + g'1) = 0 + g'1
    g'2 = g'1
so any inverse of g must be the same element, g has a unique inverse

7.2
let G = R / 0 be the set of rational numbers without 0
operation o be multiplication
1 be the identity
then for every element g ∈ G, g is a rational number and can be expressed as a/b for some integer a and b
for all element g, h ∈ R, g * h ∈ R 
for all g = a/b, g' = b/a ∈ R and g * g' = 1
associativity follows the associativity of multiplication
thereby G is a group
define H = {1} ∪ {2^i | i ∈ Z+} ⊆ G (1 = 2^0)
H contains the identity of G, and for any two elements g, h in H:
    g = 2^i, h = 2^j
    g * h = 2^(i+j) ∈ H
but for any 2^i, i >= 1, the inverse of 2^i is not in H and H is not a subgroup of G

7.3
let m = |G|, as g^0 = 1, the identity of G is in <g>
for any two elements g1, g2 ∈ <g>:
    g1 = g^x1, g2 = g^x2 for some x1, x2 ∈ N
    g1 * g2 = g^(x1 + x2) ∈ <g>
g^0 = 1 ∈ G and assume g^i is in G:
    g^(i+1) = g^i * g ∈ G (by closure property of G)
by induction, g^i ∈ G for i ∈ N, <g> ⊆ G
by Proposition 7.36, <g> is a subgroup of G
if G is infinite, H is not necessarily a subgroup of G (refer set H defined in problem 7.2)

7.4
a.  define S = {p^i * u | 1 <= i < e, gcd(u, p) = 1, 1 <= u < p^(e - i)}
    then for all d ∈ S, gcd(d, p^e) = p^i != 1, p^i * u < p^e
    if d = gcd(n, p^e) != 1 for some n < p^e, d|n and d|p^e, d must be a power of p, d = p^i, 1 <= i < e
    fix i and n = p^i * u for some integer u, p^i * u < p^e => u < p^(e - i)
    if gcd(u, p) != 1, u = p^j * k for some k, d = p^(i+j)k, gcd(n, p^e) = p^(i+j)
    thereby gcd(u, p) = 1 and d ∈ S
    so S = {d | gcd(d, p^e) != 1}
    as every integer has a unique factorization and gcd(u, p) = 1
    d = p^i * u = p^i * Π(j)pj^ej, ∀j(pj != p)
    if d = p^i * u, d' = p^i' * u', i != i' => d != d'
    obviously, if d = p^i * u, d' = p^i * u', u != u' => d != d'
    so any two elements in S defined as p^i * u for some different (i, u) are distinct
    there is one-to-one correspondence between pair (i, u) and s ∈ S
    fix i, gcd(u, p) = 1 and 1 <= u < p^(e - i), there are 
        p^(e - i) - (p^(e - i)/p - 1) = p^(e - i) - p^(e - i + 1)
    such u, and for all possible i:
        |S| = ∑i∈{1 .. e-1}(p^(e - i) - p^(e - i + 1))
            = ∑i∈{1 .. e-1}p^(e - i) - ∑i∈{2 .. e}p^(e - i)
            = p^(e - 1) - 1
    φ(p^e) = (p^e - 1) - |S| = p^e - p^(e - 1) = p^(e - 1) * (p - 1)
b.  define
        PQ = {n | gcd(n, pq) = 1, 1 <= n < pq}
        P = {n | gcd(n, p) = 1, 1 <= n < p}
        Q = {n | gcd(n, q) = 1, 1 <= n < q}
        |PQ| = φ(pq), |P| = φ(p), |Q| = φ(q)
    define f(x) = (x mod p, x mod q)
    assume x = kp + r for 0 <= r < p, if gcd(r, p) = d > 1:
        d|r, d|p => d|(kp + r), d|x, gcd(x, p) > 1
    thereby gcd(r, p) = gcd(x mod p, p) = 1, x mod p ∈ P
    symmetrically, x mod q ∈ Q, f: PQ -> PxQ
    if f(x) = (x1, x2) = f(x'),
        x = x' = x1 mod p
        x = x' = x2 mod q
        p|(x - x'), q|(x - x')
    as gcd(p, q) = 1:
        pq|(x - x')
        x - x' = npq for n ∈ N
    as both x and x' in PQ, x - x' < pq and n = 0, x = x', f is one-to-one
    as gcd(p, q) = 1, there exist some integers X, Y that:
        Xp + Yq = 1
    for any (x1, x2) ∈ PxQ, define
        x = x1Yq + x2Xp
        x mod p = x1Yq + x2Xp mod p 
                = x1(1 - Xp) + x2Xp mod p
                = x1
        x mod q = x2 (symmetric)
    so gcd(x, p) = gcd(x mod p, p) = 1 = gcd(x, q) and there exists constants A,B,C,D:
        Ax + Bp = 1
        Cx + Dq = 1
        (Ax + Bp)(Cx + Dq)  = ACx^2 + ADxq + BCxp + BDpq 
                            = (ACx + ADq + BCp)x + BDpq = 1
    which means gcd(x, pq) = 1
    as x mod pq mod p = x mod p, x mod pq mod q = x mod q,
    there is a number x mod pq ∈ PQ that f(x) = (x1, x2), f is onto
    thereby f is a bijection, |PQ| = |P| * |Q|, φ(pq) = φ(p)φ(q)
c.  every integer has unique factorization
    for any n, n = Πpi^ei and every pi^ei is coprime
    then φ(n) = Πφ(pi^ei) = Π(pi^(ei - 1) * (pi - 1))

7.5
φ(100) = φ(2^2 * 5^2) = 40
3^1000 mod 100  = 3^(1000 mod φ(1000)) mod 100
                = 3^(1000 mod 40) mod 100
                = 3^0 mod 100
                = 1
so the final two digits are 01

7.6
φ(35) = φ(5*7) = 24
101^4800000023 mod 35   = 101^(4800000023 mod φ(35)) mod 35
                        = 101^(4800000023 mod 24) mod 35
                        = 101^23 mod 35
                        = (101 mod 35)^23 mod 35
                        = 31^23 mod 35
                        = 31^(23 - φ(35)) mod 35
                        = 31^-1 mod 35
                        = 26

7.7
if G and H are groups with binary operations og and oh identities 1g and 1h
define a binary operation O that
    O((g, h), (g', h')) = (g og g', h oh h')
then for any two elements (g, h), (g', h') ∈ GxH:
    O((g, h), (g', h')) = (g og g', h oh h') ∈ GxH by closure of G and H
define (1g, 1h) as the identity of GxH, then
    O((g, h), (1g, 1h)) = (g og 1g, h oh 1h) = (g, h)
for any elements (g, h) in GxH:
    (g^-1, h^-1) ∈ GxH and
    O((g, h), (g^-1, h^-1)) = (g og g^-1, h oh h^-1) = (1g, 1h)
for any three elements in GxH:
    associativity, routine
therefore GxH defined as above is a group

7.8
X = kN + r, 0 <= r < N, X mod N = r
if p|N, N = dp, X mod p = kdp + r mod p = r mod p = X mod N mod p
let N = 6, p = 3
4 mod p mod N = 1 != 4 = 4 mod N

7.9
let f(x) = f(x mod p, x mod q)
refer to problem 7.4: 
    f: Zpq* -> Zp* x Zq*
    for f(x) = (x1, x2) = f(x'), x = x'
so f is one-to-one
also |Zpq*| = φ(pq) = φ(p)φ(q) = |Zp*| * |Zq*| = |Zp* x Zq*|
f is a bijection
refer to problem 7.7, Zp* x Zq* is a group with
    o((x, y), (x', y')) = (xx' mod p, yy' mod q)
    (1, 1) be the identity
let *N denote the multiplication modulo N, x *N x' = [x * x' mod N]
    f(x *N x') = ([x * x' mod N] mod p, [x * x' mod N] mod q)
by problem 7.8,
    [[x * x' mod N] mod p] = x * x' mod p
    [[x * x' mod N] mod q] = x * x' mod q
    f(x *N x')  = (xx' mod p, xx' mod q)
                = (x mod p, x mod q) o (x' mod p, x' mod q)
                = f(x) o f(x')
thereby f is an isomorphism Zpq* -> Zp* x Zq*
Zpq* is isomorphic to Zp* x Zq*

7.10
when p, q are distinct prime numbers, φ(N) = φ(p)φ(q)
by Chinese remainder theorem, Zn is isomorphic to Zp x Zq, f(x) = (x mod p, x mod q) satistifes:
    f(xx') = f(x)f(x')
    f(x^ed) = f(x)^ed = (x^ed mod p, x^ed mod q)
x^ed = x^(1 + kφ(N)) = x^(1 + kφ(p)φ(q))
if x != 0 mod p and x != 0 mod q, x mod p ∈ Zp* and q ∈ Zq*,
    x^(1 + kφ(p)φ(q)) = x mod p
    x^(1 + kφ(p)φ(q)) = x mod q
    f(x^ed) = (x mod p, x mod q) = f(x), x^ed = x mod N
if x = 0 mod p, x = kp = k'q + r, 0 < r < q, f(x) = (0, r), r ∈ Zq*
    f(x^ed) = (0^ed, r^ed mod q) = (0, r^(1 + kφ(p)φ(q)) mod q) = (0, r mod q) = (0, k'q + r mod q) = f(x)
    x^ed = x mod N
if both x = 0 mod p and x = 0 mod q
    f(x) = (0, 0), f(x^ed) = (0, 0)^ed = (0, 0) = f(x)
    x = x^ed mod N
therefore x^ed = x mod N when ed = 1 mod φ(N), N = pq, p and q are distinct primes

7.11
a.  (considering only positive integers, nowhere in the text specified the binary representation of negative integers)
    if a <= b, then ||a|| <= ||b|| (intuitively, a formal proof relies on the concrete representation so emitted)
    if n >= 2, N = n^e >= 2^e, ||N|| >= ||2^e|| = e + 1, ||N|| + 1 >= e
b.  assuming addition of two n bit integers can be done in time O(n)
    multiplication of two n bit integers, most naively, can be done in time O(n^2)
    when M^e < N, calculating M^e can be done with O(e) multiplication and square, in total O(e||N||^2)
    by part a, e = O(||N||) and O(e||N||^2) = O(||N||^3)
    by binary search a number 1 < M <= N, calculate M^e (halt when at some point M^e' > N) and compare to N
    an algorithm can calculate M^e = N from N in time O(||N||^3log(N)) = O(||N||^4)
c.  since ||2^e|| = e + 1, for all e > ||N||, ||2^e|| > ||N|| + 1
    so N cannot be a perfect power of n^e where e > ||N||
    by run the algorithm in part b for 2 <= e <= ||N||
    another algorithm can test whether N is a perfect power in time O(||N||^5)

7.12
assume N is odd
N - 1 has least significant bit 0, let N - 1 = x1x2...xn in big endian
by search from the least significant bit to the most, find the biggest i that xi = 1, then 
    N - 1 = x1 .. xi||0^(n-i)
denote r = n-i, let r be the number represented by the string x1 .. xi, then
    N - 1 = u * 2^(n-i) = 2^r * u
calculate b = [a^u mod N], if b != ±1 output "yes" and halt
for j = 1 to r - 1:
    calculate b^2^j = [(b^2^(j-1))^2 mod N]
    if b^2^j != -1, output "yes" and halt
output "no" and halt
searching u and r can be done in time O(||N||), r = O(||N||)
calculating a^u can be done in time O(||N||^2 * log(u)) = O(||N||^3)
each step in the loop is multiplication of two ||N|| bit number, O(||N||^2)
total running time O(||N||^3) is polynomial

7.13
N = pq 
φ(N) = (p-1)(q-1) = pq - p - q + 1
then φ(N) - N = 1 - p - q, p = 1 - q - φ(N) + N
N = (1 - q - φ(N) + N)q = -q^2 + (N - φ(N) + 1)q
-q^2 + (N - φ(N) + 1)q - N = 0, coefficient all known, q can be solved in polynomial time by formula
with q, p can be solved by binary search or long division

7.14
thanks https://stackoverflow.com/questions/2921406
// incomplete and informal
assume d is positive, otherwise (3d^2) is a positive number and
    3(3d^2) = (3d)^2 = 1^2 = 1 mod φ(N)
and ||3d^2|| = O(||d||), the number 3d^2 is only longer by a constant times, let 3d^2 be d in the following proof
3d = 1 mod φ(N)
3d = 1 + kφ(N) for some positive integer k
calculate k' = 3d/N, the biggest integer that k'N <= 3d, k' <= 3d/N
    k'N <= 3d = 1 + kφ(N) < (k'+1)N
as φ(N) = (p-1)(q-1) < N, k > k'
also (k'+1)N >= kφ(N), k <= (k'+1) * N/φ(N)
N / φ(N) = pq / pq - (p+q) + 1 = 1 + (p+q-1 / pq-(p+q)+1)
φ(N) = Θ(N) and when p and q are close, (p+q-1 / φ(N)) = O(N^(1/2)) / Θ(N) = O(1 / N^(1/2))
k <= (k'+1) * N/φ(N) <= k'+ 1 + (3d/N + 1) * O(1 / N^(1/2))
if d is O(N^(3/2)), k <= k' + 1 + c for some constant c
by testing k starting from k'+1 with the algorithm in problem 7.13, p and q can be calculated efficiently
errata: d ∈ {1 .. φ(N)}: https://www.cs.umd.edu/~jkatz/imc/errata.pdf
3d = 1 + kφ(N), k can only be 1 or 2

7.15
assume some algorithm A can compute discrete logarithm problem that:
    Pr[DLog(A, G, n) = 1] = ε(n)
define another A' solving CDH that:
    run A as a subroutine
    on input G, q, g, h1, h2, run x1 = A(G, q, g, h1), x2 = A(G, q, g, h2)
    output g^(x1x2)
if both x1 and x2 are correct, g^(x1x2) is correct
as h1 = g^x1 and h2 = g^x2 is defined by randomly chosen x1 and x2, f(x) = g^x is a isomorphism, g is a generator
h1 and h2 are randomly chosen from G, their successes are independent
    Pr[CDH(A'(G, q, g, h1, h2)) = 1] = ε(n)^2
if CDH is hard, ε(n)^2 is negligible, ε(n) must be negligible and DLog must be difficult

7.16
assume some algorithm A can solve CDH that:
    Pr[CDH(A, G, n) = 1] = ε(n)
define another A' solving DDH that:
    run A as a subrountine
    on input G, q, g, h1, h2, h3, run h3' = A(G, q, g, h1, h2)
    if h3 = h3', output 1; otherwise output 0
when h3 = g^xy, if A succeeds h3' = h3 and A' outputs 1
    Pr[A'(G, q, g, g^x, g^y, g^xy) = 1] >= ε(n)
when h3 is chosen randomly, A outputs 1 when h3 equals the output of A
A doesn't know h3 and the two events are independent, this happens with probability 1/|G|
if DDH is hard, first |G| must be exponential to the security parameter
or an algorithm that outputs a random elements in G will succeed with probability 1/|G| non-negligible
thereby
    Pr[A'(G, q, g, g^x, g^y, g^z) = 1] = negl(n)
    |Pr[A'(G, q, g, g^x, g^y, g^xy) = 1] - Pr[A'(G, q, g, g^x, g^y, g^z) = 1]| = ε(n) - negl(n) <= negl'(n)
therefore ε(n) must be negligible and CDH must be difficult

7.17
it's geometry

7.18
by problem 7.10, for any ed = 1 mod φ(N), g ∈ ZN, g^ed = g mod N, φ(p) = p-1
when x ∈ Zp-1* = Zφ(p)*, gcd(x, φ(p)) = 1 and x^-1 mod φ(p) exist and can be computed in polynomial time (Theorem B.2)
with x' = x^-1 mod φ(p), [y^x' mod N] = [g^xx' mod N] = g mod N can be computed in polynomial time

7.19
let Gen be the algorithm in Construction 7.62
p is chosen as a random strong prime number of (n+1) bits
2 is not a strong prime number, thereby p must be odd
p-1 is a (n+1)-bit even number, q = (p-1)/2 drops the least significant zero in p-1 and is a n-bit prime number
(p, q, g) <- Gen(1^n), ||p|| = n+1, ||q|| = n
input to the hash function Zq x Zq is a tuple of two numbers smaller than q, 2||q|| = 2n bits
output of the hash function is a number in Zp, has at most ||p|| = n+1 bits
the hash function therefore maps 2n bits to n+1 bits, when n > 1 it achieves compression

7.20
(p, q, g) <- Gen'(1^n), p is a prime number, ||p|| = n, q = p-1, g is a generator of Zp*
as p being a prime number, Zp* = {1 .. p-1} and every number in Zp* - {1} is a generator
if discrete logarithm is hard relative to Gen, given p, q, g, h = g^x a polynomial algorithm cannot calculate x
fix g ∈ Zp* - {1} and define p: Zp* -> Zp* as:
    f(x) = [g^(x - 1) mod p]
g is a generator of order q, for x, y ∈ Zp* = {1 .. q}, x-1, y-1 ∈ Zq = {0 .. q-1}
if g^x = g^y, x mod q = y mod q, x = y, thereby f is a permutation on Zp*
define a family of permutations Π = (Gen, Samp, H) that:
    Gen = Gen'
    Samp: on input (p, q, g), sample x <- Zp*
    H((p, q, g), x) = g^(x-1)
if an algorithm A can invert Π,
    Pr[Invert(A, Π, n) = 1] = ε(n)
define another A' attacking discrete logarithm that:
    on input p, q, g, h, run x = A((p, q, g), h)
    output x-1
if A successfully calculates x that g^(x-1) = h = g^x', x-1 = x' mod q, x-1, x' ∈ Zq, x-1 = x', A' succeeds too
    Pr[DLog(A', A, Gen, n) = 1] >= Pr[Invert(A, Π, n) = 1] = ε(n) <= negl(n)
Π must be a family of one-way permutations

7.21
let (x, x') be a collision of Hs, x != x'
define σ be the suffix function, σ(x, n) is the last n bits of x
as (x, x') being a collision, Hs(x) = Hs(x')
take i be the last position where xi != x'i, then σ(x, 3n-i) = σ(x', 3n-i), define t = Hs(σ(x, 3n-i)) = Hs(σ(x', 3n-i))
xi != x'i, if Hs(σ(x, 3n-i+1)) = Hs(σ(x', 3n-i+1)), yt^e = t^e mod N, y = 1
when y = 1, RSA is easy with x = 1, thus exclude this case
for y != 1, Hs(σ(x, 3n-i+1)) != Hs(σ(x', 3n-i+1)) and for any w, w', Hs(w) = Hs(w') => Hs(0||w) != Hs(1||w)
as Hs(x) = Hs(x'), at some point in the calculation there must be
    yt1^e = yt2^e mod N or
    t1^e = t2^e  mod N or
    yt1^e = t2^e mod N
for different t1, t2
y ∈ Zn* means y^-1 exists, the first two cases both reduce to t1^e = t2^e mod N
by definition of GenRSA, gcd(e, φ(N)) = 1, there exists ed = 1 mod φ(N), f(x) = x^e is a permutation on ZN*
if t1^e = t2^e mod N, t1 = t2 mod N, in contradiction to t1, t2 being different
so there must be some different t1, t2 that
    yt1^e = t2^e mod N
    y   = t2^e * (t1^e)^-1 mod N    // f(x) = x^e is a permutation on ZN*, t1^e invertible
        = (t2 * t1^-1)^e mod N  // t1 invertible as t1 = yt1'^e or t1'^e, both y and t1'^e invertible by induction
therefore t2 * t1^-1 is a e-th root of y
assume A can find a collision of Π = (Gen, H):
    Pr[Hash-coll(A, Π, n) = 1] = ε(n)
define another A' attacking RSA problem that:
    on input s = (N, e, y), run (x, x') = A(s)
    calculate Hs(σ(x, i)), Hs(σ(x', i)) for i from 1 to 3n, find the first pair that
        x(3n-i) != x'(3n-i)
        t1 = Hs(σ(x, i)) != Hs(σ(x', i)) = t2
        Hs(σ(x, i+1)) = Hs(σ(x', i+1))
    if x'(3n-i) = 0, output t2 * t1^-1 mod N; otherwise output t1 * t2^-1 mod N
A' correctly simulates A
if A succeeds, by the previous argument, A' outputs some x ∈ ZN* that x^e = y,
if RSA problem is hard relative to Gen
    negl(n) >= Pr[RSA-inv(A, Gen, n) = 1] >= Pr[Hash-coll(A, Π, n) = 1] = ε(n)
and Construction 7.75 must be a collision-resistant hash function

7.22
given a collision (x, x'), x != x', Hs(x) = Hs(x') for some s = (G, q, (h1 .. ht))
x = x1 .. xt, x' = x'1 .. x't, xi, x'i ∈ Zq
    Πhi^xi = Πhi^x'i
as q is a prime and h1 is a generator of q, G is cyclic and any h except the identity is a generator of order q
assume the operation in group G can be done in polynomial time
h^q = 1, h * h^(q-1) = 1, the inverse of every element in G exists and can be calculated in polynomial time
    Πhi^xi = Πhi^x'i
    Πhi^xi * (hi^-1)^x'i = 1
    Πhi^(xi - x'i) = 1
as x != x, at least one xi - x'i will be non-zero
define f(x) = h1^k, f:Zq -> G is a bijection, ki <- Zq implies hi = f(ki) = h1^ki <- G, then
    Πhi^(xi - x'i) = Πh1^ki^(xi - x'i) = h1^(Σki(xi - x'i)) = 1
    k1 = 1, k2 .. kt <- Zq
therefore Σki(xi - x'i) = 0 mod q
for some specific i' that xi' - x'i' != 0, 
    ki'(xi' - x'i') + Σ(i != i')ki(xi - x'i) = 0 mod q
    [ki'(xi' - x'i') mod q] = q - [Σ(i!=i')ki(xi - x'i) mod q]
    [ki' mod q] = [(q - [Σ(i!=i')ki(xi - x'i)])(xi' - x'i')^-1 mod q]
ki' can be calculated from Σki(xi - x'i)
if some algorithm A can find a collision in Π = (Gen, H):
    Pr[Hash-coll(A, Π, n) = 1] = ε(n)
define another A' attacking DLog that:
    on input G, q, g, h
    sample i <- {1 .. t}
    sample k2 .. ki-1, ki+1 .. kt <- Zq
    compute hj = g^kj for j = 2 .. i-1, i+1 .. t
    define h1 = g, hi = h, run (x, x') = A((G, q, (h1 .. ht)))
    compute Δj = (xj - x'j) for j ∈ {1 .. t}
    if Δi != 0: compute and output [(q - [ΣΔj * kj mod q]) * Δi^-1 mod q]
A' correctly simulates A as h is randomly chosen from G
as x != x, at least one xj != x'j, this j is independent to i
with probability 1/t, i = j and Δi != 0
when i = j and A successfully finds a collision, the calculated output is the correct k that g^k = h
when discrete logarithm is hard,
    negl(n) >= (Pr[DLog(A', G, n) = 1] >= ε(n)/t
as t = poly(n), ε(n) must be negligible and (Gen, H) is a collision-resistant hash function
H maps x1 .. xt ∈ Zq to G, every string in {0,1}^(||q||-1) = {0,1}^(n-1) can be parsed as a number in Zq
thereby H is defined on all strings {0,1}^t(n-1)
when representing an element in G requires p(n) bits, H: {0,1}^t(n-1) -> {0,1}^p(n)
when t(n-1) > p(n), H achieves compression
as an example, when t = p(n), t(n-1) = p(n)(n-1) > p(n)

Chapter 8
8.1
this method is vulnerable to Pollard's p-1 method
say both p-1 and q-1 are multiplication of a subset of the first k (small) primes
define B = Π(i∈{1 .. k})pi, (p-1)|B and (q-1)|B
then for some x ∈ ZN*, [x^B mod N] <-> (xp, xq)^B = (1,1), [x^B mod N] = 1
by testing x^B mod N, a smallest possible k can be found by binary search
as p != q, p-1 != q-1, there must be some pi, i <= k that pi|(p-1) but not pi|(q-1)
brute force such a pi and define B' = B/pi, (q-1)|B but not (p-1)|B
B' satisfies the requirement of Pollard's p-1 method
when k = O(polylog(q)), the instructions above can be done in O(polylog(q)) time
this method of choosing prime numbers is not secure

8.2
a.  q = p^e, g^p^(e-1)|q => ord(g^p^(e-1)) = ord(g)/p^(e-1) = p
    define y' = y^p^(e-1), g' = g^p^(e-1)
    solving (g^p^(e-1))^x0 = y^p^(e-1) is now g'^x0 = y', a new discrete logarithm problem with ord(g') = p
    use baby-step/giant-step algorithm and it can be solved in time O(p^1/2 * polylog(q))
b.  ord(g) = q means the g^x0 * g^(q - x0) = g^q = 1, g^(q - x0) = (g^x0)^-1 is the inverse of g^x0
    multiplying both side of g^x = y by (g^x0)^-1,
        g^(x0 + x1p + .. + xe-1p^(e-1)) * (g^x0)^-1 = y * g^(x0)^-1
        (g^p)^(x1 + x2p + .. + xe-1p^(e-2)) = y * g^(x0)^-1 = y'
c.  the equation above is a discrete logarithm in the same group with ord(g^p) = q/p = p^(e-1)
    apply the instructions in part a again can again solve x1 in time O(p^1/2 * polylog(q))
    at the last step, (g^p^(e-1))^xe-1 = y* for some y* can be solved in time O(p^1/2 * polylog(q))
        P(e) = P(e-1) + O(p^1/2 * polylog(q))
        P(1) = O(p^1/2 * polylog(q))
    by master theorem:
        P(e) = O(e * p^1/2 * polylog(q)) = O(p^1/2 * polylog(q))

8.3
every pi^ei and pj^ej is pairwise relatively prime when i != j
by Pohlig-Hellman algorithm, the discrete logarithm problem g^x = y can be reduced to i problems gi^xi = yi
where gi = g^(q/pi^ei), yi = y^(pi^ei), ord(gi) = pi^ei
by problem 8.2, such a sub problem can be solved in time O(pi^1/2 * polylog(q))
reconstruction from i sub problems to the original problem takes time O(polylog(q)) by Chinese remainder theorem
therefore the original problem can be solved in time O(∑pi^1/2 * polylog(q)) = O(max{pi}^1/2 * polylog(q))

8.4
a.  i.  d|b and d|N
        ab = c + kN
        d|b => d|ab => d|(c + kN) => c + kN = 0 mod d
        d|N => c + kN = c + kk'd, c + kk'd = c mod d, c = 0 mod d, d|c
    ii. ab = c + kN => ak1d = k2d + kk3d => aki = k2 + kk3 => a(b/d) = (c/d) + k(N/d)
        a(b/d) = c/d mod N/d
    iii.if gcd(b/d, N/d) > 1 = d'
        d'|b/d and d'|N/d => dd'|b and dd'|N, dd' > d, in contradiction to gcd(b, N) = d
b.  when g, y ∈ ZN, xg = y mod N
    calculate d = gcd(g, N)
    by ai, d|y
    by aii, x(g/d) = y/d mod N/d
    by aiii, gcd(g/d, N/d) = 1
    the problem xg = y mod N is now reduced to the problem x(g/d) = y/d mod N/d
    denote g' = g/d, y' = y/d, N' = N/d, g', y' < N' as g < N
    as gcd(g', N') = 1, Xg' + YN' = 1
    for every number k in ZN', kXg' + kYN' = k, [kX mod N']g' = k mod N', g' is a generator of ZN
    apply the method described in 8.2.3, x can be efficiently found and
        x(g/d) = y/d mod N/d
        x(g/d) = y/d + k(N/d)
        xg = y + kN
        xg = y mod N
    x is also the solution of the original problem

8.5
define a series of strings x1 .. as xi+1 = H(xi) for a randomly chosen x1
if there are some H(xi) = H(xj) for i < j in the series
the series {H(xi)} repeats j-i elements after xi
define k as the smallest integer that k(j-i) >= i, define i' = k(j-i)
i' < j and H(xi') = H(x2i') as in Claim 8.2
define an algorithm that:
    sample x0 <- {0,1}^l(n), where l(n) is the output length of H
    set xi = x2i = x0
    for i = 1 to k:
        xi' = H(xi)
        x2i' = H(H(x2i))
        compare xi' and x2i', output (xi, H(x2i)) if xi' = x2i'
        xi = xi'
        x2i = x2i'
take k = Θ(2^l(n)/2)
if the series {xi} can be viewed as independently sampled strings in {0,1}^l(n), by birthday problem:
    coll(k) >= k(k-1)/4|{0,1}^l(n)| ≒ 1/4
    Pr[xi = xj, i != j] = negl(n)
the algorithm have 1/4 - negl(n) probability finding a collision of H
by repeating the algorithm polynomial times with different x0, with 1 - negl(n) probability a collision can be found

Chapter 9
9.1
a.  Π' = (Πk, Πe) consists of two schemes: a key-exchange protocol Πk and an encryption scheme Πe = (Gen, Enc, Dec)
    define an experiment KEPrivK(A, (Πk, Πe), n) that:
        run (trans, k) <- Πk(1^n)
        pass trans to A, A outputs a pair of messages (m0, m1)
        sample b <- {0,1}, pass Enc(k, mb) to A, A outputs a bit b' ∈ {0,1}
        the output of the experiment is defined as 1 if b = b'; 0 otherwise
    an interactive protocol Π' has indistinguishable encryptions if,
    for all polynomial time probabilistic adversary A there is a negligible function negl that:
        Pr[KEPrivK(A, Π', n) = 1] <= 1/2 + negl(n)
b.  assume there is some A attacking KEPrivK(A, Π', n) and
        Pr[KEPrivK(A, Π', n) = 1] = 1/2 + ε(n)
    define another experiment KEPrivK'(A, Π', n) that:
        run (trans, _) <- Πk(1^n)
        pass trans to A, A outputs a pair of messages (m0, m1)
        sample k <- Gen(1^n), b <- {0,1}, pass Enc(k, mb) to A, A outputs a bit b' ∈ {0,1}
        the output of the experiment is defiend as 1 if b = b'; 0 otherwise
    define:
        Pr[KEPrivK'(A, Π', n) = 1] = 1/2 + ε'(n)
    define another A' attacking PrivK(A', Πe, n) that:
        runs (trans, _) <- Πk(1^n)
        pass trans to A, get a pair of message (m0, m1)
        output (m0, m1), get a challenge ciphertext c
        pass c to A, output whatever A outputs
    A' correctly simulates KEPrivK'(A, Π', n) as PrivK chooses k <- Gen(1^n)
    when A successfully guesses b, A' succeeds in guessing b as well
    assume Πe has indistinguishable encryption:
        1/2 + negl(n) >= Pr[PrivK(A', Πe, n) = 1] >= Pr[KEPrivK'(A, Π', n) = 1] = 1/2 + ε'(n)
        ε'(n) <= negl(n)
    define another A* attacking KE(A*, Π', n) that:
        on input (trans, k), pass trans to A, get a pair of messages (m0, m1)
        sample b <- {0,1}, pass Enc(k, mb) to A, get a bit b'
        if b = b', output 1; otherwise output 0
    when k <- {0,1}^n (supposedly equivalent to k <- Gen(1^n)), A* simulates KEPrivK'(A, Π', n)
        Pr[KE(A*, Π', n) = 1 | b = 0] = Pr[KEPrivK'(A, Π', n) = 1] = 1/2 + ε'(n)
        (here b refers to the one generated by experiment KE, not that one generated by A*)
    when (trans, k) <- Πk(1^n), A* simulates KEPrivK(A, Π', n)
        Pr[KE(A*, Π', n) = 1 | b = 1] = Pr[KEPrivK(A, Π', n) = 1] = 1/2 + ε(n)
    assume Πk is secure,
        1/2 + negl(n)   >= Pr[KE(A*, Π', n) = 1]
                        = 1/2 * Pr[KE(A*, Π', n) = 1 | b = 0] + 1/2 * Pr[KE(A*, Π', n) = 1 | b = 1]
                        = 1/2 * (1/2 + ε'(n)) + 1/2 * (1/2 + ε(n))
                        = 1/2 + ε'(n)/2 + ε(n)/2
        (by negl(n) >= ε'(n))
        1/2 + negl(n) >= 1/2 + ε(n)/2
    and the interactive protocol Π' has indistinguishable encryption 

9.2
an adversary A in Diffie-Hellman key-exchange protocol can manipulate the transcript and impersonate both Alice and Bob
on receiving (G, q, g, h1) from Alice where h1 = g^x, A sample an x' <- Zq and send h1' = g^x' it to Bob
when Bob send h2 = g^y back, A sample another y' <- Zq that h1^y' != h2^x' and send h2' = g^y' to Alice
then A knows (h1, h2, h1', h2') = (g^x, g^y, g^x', g^y')
Alice receives h2' and defines her key kA = h2'^x = g^xy'
Bob receives h1' and defines his key kB = h1'^y = g^x'y
both keys can be calculated from what A knows, and by choices of x' and y' kA and kB are guaranteed to be different
assume A is still there when Alice and Bob send each other questions only them know the answer
as A knows both kA and kB, A can: 
    receive ciphertext from Alice
    decrypt it with kA
    encrypt it with kB
    send to Bob
    (or vice versa)
both party won't notice any difference
after A leaves, Alice and Bob will no longer be able to decrypt ciphertexts from each other
only then they will notice the existance of the adversary

9.3
w xor t = u xor r xor t = s xor t xor r xor t = k xor r xor t xor r xor t = k
thereby w xor t = k and both parties output the same key
an adversary can get:
    s = k xor r
    u = s xor t
    w = u xor r
then s xor w xor u = k xor r xor u xor r xor u = k
this protocol is not secure

Chapter 10
10.1
as Enc is efficiently computable, the number of random coins it can use is bounded by some polynomial p
an adversary A with unbounded computational power can enumerate all possible random tapes r with length p(n)
define A as:
    on input (pk, 1^n), outputs (0, 1), get a challenge ciphertext c
    for all r <- {0,1}^p(n), compute c' = Enc(pk, 0; r), compare the result to c
    if any c' equals c, A outputs 0; otherwise A outputs 1
if b = 0, c = Enc(pk, 0; r) for some r, there must be some c' = c, A always output 0
if b = 1, no Enc(pk, 0; r) can be c or the scheme does not have correct decryption, A always otuput 1
    Pr[PubK(A, Π, n) = 1]   = 1/2 * (Pr[b' = 0 | b = 0] + Pr[b' = 1 | b = 1])
                            = 1/2 * (1 + 1)
                            = 1
as (0, 1) is the only possible different pair of messages in the message space and A is symmetric
this implies that A can judge m ∈ {0,1} from c = Enc(pk, m) with pk

10.2
as L is a small finite set
time encrypting an element in L is bounded by a constant equal to the maximal time required encrypting any element in L
an adversary with c = Enc(pk, m) can compute Enc(pk, m') for all m' ∈ L
as Enc is deterministic, if m = m', Enc(pk, m) = Enc(pk, m')
if Enc(pk, m) = Enc(pk, m'), m must be equal to m' or Π does not have correct decryption
therefore f(m) = Enc(pk, m) is a bijection, Enc(pk, m) = Enc(pk, m') iff m = m'
computing all Enc(pk, m') requires time O(L) as encryption for m ∈ L can be done in constant time

10.3
assume |Enc(pk, b)| = O(log(n)), then there are at most 2^O(log(n)) = n^c = p(n) = poly(n) different ciphertexts
define an adversary A attacking PubK(A, Π, n) on message space M = {0,1} that:
    on input (pk, 1^n), output (0, 1), receive a challenge ciphertext c
    compute c' <- Enc(pk, 0), if c' = c, output 0; otherwise output 0 or 1 randomly
define C = {c | c <- Enc(pk, 0)}, then |C| <= p(n) and there must be some c* that Pr[C = c*] >= 1/p(n)
if b = 0, c and c' are two independent samples of C
    Pr[c = c'] >= Pr[c = c' = c*] = Pr[C = c*]^2 = 1/p(n)^2
    Pr[PubK(A, Π, n) = 1 | b = 0]   = Pr[b' = 0 | c = c'] * Pr[c = c'] + Pr[b' = 0 | c != c'] * Pr[c != c']
                                    = Pr[c = c'] + 1/2 * (1 - Pr[c = c'])
                                    = 1/2 + 1/2 * Pr[c = c']
                                    >= 1/2 + 1/2p(n)^2
when b = 1, c will never be equal to c' or Π does not have correct decryption
    Pr[PubK(A, Π, n) = 1 | b = 1]   = 1/2
thereby
    Pr[PubK(A, Π, n) = 1]   = 1/2 * Pr[PubK(A, Π, n) = 1 | b = 0] + 1/2 * Pr[PubK(A, Π, n) = 1 | b = 1]
                            = 1/2 + 1/4p(n)^2
when p(n) is a polynomial, 4p(n)^2 is a polynomial and is non-negligible
therefore if Π is a CPA-secure public-key encryption scheme, |Enc(pk, b)| = ω(log(n))

10.4
thanks https://www-cc.cs.uni-saarland.de/media/lectures/W1617/L-Cryptography/Assignment11SOL.pdf
for a 2-round key-exchange protocol Πk, define a public-key encryption scheme Π = (Gen, Enc, Dec) that:
    Gen:    on input 1^n, simulate party A by a machine MA until it sends the first transcript trans1 to B
            define pk = trans1, sk = the configuration of MA right after outputted trans1
            (as Πk is efficient and not non-deterministic, A is polynomial time reducible to MA and |sk| = poly(n))
            output (pk, sk)
    Enc:    on input (pk, m), simulate B until it outputs both the second transcript trans2 and a key k
            define c = k xor m, output (trans2, c)
    Dec:    on input (sk, (trans2, c)), run the simulation of MA from the configuration sk
            when sk requires the second transcript, give it trans2
            when MA finally outputs a key k, output k xor c
Π simulates A and B running Πk, therefore k outputted by both party will be the same key and
    k xor c = k xor k xor m = m
thus Π has correct decryption
assume some adversary A attacking PubK(A, Π, n) and
    Pr[PubK(A, Π, n) = 1] = ε(n)
define another A' attacking KE(A', Πk, n) that:
    run A as a subroutine
    on input ((trans1, trans2), k), pass trans1 to A, A outputs (m0, m1)
    sample b <- {0,1}, pass (trans2, k xor mb), A outputs b'
    if b = b', output 1; otherwise output 0
if (trans, k) <- Πk(1^n), k is generated by Πk and A' correctly simulates PubK(A, Π, n), thereby
    Pr[PE(A', Πk, n) = 1 | b = 1] = Pr[PubK(A, Π, n) = 1] = ε(n)
    (here b is the one generated by PE, not that by A')
if k <- {0,1}^n, k is totally independent to pk (so A does not have free access to an encryption oracle in this case)
A is equivalently running PrivK(A, Π', n) with a one-time pad encryption scheme Π' with no encryption oracle, so
    Pr[PE(A', Πk, n) = 1 | b = 0] = Pr[PrivK(A, Π', n) = 1] = 1/2   // by perfect secrecy of one-time pad
therefore
    Pr[PE(A', Πk, n) = 1]   = 1/2 * (Pr[PE(A', Πk, n) = 1 | b = 0] + Pr[PE(A', Πk, n) = 1 | b = 1])
                            = 1/2 * (1/2 + ε(n))
                            = 1/4 + ε(n)/2
if Πk is secure,
    1/2 + negl(n) >= 1/4 + ε(n)/2
    1/2 + 2negl(n) >= ε(n)
    1/2 + negl'(n) >= ε(n)
and Π must be CPA-secure

10.5
assume A is an adversary outputs two vectors of messages M0 and M1, M0 = (m01 .. m0k), M1 = (m11 .. m1k)
as A is PPT, k is bounded by a polynomial t(n) given security parameter n and define
    Pr[PubKmult(A, Π, n) = 1] = ε(n)
define A' be an adversary attacking PubKmult(A', Π, n) and outputs two message vectors M'0 and M'1 of length t(n) that:
    run A as a subroutine 
    on input (pk, 1^n), pass (pk, 1^n) to A, get two message vectors M0 and M1 of length k
    pad both M0 and M1 to length t(n) by appending 0^|m00| (m00 is the first element in M0), get M0' and M1'
    output M0' and M1', get a vector of challenge ciphertexts C, pass the first k elements of C to A
    output whatever A outputs
C is the encryption of Mb' where b <- {0,1}, thereby the first k elements of C is the encryption of Mb where b <- {0,1}
A' correctly simulates PubKmult(A, Π, n) and A' succeeds iff A succeeds, by Definition 10.7:
    1/2 + negl(n) >= Pr[PubKmult(A', Π, n) = 1] = Pr[PubKmult(A, Π, n) = 1] = ε(n)
therefore Π has indistinguishable multiple encryptions regarding message vectors of variable length k

10.6
define an adversary A' attacking PubK(A', Π, n) that:
    run A as a rubroutine
    on input (pk, 1^n), pass (pk, 1^n) to A, get a pair of vectors ((m00, m01), (m10, m11))
    output a pair of messages (m00, m10), get a challenge ciphertext c0
    compute c1 <- Enc(pk, m11), pass (c0, c1) to A
    output whatever A' outputs
when b = 0, c0 <- Enc(pk, m00) and
    Pr[PubK(A', Π, n) = 1 | b = 0] = Pr[A(Enc(pk, m00), Enc(pk, m11)) = 0]
when b = 1, c0 <- Enc(pk, m10) and 
    Pr[PubK(A', Π, n) = 1 | b = 1] = Pr[A(Enc(pk, m10), Enc(pk, m11)) = 1]
as Π is CPA-secure,
    1/2 + negl(n)   >= Pr[PubK(A', Π, n) = 1]
                    = 1/2 * (Pr[PubK(A', Π, n) =1 | b = 0] + Pr[PubK(A', Π, n) = 1 | b = 1])
                    = 1/2 * Pr[A(Enc(pk, m00), Enc(pk, m11)) = 0]
                    + 1/2 * Pr[A(Enc(pk, m10), Enc(pk, m11)) = 1]

10.7
assume e is known, f(x) = x^e mod N is a bijection in group ZN*, N = pq for some primes p and q
define A' as:
    run A as a subroutine
    on input y = x^e, x unknown, assert that gcd(y, N) = 1
    for i = 1 to log(0.99, 0.01):
        sample r <- ZN, calculate [r^-1 mod N]
        if gcd(r, N) = 1, compute y' = y * r^e mod N, run x' = A(y')
        if (x' * r^-1)^e = y mod N, output x' * r^-1
if gcd(y, N) > 1 or any gcd(r, N) > 1, N can be easily factored
A' can calculate d = e^-1 mod φ(N), then x = x^ed = y^d mod N
assume gcd(y, N) = gcd(r, N) = 1, then y, r <- ZN*, r^e <- ZN* as f(x) = x^e mod N is a bijection
by lemma 10.20, y * r^e is a uniformly chosen element in group ZN*, thereby
    Pr[A(y * r^e) = y^(1/e) * r] = 0.01
repeating with k independently sampled r, the probability that A succeeds at least once is:
    1 - (1 - Pr(A(y * r^e) = y^(1/e) * r))^k = 1 - 0.99^k
take k = log(0.99, 0.01),
    1 - 0.99^k = 1 - 0.99^log(0.99. 0.01) = 1 - 0.01 = 0.99
when x' = y^(1/e) * r, (x' * r^-1)^e = y^(1/e)^e = y mod N, x' * r^-1 is the answer to the original problem
therefore A' successfully calculates y^(1/e) mod N when any one of log(0.99, 0.01) runs of A succeeds
A' succeeds with probability 0.99
by Theorem B.2, exponentiation, inverse, gcd and multiplication can all be done in time poly(||N||)
also log(0.99, 0.01) is a constant, A' runs in time poly(t, ||N||)

10.8
raise x to x^e mod N, by the algorithm in B.2.3, requires #1(b(e)) - 1 multiplication and ||e|| square operations
3 is small and 2^16 + 1 = b10000000000000001
for a random number e with ||e|| = ||2^16+1||, the binary representation of e will typically contain more 1 than 2^16+1
thereby x^e requires more multiplication thus is slower than x^(2^16+1)

10.9
let Π be Construction 10.18 with padding l, assume some adversary attacking PubK(A, Π, n) that:
    Pr[PubK(A, Π, n) = 1] = ε(n)
define another adversary A' attacking PAD(A', GenRSA, l, n) that:
    on input (N, e), pass (N, e) to A, get a pair of messages (m0, m1)
    sample b <- {0,1}, output mb, get y, pass y to A, get a bit b'
    if b = b', output 1; otherwise output 0
when y = [(r||m)^e mod N], y = Enc((N, e), mb), A' correctly simulates PubK(A, Π, n) and
    Pr[PAD(A', GenRSA, l, n) = 1 | y = [(r||m)^e mod N]] = Pr[PubK(A, Π, n) = 1] = ε(n)
when y <- ZN*, y contains no information of and is totally independent to (m0, m1)
b' outputted by A is independent to b and
    Pr[PAD(A', GenRSA, l, n) = 1 | y <- ZN*] = Pr[b' = b] = 1/2
assume l-padded RSA problem is hard relative to GenRSA,
    1/2 + negl(n)   >= Pr[PAD(A', GenRSA, l, n) = 1]
                    = 1/2 * Pr[PAD(A', GenRSA, l, n) = 1 | y = [(r||m)^e mod N]]
                    + 1/2 * Pr[PAD(A', GenRSA, l, n) = 1 | y <- ZN*]
                    = 1/2 * ε(n) + 1/2 * 1/2
                    = 1/4 + ε(n)/2
    1/2 + 2negl(n)  >= ε(n)
    1/2 + negl'(n)  >= ε(n)
therefore Π is CPA-secure

10.10
?

10.11
if b = 0, c1 = g^y, c2 = h^y = g^xy = (g^y)^x = c1^x
if b = 1, as g is a generator of G, c1 and c2 are independent elements in G, Pr[c1^x = c2] = negl(n)
thereby with 1 - negl(n) probability, with knowledge of private key x, compare c2 and c1^x, b can decrypt efficiently
let Π be the this encryption scheme, assume some A attacking PubK(A, Π, n) has:
    Pr[PubK(A, Π, n) = 1] = ε(n)
define another A' attacking DDH problem relative to G that:
    run A as a subroutine
    on input (G, q, g, h1, h2, h3), pass (G, q, g, h1) to A, get a pair of messages (m0, m1)
    without loss of generality, assume m0 = ~m1
    pass (h2, h3) to A, get a bit b'
    if mb' = 0, output 1; otherwise output 0
in DDH experiment, h1 = g^x, h2 = g^y, x, y <- Zq
if h3 = g^xy, h2 = g^y = c1, h3 = g^xy = h1^y = c2, A' is simulating the encryption of m = 0
    Pr[A'(G, q, g, g^x, g^y, g^xy) = 1] = Pr[PubK(A, Π, n) = 1 | mb = 0]
if h3 = g^z, z <- Zq, A' is simulating the encryption of m = 1
    Pr[A'(G, q, g, g^x, g^y, g^z) = 1]  = Pr[PubK(A, Π, n) = 0 | mb = 1]
                                        = 1 - Pr[PubK(A, Π, n) = 1 | mb = 1]
by the setting of experiment PubK and the assumption m0 = ~m1, Pr[mb = 0] = Pr[mb = 1] = 1/2
    |Pr[A'(G, q, g, g^x, g^y, g^xy) = 1] - Pr[A'(G, q, g, g^x, g^y, g^xy) = 1]|
    = |Pr[PubK(A, Π, n) = 1 | mb = 0] + Pr[PubK(A, Π, n) = 1 | mb = 1] - 1|
    = |2 * ε(n) - 1|
if DDH is difficult relative to G,
    |2ε(n) - 1| <= negl(n)
    2ε(n) <= 1 + negl(n)
    ε(n) <= 1/2 + negl(n)/2 = 1/2 + negl'(n)
therefore Π is CPA-secure

10.12
(the problem assumes k can be treated as both a group element and a private key)
by the above assumption, a random element g <- G is also a random key
as g is a generator, choose r <- Zq and g^r is also a uniformly random element in G
define a hybrid encryption scheme that
given El Gamal scheme Π' = (Gen', Enc', Dec') and a private key scheme Π* = (Gen*, Enc*, Dec*), define a scheme Π that:
    Gen:    output (pk, sk) = ((G, q, g, h), (G, q, g, x)) <- Gen'
    Enc:    on a message m, sample r <- Zq, return ciphertext (h^r, Enc*(g^r, m))
    Dec:    on input (c1, c2), calculate k = c1/g^x, output Dec*(k, c2)
k = c1/g^x = h^r/g^x = g^xr/g^x = g^r, c2 is encrypted by the key g^r, this scheme has correct decryption
assume some adversary A attacking PubK(A, Π, n) and:
    Pr[PubK(A, Π, n) = 1] = ε(n)
define another A' attacking DDH problem that:
    run A as a subroutine
    on input (G, q, g, h1, h2, h3), pass (G, q, g, h1) to A, get a pair of messages (m0, m1)
    sample b <- {0,1}, pass (h3, Enc*(h2, m)) to A, get a bit b'
    if b = b', output 1; otherwise output 0
by the setting of DDH experiment, h1 = g^x, h2 = g^y, x, y <- Zq
when h3 = g^xy, h3 = h1^y, A' correctly simulates PubK(A, Π, n) and
    Pr[DDH(G, q, g, g^x, g^y, g^xy) = 1] = ε(n)
when h3 = g^z, z <- Zq, both pk and c1 = h3 contains no information of h2 = g^y
A is effectively running PrivK(A, Π*, n) with no free oracle access to Enc*
assume Π* has indistinguishable encryption:
    Pr[DDH(G, q, g, g^x, g^y, g^z) = 1] = Pr[PrivK(A, Π*, n) = 1] <= 1/2 + negl(n)
assume DDH problem is hard relative to G:
    |Pr[DDH(G, q, g, g^x, g^y, g^xy) = 1] - Pr[DDH(G, q, g, g^x, g^y, g^z) = 1]|
    = |ε(n) - (1/2 + negl(n))| <= negl'(n)
    ε(n)    <= 1/2 + negl(n) + negl'(n)
            = 1/2 + negl''(n)
and Π is CPA-secure

10.13
given a public-key encryption scheme Π = (Gen, Enc, Dec) has indistinguishable encryption with a message space {0,1}
let Π' be the encryption scheme constructed as 10.2 from Π with message space {0,1}*
define an adversary A attacking PubKcca(A, Π', n) that:
    on input pk, output two messages (00, 10)
    on receiving the challenge ciphertext c, parse c = (c1, c2) (implicitly possible by the construction of Π')
    query b' = Deck(c1), output b'
by the definition of Π', for m = m1m2, Enc'(pk, mb) = Enc(pk, mb1)||Enc(pk, mb2)
Deck(c1) = mb1, the first bit of the message
when b = 0, c1 = Enc(pk, 0), b' = Dec(sk, Enc(pk, 0)) = 0; similarly when b = 1, b' = 1
A succeeds with certainty and Π' is not CCA-secure
in CCA-security experiments, the adversary can query the decryption of any ciphertexts except these given as challenges
with a single long message, the ciphertext can be parsed to many shorter ciphertexts
the messages can be totally recovered by query all these shorter ciphertexts to the decryption oracle
while in multiple messages experiment, messages in the vectors are encrypted seperately
an adversary is not allowed to query any ciphertext in the challenge ciphertext vector
to recover some information of the message m from its ciphertext c
the adversary has to modify c to some c', the ciphertext of m' that is somehow relative to m
when the underlying encryption scheme is CCA-secure, such modification is impossible

10.14
on a ciphertext c = m'^e mod N, m' = 0^k||r||0^8||m, calculate c' = c*2^e, then c' = (2m')^e mod N
when the first bit of r chosen during the encryption of m and m itself are both 0
2m' shifts every bit in m' one position to left is still a valid padded message
2m' = 0^k||r<<1||0^8||m<<1||0, where m<<k drops the first k bits from m
if the decryption of c' is not an error, m can be recovered
if the decryption of c' is an error, by probability 1/2 (r starts with 0) the first bit of m is 1
either case some information of m is leaked
in PKCS, the padding contains a 1 at a specific position
it's harder to forge a valid ciphertext in PKCS than in this scheme

10.15
?

10.16
a.  assume that Pr[hc(x) = 1] = ε(n)
    define an adversary A guessing hc(x) from f(x) that:
        always output 1 regardless of the input
    then Pr(x<-DI)[A(f(x)) = hc(x)] = Pr[hc(x) = 1] = ε(n)
    if hc is a hard-core predicate, ε(n) <= 1/2 + negl(n)
    symmetrically, Pr[hc(x) = 0] <= 1/2 + negl(n)
    by choosing n random x, the probability no hc(x) = m is:
        (Pr[hc(x) = ~m])^n = (1/2 + negl(n))^n = ΣC(n, k)(1/2)^k * negl(n)^(n-k) = negl'(n)
    by output ⊥ when no hc(x) = m is find in n trials and define Dec(_, ⊥) = ⊥
    decryption fails with negligible probability (which is acceptable)
    as hc is PPT, n calculation of hc is also PPT, Enc can be performed in polynomial time
b.  assume there is some adversary A attacking PubK(A, Π, n) that:
        Pr[PubK(A, Π, n) = 1] = ε(n)
    define another A' guesses hc(I, x) from f(I, x) that:
        run A as a subroutine
        on input (I, f(I, x)), pass pk = I to A, get a pair of messages (m0, m1)
        assume without loss of generality m0 = ~m1
        pass f(I, x) to A, get a bit b', output mb'
    as x <- DI, if hc(x) = m0, A' simulates PubK(A, Π, n) when b = 0
        Pr[A'(I, f(I, x)) = hc(x) | hc(x) = m0] = Pr[PubK(A, Π, n) = 1 | b = 0]
    symmetrically    
        Pr[A'(I, f(I, x)) = hc(x) | hc(x) = m1] = Pr[PubK(A, Π, n) = 1 | b = 1]
    as m0 = ~m1, hc(x) = m0 or hc(x) = m1, 
        Pr[A'(I, f(I, x)) = hc(x)]  = Pr[A'(I, f(I, x)) = hc(x) | hc(x) = m0] * Pr[hc(x) = m0]
                                    + Pr[A'(I, f(I, x)) = hc(x) | hc(x) = m1] * Pr[hc(x) = m1]
                                    <= Pr[PubK(A, Π, n) = 1 | b = 0] * (1/2 + negl(n))
                                    + Pr[PubK(A, Π, n) = 1 | b = 1] * (1/2 + negl(n))
                                    = Pr[PubK(A, Π, n) = 1] + negl'(n)
                                    = ε(n) + negl'(n)
    when hc is a hard-core predicate,
        ε(n) + negl'(n) <= 1/2 + negl(n)
        ε(n) <= 1/2 + negl''(n)
    and Π is CPA-secure

10.17
a.  if A is dishonest and always output cA = Enc(pk, b) for b = 1 or 0
    B is honest and outputs cB = Enc(pk, b'), Pr[b' = 0] = Pr[b' = 1] = 1/2
    c = b xor b', Pr[c = b] = Pr[b' = 0] = 1/2, Pr[c = ~b] = Pr[b' = 1] = 1/2
    c is still uniformly distributed as an element in {0,1}
b.  the bit first has to be encoded as a group element
    define 0g, 1g ∈ G be the encoding of 0 and 1 in the group
    if A outputs ciphertext (h1, h2), by also output (h1, h2), B chooses the same bit as A, b xor b' = 0
    by output (h1, h2 * 0g^-1 * 1g), if A encodes 0g, B encodes 1g, b xor b' = 1
    if A encodes 1g, the decryption of cB will be an error, b xor b' = 0 never happen
c.  the encryption scheme must be CCA-secure against replay attack

Chapter 11
11.1
let G be a abelian group
let G* be the set of quadratic residues in G, G* = {y | y = x^2, x ∈ G}
as 1^2 = 1, 1 ∈ G*, 1 is also the identity of G*
for any two elements g, h ∈ G*, g = x^2, h = y^2, gh = x^2y^2 = (xy)^2
by closure property of G, xy ∈ G and (xy)^2 ∈ G*, G* has closure property 
for any g = x^2 in G*, x ∈ G, x^-1 ∈ G, g * (x^-1)^2 = x^2 * (x^-1)^2 = (x * x^-1)^2 = 1
the inverse of g is h = (x^-1)^2 and h ∈ G*
the associativity of G implies the associativity of G*
as G* ⊆ G, G* is a subgroup of G

11.2
a.  let p = 2i + 1 be a odd prime number
    for any y ∈ Zp, if y is even, x = y/2 ∈ Zp
    if y is odd, y = 2j+1, j < i
    define x = i + j + 1, x < p => x ∈ Zp
    2x = 2i + 2j + 2 = 2j+1 = y mod p 
    therefore every element in Zp is a quadratic residue
b.  by Chinese remainder theorem, Zpq <-> Zp x Zq
    y = 2x mod N => y <-> 2(xp, xq) => y <-> (xp + xp mod p, xq + xq mod q)
    y is a quadratic residue of ZN iff there there are some quadratic residues xp, xq in Zp, Zq that y <-> (xp, xq)
    as every element in Zp, Zq is a quadratic residue, every element in ZN is also a quadratic residue
c.  N = 2i is an even integer
    for every even element y in ZN, y = 2j, j < i, thereby j ∈ ZN and y is a quadratic residue
    for every odd element y in ZN, y = 2j+1
    if y is a quadratic residue, 2x = y mod N, 2x = y + kN = 2j+1 + k(2i) = 2(j + ki) + 1
    lhs is an even number 2x and rhs is an odd number
    even number cannot be equal to odd number therefore no such x ∈ ZN that 2x = y mod N
    every odd number y in ZN is not a quadratic residue
    quadratic residues in ZN are all even elements in ZN

11.3
both N = pq and p, q are known
|ZN*| = φ(N) = (p-1)(q-1), assume p, q are different primes,
    |ZN*|/|ZN| = (p-1)(q-1)/pq >= 2/6 = 1/3
by sample n independent 0 < z < N, with probability 1 - (2/3)^n more than one of them are in ZN*
testing whether z ∈ ZN* is equivalent to test gcd(z, N) = 1, can be done in time poly(||N||)
thereby ZN* is efficiently samplable
with a random z <- ZN*, z ∈ QNR+1 iff Jp([z mod p]) = Jq([z mod q]) = -1
both Jp and Jq can be calculated in time poly(||N||), and Pr[z ∈ QNR+1] = 1/4
by sample n = ||N|| random z <- ZN* and test Jp([z mod p]) and Jq([z mod q])
with probability 1 - (3/4)^n at least one z ∈ QNR+1 can be found in time poly(||N||)
the probability of failure is (3/4)^||N||, negligible in ||N||

11.4
if x ∈ QR, x <-> (xp, xq) and Jp(xp) = Jq(xq) = 1
x * x^-1 = 1 mod N => x^-1 <-> (xp', xq') and (xp, xq) * (xp', xq') = (1, 1) => xp' * xp = 1 mod p, xq' * xq = 1 mod q
Jp(xp * xp') = Jp(1) = 1, Jq(xq * xq') = Jq(1) = 1
as Jp(xp) = Jq(xq) = 1, Jp(xp') = Jq(xq') = 1, [x^-1 mod N] ∈ QR
if x ∈ QNR+1, Jp(xp) = Jq(xq) = -1
again Jp(xp * xp') = Jp(1) = 1 = Jp(xq * xq')
Jp(xp') = Jq(xq') = -1, [x^-1 mod N] ∈ QNR+1

11.5
for z ∈ QNR+1, [z^-1 mod N] ∈ QNR+1 and
    Pr[zx = y mod N] = Pr[x = z^-1y mod N]
given y ∈ QNR+1, x' = [z^-1 * y mod N] ∈ QR is a fixed quadratic residue of ZN*
when x <- QR,
    Pr[x = z^-1y mod N] = Pr[x = x'] = 1/|QR|

11.6
let N = p1p2p3p4p5
by Chinese remainder theorem, [x mod N] <-> ([x mod p1], [x mod p2], [x mod p3], [x mod p4], [x mod p5])
different (x1, x2, x3, x4, x5) corresponds to different element of ZN*
by an extension of Propositon 11.6
y ∈ ZN* is a quadratic residue iff y <-> (y1 .. y5) and y1 .. y5 are quadratic residues in their corresponding groups
if yi ∈ Zpi is a quadratic residue, yi has exactly two suqare roots xi and -xi
by choose xi or -xi for i = 1 .. 5, there are 2^5 = 32 different elements (x1 .. x5) in Zp1 x Zp2 x Zp3 x Zp4 x Zp5 that
    (x1 .. x5)^2 = (y1 .. y5) <-> y
all (x1 .. x5) are mutually different i.e. corresponds to different elements in ZN*
therefore there are 32 differernt x ∈ ZN* that x^2 = y mod N, y has 32 square roots 

11.7
a.  as p|N and q|N, [-1 mod N] = -1 mod p and [-1 mod N] = -1 mod q
    [-1 mod N] <-> ([-1 mod p], [-1 mod q])
    p = 3 + 4i, q = 3 + 4j
    Jp([-1 mod p]) = (-1)^((p-1)/2) = (-1)^((2+4i)/2) = (-1)^(1 + 2i) = -1
    similarly Jq([-1 mod q]) = -1, thereby [-1 mod N] ∈ QNR+1
b.  when deciding quadratic residuosity is hard relative to GenModulus
    this scheme is equivalent to Construction 11.13 with fixed z = [-1 mod N]
    decryption is still determined by the qudratic residuosity of ciphertext
    [-1 mod N] incurs no difference compared to any other z ∈ QNR+1
    assume for some adversary A that:
        Pr[PubK(A, Π, n) = 1] = ε(n)
    define another D solving decisional quadratic residuosity problem that:
        on input (N, z), pass pk = N to A, get a pair of messages (m0, m1)
        sample b <- {0,1}, x <- ZN*, compute c = [z^mb * x^2 mod N]
        pass c to A, get a bit b', output 1 if b = b'; output 0 otherwise
    by exactly the same argument in Theorem 11.14,
        |Pr[D(N, qr) = 1] - Pr[D(N, qnr) = 1]|  = |ε(n) - 1/2| <= negl(n)
        ε(n) <= 1/2 + negl(n)
    and Π is CPA-secure

11.8
assume some D can distinguish (N, QR) and (N, JN+1) with probability ε(n):
    |Pr[D(N, QR) = 1] - Pr[D(N, JN+1) = 1]| = ε(n)
define another D' that:
    sample b <- {0,1}, x <- ZN*, y = [x^2 mod N]
    on input (N, z)
        if b = 0, set z' = z
        if b = 1, set z' = y
    pass (N, z') to D, output whatever D outputs
the distribution of z' is solely determined by z
when z <- QR, no matter b = 1 or 0, z' is a random element in QR,
    Pr[D'(N, qr) = 1] = Pr[D(N, qr) = 1]
when z <- QNR+1, with half the probability b = 1 and z' <- QR, the same for b = 0 and z' <- QNR+1
Proposition 11.8 says |JN+1| = |QR| + |QNR+1|, |QR| = |QNR+1|
for any element y' in JN+1,
    Pr[z' = y']  = Pr[z' = y' | z' ∈ QR] * Pr[z' ∈ QR] + Pr[z' = y' | z' ∈ QNR+1] * Pr[z' ∈ QNR+1]
                = Pr[z' = y' | b = 1] * Pr[b = 1] + Pr[z' = y' | b = 0] * Pr[b = 0]
                = 1/2 * (Pr[y = y'] + Pr[z = y']) 
as y' ∈ JN+1, z <- QNR+1, y <- QR, either Pr[y = y'] = 0 or Pr[z = y'] = 0, the other is 2/|JN+1|
    Pr[z' = y'] = 1/2 * 2/|JN+1| = 1/|JN+1|
and z' is a uniformly random element of JN+1,
    Pr[D'(N, qnr) = 1] = Pr[D(N, JN+1) = 1]
assume decide quadratic residuosity is hard relative to GenModulus,
    |Pr[D'(N, qr) = 1] - {r[D'(N, qnr) = 1]|    = |Pr[D(N, qr) = 1] - Pr[D(N, JN+1) = 1]|
                                                = ε(n) <= negl(n)
therefore distinguishing z <- QR and z <- JN+1 is also hard                                                 

11.9
a.  as mensioned in section 11.1.3, there isa polynomial time algorithm calculating JN(x) without factoring N
    by sample x <- ZN*,Pr[JN(x) = 1] = 1/2
    by sample n random x <- ZN* and test JN(x), with 1 - (1/2)^n the algorithm can find at least one x ∈ JN+1
b.  on receiving (c1 .. cn), the receiver tests quadratic residuosity of all ci
    (can be done in poly(n) as Algorithm 11.11)
    if all ci ∈ QR, Dec(sk, c*) = 0
    if there is some ci ∉ QR, Dec(sk, c*) = 1
    when m = 0, all ci <- QR, Dec(sk, c*) = 0 with certainty
    when m = 1, as ci <- JN+1, Pr[c1 .. ci ∈ QR] = Pr[ci ∈ QR]^n = (1/2)^n
    with probability (1/2)^n, Dec(sk, c*) = 0, otherwise Dec(sk, c*) = 1, the probability of failure is negligible
c.  assume some adversary A attacking PubK(A, Π, n) that:
        Pr[PubK(A, Π, n) = 1] = ε(n)
    define another D distinguishing z <- QR and z <- JN+1 that:
        on input (N, z), pass N to A, get a pair of one-bit messages (m0, m1)
        assume without loss of generality, m0 = ~m1
        sample n different xi <- ZN*, compute yi = [xi^2 mod N], sample b <- {0,1}
        set ci = [z^b * yi mod N]
        pass c* = (c1 .. cn) to A, get a bit b'
        output mb'
    when z <- QR, both yi and z * yi are independent elements in group QR
    D is simulating PubK(A, Π, n) when the message get encrypted is 0, thus
        Pr[D(N, qr) = 1]    = Pr[mb' = 1 | mb = 0] 
                            = Pr[PubK(A, Π, n) = 0 | mb = 0]
                            = 1 - Pr[PubK(A, Π, n) = 1 | mb = 0]
    when z <- JN+1 and b = 1, with 1/2 probability, z <- QR and z * yi is a random element in group QR
    also with 1/2 probability, z <- QNR+1, z * yi ∈ QNR+1
    if z * yi = z * yj, as z ∈ ZN*, z^-1 ∈ ZN* and yi = yj mod N
    as |QR| = |QNR+1|, f(y) = [z * y mod N] is a bijection QR -> QNR+1
    z * yi is a uniformly random element in QNR+1 given yi <- QR
    when b = 0, yi <- QR
    by the same argument in problem 11.8, z^b * yi <- JN+1
    D is simulating PubK(A, Π, n) when the message get encrypted is 1, thus
        Pr[D(N, JN+1) = 1]  = Pr[mb' = 1 | mb = 1] 
                            = Pr[PubK(A, Π, n) = 1 | mb = 1]
    assume deciding quadratic residuosity is hard relative to GenModulus
    problem 11.8 shows that it's also difficult to distinguish z <- QR and z <- JN+1, therefore
        |Pr[D(N, qr) = 1] - Pr[D(N, JN+1) =1]|
        = |1 - (Pr[PubK(A, Π, n) = 1 | mb = 0] + Pr[PubK(A, Π, n) = 1 | mb = 1])|
        = |1 - 2ε(n)| <= negl(n)
        2ε(n) <= 1 + negl(n)
        ε(n) <= 1/2 + negl(n)/2 = 1/2 + negl'(n)
    and Π is CPA-secure

11.10
assume p is odd (true for all n > 2)
given h = g^x, x ∈ Zp, by computing Jp(h), a PPT algorithm can decide whether x is an even number
if for h1 = g^x and h2 = g^y, both x and y are even, then xy is an even number and g^xy is a quadratic residue of Zp as
    g^[(xy/2) mod φ(p)]^2 = g^[xy mod φ(p)] = g^xy
so Jp(g^xy) = 1
for a random z <- Zp*, Pr[Jp(g^z) = 1] = |QR|/|Zp*| = 1/2
define an adversary attacking DDH problem that:
    on input (G, q, g, h1, h2, h3), compute Jp(h1), Jp(h2), Jp(h3)
    if Jp(h1) = Jp(h2) = 1, output Jp(h3); otherwise output 0 or 1 randomly
when h1 = g^x, h2 = g^y, h3 = g^xy, with probability 1/4, Jp(h1) = Jp(h2) = 1, implies Jp(h3) = 1
    Pr[D(G, q, g, g^x, g^y, g^xy) = 1] = 3/4 * 1/2 + 1/4 * 1 = 5/8
when h1 = g^x, h2 = g^y, h3 = g^z, with probability 1/4, Jp(h1) = Jp(h2) = 1
z is independent to x, y, Pr[Jp(h3) = 1] = 1/2
    Pr[D(G, q, g, g^x, g^y, g^z) = 1] = 3/4 * 1/2 + 1/4 * 1/2 = 1/2
    |Pr[D(G, q, g, g^x, g^y, g^xy) = 1] - Pr[D(G, q, g, g^x, g^y, g^z) = 1]|
    = 1/8 (for infinitely many n)
therefore DDH problem is not hard relative to G

11.11
let f(x) = [g^x mod p], lsb(x) is determined by the oddity of x that:
    lsb(x) = 0 if x is even
    lsb(x) = 1 is x is odd
f(x) is a bijection Zφ(p) -> Zp*
f(x+y) = g^(x+y) = g^x * g^y = f(x) * f(y)
f(x) is an isomorphism Zφ(p) -> Zp*
if g^y is a quadratic residue of Zp*
    f(y) = g^y = g^x * g^x = f(x) * f(x) = f(x+x)
[y mod φ(p)] is also a quadratic residue of Zφ(p)
conversely, if y = 2x mod φ(p), f(y) = f(x+x) = f(x) * f(x), f(y) = [g^y mod p] is a quadratic residue of Zp*
assume p is odd (true for all n > 2), φ(p) = p-1 is even
by problem 11.2, if [g^y mod p] is a quadratic residue of Zp*, [y mod φ(p)] is even
y = [y mod φ(p)] + kφ(p), thereby y is even too
if [y mod φ(p)] is odd, y = [y mod φ(p)] + kφ(p) is odd and [g^y mod p] is not a quadratic residue of Zp*
this means by computing Jp(g^y), a PPT algorithm can decide the quadratic residuosity of g^y, thus the oddity of y
therefore lsb(x) can be computed from f(x) and cannot possibly be a hard-core predicate

11.12
when c = [m^2 mod N], for ciphertext c that is not a quadratic residue in ZN*, Dec(sk, c) must return error messages
even if the scheme try to hide an error by return some element in m on quadratic non-residue c, by computing
    c' = [m^2 mod N]
and c' is a quadratic residue of ZN*, it must have c' != c
thereby in a chosen ciphertext attack, it will be easy to determine the quadratic residuosity of any c ∈ ZN*
by Theorem 11.22, by finding two unrelative quadratic residues x and x', N can be factored in time poly(n)
by Proposition 11.8, Pr(x <- ZN*)[x ∈ QR] = 1/4
by sample n random x <- ZN*, an algorithm can find a quadratic residue with probability 1 - (3/4)^n
by sample other n random x' <- ZN*, another quadratic residue with probility 1 - (3/4)^n
as these two quadratic residues are independent sampling of QR, x' = ±x mod N with probability 2/|QR| = 8/φ(N)
as N = pq is a Blum integer, p, q >= 3, φ(N) = (p-1)(q-1) >= 2N/3
    Pr[x' = ±x mod N] = 8/φ(N) <= 12/N
    Pr[x' != ±x mod N] = 1 - 12/N
an adversary given oracle access to Dec(sk, _) can run the above process and factor N with probability
    (1 - (3/4)^n)^2 * (1 - 12/N)    = (1 - negl(n))^2 * (1 - negl'(n))
                                    = 1 - negl''(n)
and recover the private key (p, q)

11.13
a.  for all quadratic residue z of ZN*, z <-> (yp, yq)
    z has four square roots in the form (xp, xq), (-xp, xq), (xp, -xq), (-xp, -xq)
    assume Jp(xp) = Jq(xq) = 1, Jp(-xp) * Jq(-xq) = 1
    the other two square roots (-xp, xq), (xp, -xq) are not in JN+1
    for x <-> (xp, xq), x' <-> (-xp, -xq), x' = -x mod N, only one of them can be smaller than N/2
    therefore exactly one square root of z is in S, f(x) = [x^2 mod N] is a permutation S -> QR
    define gN(z) as:
        z if z < N/2
        [-z mod N] = N - z if z > N/2
    by problem 11.7, JN(-1) = 1, JN(-z) = JN(-1) * JN(z) = JN(z)
    for z ∈ ZN*, 0 < z < N, gcd(z, N) = 1, gN(z) < N/2 (z = N/2 cannot happen)
    thereby gN maps JN+1 -> S and fN(x) = gN(f(x))
    assume z, w be two quadratic residues of ZN*, gN(z) = gN(w)
    if both 0 < z, w < N/2 or N/2 < z, w < N, z = w
    if z < N/2 and w > N/2,
        w = -z mod N
    as -1 ∈ QNR+1, z ∈ QR, w = -1 * z mod N and w ∈ QNR+1, in contradiction to the assumption
    therefore gN: QR -> S is one-to-one, |QR| = |S|, gN is a permutation QR -> S
    implies fN = gN . f is also a permutation S -> S
b.  define a family of trap-door permutations Π = (Gen, Samp, f, Inv) that:
        Gen:    run (N, p, q) <- GenModulus(1^n), N be a Blum integer, set I = N, td = (p, q), output (I, td)
        Samp:   on input I = N, output a random element x <- S
        f:      on input I = N and x, output fN(x)
        Inv:    on input I = N, td = (p, q) and x, first compute Jp([x mod p]) and Jq([x mod q])
                set z' = [±z mod N] according to the previous computation so z' is a quadratic residue of ZN*
                calculate the unique x ∈ S that x^2 = z' mod N following Lemma 11.21
    Inv(f(x)) = x follows the arguments in part a
    obviously if an adversary can invert f(x), it can compute square root of random z <- QR given only I = N
    if factorization is hard relative to GenModulus, computing square roots is also hard relative to GenModulus
    Π defined here is a family of trap-door permutation

11.14
a.  let g(x) = [x^2 mod N], if g(x) = g(y), x and y are two square roots of g(x) = [x^2 mod N]
    denote x <-> (xp, xq), then the four square roots are
        (xp, xq), (-xp, xq), (xp, -xq), (-xp, -xq)
    assume JN(x) = 1 (other possibilities are symmetric)
        JN((xp, xq)) = JN((-xp, -xq)) = 1
        JN((-xp, xq)) = JN((xp, -xq)) = -1
    if x < N/2, x' <-> (-xp, -xq) and x' = -x mod N, x' > N/2
    similarly halfN((-xp, xq)) = ~halfN((xp, -xq))
    thereby given a, b <- {0,1}, only one square root x of x^2 satisfies JN(x) = a and halfN(x) = b
    therefore if f(x) = f(y),
        g(x) = g(y), x and y are square roots of a specific z ∈ QR
        JN(x) = JN(y), halfN(x) = halfN(y), x and y are both equal to the specific square root of z
    f: ZN* -> QR x {0,1}^2 is one-to-one
    in fact |ZN*| = 4|QR| and f is a permutation
b.  define Π = (Gen, Enc, Dec) that:
        Gen:    run (N, p, q) <- GenModulus, set pk = N, sk = (p, q)
        Enc:    on input (pk, m), choose random r <- {0,1}^(||N|| - n - 1)
                output c = ([(r||m)^2 mod N], JN(r||m), halfN(r||m))
        Dec:    on input (sk, (c, a, b)), calculate the unique square root m' of c that
                    JN(m') = a
                    halfN(m') = b
                and output the last n bits of m'
    correctness of decryption follows part a, security unknown

11.15
given c = f(a, b) = [(1+N)^a * b^N mod N^2], as in the decryption algorithm of Paillier encryption scheme,
    a = [([c^φ(N) mod N^2] - 1)/N * φ(N)^-1 mod N]
can be computed given N and its factorization (thereby φ(N))
as (1+N)^a = 1 + aN mod N^2, gcd(1 + aN, N^2) = 1, (1+N)^a is invertible mod N^2
compute c' = [[c * (1+N)^a^-1 mod N^2] mod N], c' = [[b^N mod N^2] mod N] = [b^N mod N]
as gcd(N, φ(N)) = 1, d = N^-1 mod φ(N) exists, can be computed from N and its factorization
then [c'^d mod N] = [b^Nd mod N] = [b mod N]
as f is defined on ZN x ZN* -> ZN^2*, 0 < b < N, [b mod N] = b
both a and b can be computed from f(a, b), N and the factorization of N

11.16
for an element c in Φ(N^2), c = [(1+N)^a mod N^2], c <-> (a, 1)
c^N = (a, 1)^N = (1, 1) = 1 + N mod N^2
for c' <-> (a, b) that b != 1, c^N = (a, b)^N = (1, b^N)
as gcd(N, φ(N)) = 1, f(b) = b^N mod N is a permutation ZN* -> ZN*, b != 1 implies b^N != 1 mod N
therefore by computing [c^N mod N^2] and compare it to 1 + N, an algorithm can decide whether c ∈ Φ(N^2)

11.17
given m1, m2 ∈ Z2, the ciphertexts c1, c2 ∈ ZN^2* are:
    c1 = [(1+N)^m1 * r1^N mod N^2]
    c2 = [(1+N)^m2 * r2^N mod N^2]
    c1 * c2 = [(1+N)^(m1 + m2) * (r1r2)^N mod N^2]
when m1 = m2 = 0,
    c1 * c2 = [(r1r2)^N mod N^2] is an encryption of m = 0
when m1 = 0, m2 = 1 (and symmetrically),
    c1 * c2 = [(1+N) * (r1r2)^N mod N^2] is an encryption of m = 1
when m1 = m2 = 1, m1 + m2 = 0 mod 2
    c1 * c2 = [(1+N)^2 * (r1r2)^N mod N^2] is an encryption of m = 2 = 0 mod 2
and Dec(c1 * c2) = m1 * m2 mod 2

Chapter 12
12.1
?

12.2
regarding Construction 12.3, assume RSA problem is hard relative to GenRSA
a.  sample r <- ZN*, define r' = r^e mod N, query for signature σ = Sign(sk, r'm) = (r'm)^d mod N
    by definition, σ = (r'm)^d mod N = r'^d * m^d mod N = r^ed * m^d mod N = r * m^d mod N
    output σ' = σ * r^-1 mod N = m^d mod N, then Vrfy(m, σ') = 1
    an adversary can break this definition of security with almost certainty
b.  assume some adversary A can break this security with probability ε(n)
    define another A' attacking RSA problem that:
        run A as a subroutine
        on input (N, e, y), set pk = (N, e), pass (pk, y) to A, get a signature σ ∈ ZN*
        output σ
    A' correctly simulates A in its experiment
    when A successfully outputs a signature σ that Vrfy(y, σ) = 1, y = σ^e mod N, A' succeeds in RSA experiment
    by the assumption above:
        negl(n) >= Pr[RSA-inv(A', GenRSA, n) = 1] = ε(n)
    and the textbook RSA signature scheme is secure in this definition of security

12.3
define "textbook Rabin signature scheme (Gen, Sign, Vrfy) as:
    Gen:    run (N, p, q) <- GenModulus(1^n), where N = pq is a Blum integer
            set pk = N, sk = (p, q), output (pk, sk)
    Sign:   on input (sk, m), where m ∈ QR, output σ, a random square root of m
    Vrfy:   on input (pk, m, σ), output 1 if σ^2 = m mod N
obviously Vrfy(pk, m, Sign(sk, m)) = 1 for all pk, sk and m, this scheme has correct verification
but an adversary with access to a Sign oracle can in fact obtain square root of arbitrary m ∈ QR
if some adversary can obtain two square roots x, x' of the same message m, and x' != ±x mod N,
by Lemma 11.21 the adversary can factor N in time poly(||N||)
by query the same m twice, an adversary get such two x, x' with probability 1/2
the private key sk = (p, q) can be recovered in a chosen-message attack with probability 1/2

12.4
a.  compute if σ^e = enc(m) mod N
b.  when enc is hard to invert, given random σ, it will still be easy to compute enc(m) = σ^e mod N
    but a PPT adversary will not be able to compute a proper m from enc(m), thus no-message attack doesn't work directly
c.  this enc is easy to invert
    given σ^e = enc(m) = 0||m||0^(l/10), |enc(m)| = ||N|| = l
    drop the first and last l/10 0s an adversary can recover m from enc(m)
d.  again enc is easy to invert
    given σ^e = enc(m) = 0||m||0||m, drop the last half and the single leading 0 an adversary can recover m

12.5
let Π' = (Gen', Sign', Vrfy') be a fixed-length signature scheme for messages of length l(n)
define Π = (Gen, Sign, Vrfy) as follows:
    Gen:    identical to Gen'
    Sign:   on input (sk, m), m ∈ {0,1}*, l = |m| <= 2^(l(n)/4), parse m into d blocks m1 .. md, each of length l(n)/4
            (last block is padded with 0s if necessary)
            sample r <- {0,1}^(l(n)/4)
            for i = 1 .. d:
                compute ti <- Sign'(sk, r||l||i||mi), l and i uniquely encoded as strings of length l(n)/4
            output t = <r, t1 .. td>
    Vrfy:   on input (pk, m, t), l = |m| <= 2^(l(n)/4), t = <r, t1 .. td>
            parse m into d' blocks m1 .. md' of length l(n)/4
            if d = d' and Vrfy'(r||l||i||mi, ti) = 1 for all i = 1 .. d, output 1; otherwise output 0
assume for some adversary A attacking Sign-forge(A, Π, n):
    Pr[Sign-forge(A, Π, n) = 1] = ε(n)
let Repeat denote the same identifer r appears in two of the signatures returned by the oracle
as A is PPT, the number of oracle queries by A is bounded by a polynomial q
applying birthday bound:
    Pr[Repeat] <= q(n)^2 / 2^(l(n)/4)
if l(n) is super-logarithm, 1/2^(l(n)/4) and Pr[Repeat] are negligible
let (m, t = <r, t1 ..>) be the final output of A
let Forge denote the event that at least one of the blocks r||l||i||mi was never previously signed by the scheme and
    Vrfy'(pk, r||l||i||mi, ti) = 1
by argument identical to that following Claim 4.8:
    Pr[Sign-forge(A, Π, n) = 1 ∧ ¬Repeat ∧ ¬Forge] = 0
then
    Pr[Sign-forge(A, Π, n) = 1] <= Pr[Repeat]
                                + Pr[Sign-forge(A, Π, n) = 1 ∧ ¬Repeat ∧ ¬Forge]
                                + Pr[Sign-forge(A, Π, n) = 1 ∧ ¬Repeat ∧ Forge]
                                <= negl(n) + Pr[Sign-forge(A, Π, n) = 1 ∧ ¬Repeat ∧ Forge]
    Pr[Sign-forge(A, Π, n) = 1 ∧ ¬Repeat ∧ Forge] <= ε(n) - negl(n)
define another A' attacking Sign-forge(A', Π', n) that:
    run A as a subroutine
    on input pk, pass pk to A
    when A queries its Sign oracle with a message m,
        sample r <- {0,1}^(l(n)/4)
        parse m into d blocks m1 .. md of length l(n)/4
        query and record every block r||l||i||mi in its own Sign' oracle, get ti
        return <r, t1 .. td>
    when A outputs the final result (m, t = <r, t1 ..>),
        parse m = m1 .. md, t = <r, t1 .. td'>
        find the previously unsigned block r||l||i||mi and output (r||l||i||mi, ti)
        if no such block exists, halt
by the same argument at the end of Theorem 4.6,
    Pr[Sign-forge(A', Π', n) = 1] >= Pr[Sign-forge(A, Π, n) = 1] >= ε(n) - negl(n)
assume Π' is secure,
    negl'(n) >= ε(n) - negl(n)
    ε(n) <= negl''(n)
and Π is secure against adaptive chosen-message attacks
l(n) has to be at least super-logarithm
the signature will be linear to the length of the message
however this scheme does not rely on the existance of hash functions compared to hash-and-sign schemes

12.6
a.  define an adversary A that:
        on input pk = y, query for m = n, get a signature σ
        output (n-1, f(σ))
    as σ = Sign(sk, m) = f^(n - n)(x) = x, f(σ) = f(x) = Sign(sk, n-1), Vrfy(n-1, f(σ)) = 1
    A successfully breaks Π with certainty
    given σ = Sign(sk, i), σ = f^(n-i)(x) 
    for any j < i, an adversary can compute σ' = Sign(sk, j) = f^(i-j)(σ) = f^(n-j)(x) and output (j, σ') as a forgery
b.  assume an adversary A given a signature on i can output a forgery on some message j > i with probability ε(n)
    define another A' attacking Invert(A', f, n) that:
        run A as a subroutine
        on input y, compute pk = f^i(y), pass pk to A
        when A queries a message i',
            if i != i', halt
            if i = i', output y
        when A finally outputs (j, σ),
            if j <= i, halt
            if j > i, compute x = f^(j-i-1)(σ), output x
    by definition, A' simulates A when A queries for only one message i
    when A successfully outputs a forgery of message (j, σ), j > i, f^j(σ) = f^i(y)
    f^(j-i)(σ) = y, f(f^(j-i-1)(σ)) = y, f^(j-i-1)(σ) is a preimage of y, A' succeeds when A succeeds
    assume f is one-way,
        negl(n) >= ε(n)
    and A can only succeeds with negligible probability
c.  define another signature scheme Π = (Gen, Sign, Vrfy) that:
        Gen:    sample x, x' <- {0,1}^n, compute y = f^n(x) and y' = f^n(x')
                set sk = (x, x'), pk = (y, y'), output (sk, pk)
        Sign:   on input (sk, i), i ∈ {1 .. n}, compute σ = f^(n-i)(x) and σ' = f^i(x')
                output (σ, σ')
        Vrfy:   on input (i, (σ, σ')), compare y = f^i(σ) and y' = f^(n-i)(σ')
                output 1 if both equation holds; 0 otherwise
    by the same argument in part b (one in reverse)
    given a signature on i, no PPT adversary can output a forgery on any message j > i or j < i with >= negl(n) chance
    therefore Π is a one-time signature scheme

12.7
an adversary A can:
    query 1^l(n), get x1,1 .. xl,1
    query 0^l(n), get x0,0 .. xl,0
by Construction 12.7, A recovered the whole secret key sk and can sign any message now

12.8
assume some adversary A can forge a signature of this scheme with probability ε(n):
    Pr[Sign-forge1(A, Π, n) = 1] = ε(n)
define another A' inverting the one-way function f that:
    run A as a subroutine
    on input (1^n, y), sample i* <- {1 .. 2l}
    for all i != i*, sampe xi <- {0,1}^n, compute yi = f(xi)
    set pk = (y1 .. y2l), pass pk to A
    when A queries a message m':
        if the corresponding subset Sm' contains i*, halt
        otherwise return the correct signature σ' = {xi}, i ∈ Sm'
    when A outputs (m, σ), σ = {xi}, i ∈ Sm
        if i* ∈ Sm, output xi* from σ
when A outputs a forgery (m, σ), m != m', Sm != Sm', there must be some i that i ∈ Sm and i ∉ Sm'
again i* is independent to this i, thereby
    Pr[i* = i] = 1/2l
by definition, when i* ∉ Sm' and A' correctly simulates A in this case
when A succeeds, for all i ∈ σ = Sm, f(xi) = yi, if i* ∈ Sm, f(xi*) = yi* = y, xi* is a preimage of y, A' succeeds too
by one-wayness of f:
    negl(n) >= Pr[Invert(A', f, n) = 1] >= Pr[Sign-forge1(A, Π, n) = 1 ∧ i = i*]
            = Pr[Sign-forge1(A, Π, n) = 1] * Pr[i* = i]
            = ε(n) * 1/2l
for Π to be efficient, l must be polynomial, therefore ε(n) is negligible and Π is a one-time signature scheme
for the mapping from m to Sm be one-to-one
the number of subsets of {1 .. 2l} of size l should be greater or equal to the number of strings of length l'
    C(2l, l) >= 2^l'

12.9
a.  for a signature scheme Π = (Gen, Sign, Vrfy) and a PPT adversary A, define experiment Strong-Sign-forge1(A, Π, n) as:
        run (pk, sk) <- Gen(1^n)
        adversary A is given pk and can ask a single query m' to oracle Sign(sk, _), get σ' = Sign(sk, m')
        A outputs (m, σ), the output of the experiment is defined as 1 iff
            Vrfy(pk, m, σ) = 1, (m, σ) != (m', σ')
    a signature scheme Π is a strong one-time signature scheme if for all PPT adversary A:
        Pr[Strong-Sign-forge1(A, Π, n) = 1] <= negl(n)
b.  let g(x1, x2) = f(x1), |x1| = |x2|
    by problem 6.5, given f being a one-way function, g is a one-way function too
    let Π = (Gen, Sign, Vrfy) be Lamport's scheme with one-way function g
    define an adversary A attacking Strong-Sign-forge(A, Π, n) that:
        on input pk, sample random m <- {0,1}^l, query for σ = Sign(sk, m) = (x1,m1 .. xl,ml)
        parse (x1, x2) = x1,m1, set x* = x1||~x2
        output (m, σ' = (x*, x2,m2 .. xl,ml))
    by definition, σ != σ' and for all i ∈ {1 .. l},
        for i = 1, g(x*) = g(x1, ~x2) = f(x1) = g(x1, x2) = y1,m1
        for i = 2 .. l, f(xi,mi) = yi,mi naturally
    Vrfy(pk, m, σ') = 1, A breaks Π in this experiment with certainty
c.  use a collision-resistant hash function instead a one-way function in Lamport's scheme
    by Section 4.6.2, any collision-resistant hash function is automatically one-way
    thereby for any PPT adversary A, the probability that A outputs a forgery with a fresh message is negligible 
    when A outputs (m, σ) after querying for m and get σ' = Sign(sk, m)
    for (m, σ) to be a forgery, σ != σ' and A must have found a collision for some yi,mi
    another A' running A can then output this collision and succeeds in experiment Hash-coll(A', Π, n)
    formally, given Πh = (Genh, f) be a collision-resistant hash function
    define Π = (Gen, Sign, Vrfy) be the Lamport's scheme using Πh in place of the one-way function
    (Π has to run s <- Genh(1^n) and include s in both pk and sk)
    assume some adversary A attacking Strong-Sign-forge1(A, Π, n) and:
        Pr[Strong-Sign-forge1(A, Π, n) = 1] = ε(n)
    define another A' attacking Hash-coll(A', Πh, n) that:
        run A as a subroutine
        on input (1^n, s), simulate Gen with s, get (pk, sk), pass pk to A
        when A queries for a message m, calculate σ = Sign(sk, m), pass σ to A
        when A finally outputs a pair (m', σ'):
            if m != m', halt
            if m = m', let σ = x1,m1 .. xl,ml, σ' = x'1,m1 .. x'l,ml
                find some i that xi,mi != x'i,mi, output this pair
    when A successfully outputs a forgery (m', σ') that m' = m and σ' != σ, there must be some i that:
        xi,mi != x'i,mi
        f(xi,mi) = f(x'i,mi) = yi,mi
    and A' succeeds in finding a collision
    assume Πh is collision-resistant:
        negl(n) >= Pr[Hash-coll(A', Πh, n) = 1] >= Pr[Strong-Sign-forge1(A, Π, n) = 1 | m = m']
                >= Pr[Strong-Sign-forge1(A, Π, n) = 1] - Pr[Strong-Sign-forge1(A, Π, n) = 1 | m != m] * Pr[m != m]
                >= ε(n) - negl'(n)
        ε(n) <= negl''(n)
    and Π is a strong one-time signature scheme

12.10
refer 4.10

12.11
the same method is not directly applicable
for a receiving party to verify the signature of the ith message mi, it needs:
    all previously signed messages m1 .. mi-1
    all previously generated public keys pk1 .. pki
    all signatures σ1 .. σi
assume {pki} and {σi} can be computed by using pseudorandom coins
a stateless signer cannot output {mi}, the series of previously signed messages
the tree-based scheme addressed this problem and is proved secure in Section 12.6.2

12.12
let G be a pseudorandom function, define F be a pseudorandom function that:
    F(k1||k2, x) = G(k1, x)||G(k2, x)
by problem 6.16, F is also a pseudorandom function 
let Π = (Gen, Sign, Vrfy) be the stateless tree-based signature scheme described in Section 12.6.2
let F above be the pseudorandom function in Π
let Π' = (Gen', Sign', Vrfy') be the stateful tree-based signature corresponding to Π
the only differences between Π and Π' is:
    compared to Gen', Gen generates two more key k, k' for the pseudorandom function F
    (F(k||k', x) = G(k, x)||G(k', x), F generates two random tapes at once)
    Π then uses pseudorandom tapes generated by F where Π' uses real random coins
assume some adversary A attacking Sign-forge(A, Π, n) and:
    Pr[Sign-forge(A, Π, n) = 1] = ε(n)
by Theorem 12.13, Π' is a secure signature scheme and
    Pr[Sign-forge(A, Π', n) = 1] <= negl(n)
define a distinguisher D with oracle access to a function f that:
    run A as a subroutine
    simulates the experiment Sign-forge(A, Π, n)
    when random tapes are needed by Gen and Sign, query f(w)
    if A finally outputs a forgery, output 1; otherwise output 0
when f <- Func is a true random function, A' indeed simulates Sign-forge(A, Π', n) and
    Pr[A'(f) = 1] = Pr[Sign-forge(A, Π', n) = 1] <= negl(n)
when f(w) = F(k1||k2, w), A' simulates Sign-forge(A, Π, n) and
    Pr[A'(Fk) = 1] = Pr[Sign-forge(A, Π, n) = 1] = ε(n)
by pseudorandomness of F:
    |Pr[A'(f) = 1] - Pr[A'(Fk) = 1]|    = |ε(n) - negl(n)| <= negl'(n)
ε(n) must be negligible and Π is a secure signature scheme

12.13
by the security of underlying signature schemes, only people possessing skB can sign such a message in respect to pkB
then there are two possibilities:
    it's issued by Bob and the CA should do as Bob asked
    it's issued by someone other than Bob, which means Bob's secret key is stolen, CA should revoke the key
either case the correct thing to do is to revoke Bob's public key