Chapter 1 
1.1
JGRMQOYGHMVBJWRWQFPWHGFFDQGFPFZRKBEEBJIZQQOCIBZKLFAFGQVFZFWWE
OGWOPFGFHWOLPHLRLOLFDMFGQWBLWBWQOLKFWBYLBLYLFSFLJGRMQBOLWJVFP
FWQVHQWFFPQOQVFPQOCFPOGFWFJIGFQVHLHLROQVFGWJVFPFOLFHGQVQVFILE
OGQILHQFQGIQVVOSFAFGBWQVHQWIJVWJVFPFWHGFIWIHZZRQGBABHZQOCGFHX
QVF -> the
cryptographicsystemsareextremelydifficulttobuildneverthelessf
orsomereasonmanynonexpertsinsistondesigningnewencryptionschem
esthatseemtothemtobemoresecurethananyotherschemeonearththeunf
ortunatetruthhoweveristhatsuchschemesareusuallytrivialtobreak

1.2
mono-alphabetic:
    Gen: gives a random bijection f: Z26 -> Z26
    Enc: a homomorphism (Z26)* -> (Z26)* based on f 
    Dec: a homomorphism (Z26)* -> (Z26)* based on the inversion of f
Vigenere:
    Gen: gives a random string in (Z26)*
    Enc: a length preserving function (Z26)* -> (Z26)* that for input w = w1w2...wn and key k:
         output is x = x1x2...xn that
         xi = (wi + k[i mod |k|]) mod 26
    Dec: the same as Enc except
         xi = (wi - k[i mod |k|]) mod 26

1.3
characters in position i, i+t, i+2t is in a mono-alphabetic permutation, and t can be tested with statistics
then the problem reduces to breaking t mono-alphabetic permutation

1.4
a.  substract ki + j modulo 26
b.  the repeating bi or trigram is 26 times less frequent
    since they have to occur in the (modulo 26) same position in the key and jth block
    requires longer ciphertext to determine the period
c.  since the encryption method is open
    substract j for characters in jth block modulo 26 and it's now an ordinary Vigenere cipher

1.5
shift:  all it needed is a single character to calculate the shift
substitution:   a segment containing all 26 characters then the permutation is known
Vigenere:   any text with length at least t, then the key can be calculated

1.6
shift:  a single character
substitution:   a string of length 25, "ab..y"
Vigenere:   a length t string of repeating "a", when t unknown just any reasonable length < 100

Chapter 2 
2.1
if Π = (Gen, Enc, Dec) is perfectly secret
    Pr[M = m | C = c] = Pr[M = m]
    Pr[M = m ∧ C = c] / Pr[C = c] = Pr[M = m]
multiply both sides with Pr[C = c] / Pr[M = m]
    Pr[M = m ∧ C = c] / Pr[M = m] = Pr[C = c]
    Pr[C = c | M = m] = Pr[C = c]

2.2
by perfect secrecy
    Pr[M = m | C = c] = Pr[M = m]
    Pr[M = m' | C = c] = Pr[M = m']
so if Pr [M = m | C = c] = Pr[M = m' | C = c], then
    Pr[M = m] = Pr[M = m']
what only holds if the distribution over M is uniform, so refute

2.3
by outruling k = 0^l, |K| = |M| - 1 < |M|, so this encryption is no longer perfectly secret
first, it's a very low possibility of choosing k = 0^l, namely 1/2^l
second, for all possible m ∈ M and c ∈ C, there exists a key encrypts m to c
that means any meaningful sentence can be the ciphertext of any other plaintext
an adversary seeing some meaningful ciphertext cannot tell the difference between:
    1. the key is 0^l
    2. the plaintext is encrypted to meaningful ciphertext by chance
the probability of the two event are roughly the same

2.4
a.  |C| = |M| = |K| = 26, and for any character x and any cipher character y, there exists a unique key that:
        x + k ≡ y (mod 26)
    so by Shannon's theorem, if k is chosen uniformly from Z26 this encryption method is perfectly secret
b.  let M = strings of length 26 with non-repeating characters
    then |M| = |K| = 26!
    also |C| = |M| = 26!, in fact C = M
    for any c ∈ C and m ∈ M, define a function k that maps every character in m to every character in c in order
    then k is an bijection Z26 -> Z26, k ∈ K, Enc(k, m) = c
    by Shannon's theorem, if k is chosen uniformly from K, then this encryption is perfectly secret
    since |K| >= |M| for any perfectly secret encryption, this is the biggest |M| possible
c.  for M = {w | w is a word of length t}, |M| = |K| = t^26 
    since Vigenere cipher is length preserving, and for any string c of length t 
        Enc(c, a^26) = c
    so C = M and |C| = |M| = |K|
    also for any c, m ∈ C = M, define k = k1k2..kt that
        ki = (ci - mi) mod 26
    then Enc(k, m) = c
    by Shannon's theorem, if k is chosen uniformly from K, then this cipher is perfectly secret
all attacks in Chapter 1 relies on some form of statistics, which is infeasible with so small data
only exception be the exhausting search for shift cipher, which doesn't make sense with only one character

2.5
refute. Modify shift cipher with a message space of one character strings that 
    discard generated key and always shift the plaintext by 3
then
    Pr[C = d | M = a] = 1
    Pr[C = e | M = a] = 0 != 1
so this cipher is not perfectly secret, but it meets all requirements the problem states 

2.6
thanks https://cstheory.stackexchange.com/questions/11476#answer-11479
try doing it in some different setup
let M' = {m | Pr[M = m] > 0}, N = M - M', define a new distribution Pr' that
    Pr'[M = m] = Pr[M = m] / 2 for m ∈ M'
    Pr'[M = m] = some arbitrary non-zero real number for m ∈ N and make
    ∑m∈N Pr'[M = m] = 1/2
then ∑m∈M Pr'[M = m] = 1 is a proper distribution
and since Pr' assigns non-zero probability to all m, the scheme under Pr' is perfectly secret
for m ∈ M',
    Pr'[M = m, C = c]   = Pr'[C = c | M = m] * Pr'[M = m]
when m fixed, the probability Pr'[C = c | M = m] only affected by the randomness of Gen and Enc, not Pr or Pr' so
    Pr'[C = c | M = m] = Pr[C = c | M = m]
and
    Pr'[C = c | M = m] * Pr'[M = m] = Pr[C = c | M = m] * Pr[M = m] / 2
                                    = Pr[M = m, C = c] / 2
while ∑m∈N Pr'[C = c, M = m]    = ∑m∈N Pr'[C = c | M = m] * Pr'[M = m]
                                = ∑m∈N Pr'[C = c] * Pr'[M = m]  // by perfect secrecy
                                = Pr'[C = c](∑m∈N Pr'[M = m])
                                = Pr'[C = c] / 2
combined with Pr'[C = c] = ∑m∈M Pr'[C = c, M = m] and M = M' + N, it makes
    ∑m∈M' Pr'[C = c, M = m] = Pr'[C = c] - ∑m∈N Pr'[C = c, M = m]
                            = Pr'[C = c] / 2
that means
    Pr'[C = c] / 2  = ∑m∈M' Pr'[C = c, M = m]
                    = ∑m∈M' Pr[M = m, C = c] / 2
                    = Pr[C = c] / 2
so the distribution of ciphertext is the same with either Pr or Pr' and for m ∈ M':
Pr[M = m | C = c]   = Pr[M = m, C = c] / Pr[C = c]
                    = 2Pr'[M = m, C = c] / Pr'[C = c]
                    = 2Pr'[M = m | C = c]
                    = 2Pr'[M = m]   // by perfect secrecy
                    = 2 * Pr[M = m] / 2
                    = Pr[M = m]
for m ∈ N, Pr[M = m | C = c] = Pr[M = m] = 0
so the encryption scheme is still perfectly secret with some m assigned zero probability
for any M' ⊂ M, define Pr[M = m] = 0 for m ∈ M - M' then the distribution has been extended to M
for all m ∈ M, perfect secrecy holds

2.7
Since perfect secrecy is true for all distribution, it is also true for a distribution that
    Pr[M = m0] = Pr[M = m1] = 1/2
and a message space M = {m0, m1}
then Pr[C = c | M = m0] = Pr[C = c | M = m1]
no matter what m0, m1 the adversary has chosen, the ciphertext is totally indifferent to the adversary

2.8
if Π is not a scheme of perfect secrecy, then for some message m0, m1 and some ciphertext c:
    Pr[C = c | M = m0] != Pr[C = c | M = m1]
assume Pr[C = c | M = m0] > Pr[C = c | M = m1] (otherwise symmetric)
then
    Pr[C = c, M = m0] / Pr[M = m0] > Pr[C = c, M = m1] / Pr[M = m1]
if Pr[C = c] = 0, Pr[C = c | M = m0] = Pr[C = c | M = m1] = 0, so Pr[C = c] != 0
since Pr[M = m0] = Pr[M = m1] = 1/2, multiply both sides with Pr[C = c] / 2:
    Pr[C = c, M = m0] / Pr[C = c] > Pr[C = c, M = m1] / Pr[C = c]
    Pr[M = m0 | C = c] > Pr[M = m1 | C = c]
as M = {m0, m1}, Pr[M = m0 | C = c] + Pr[M = m1 | C = c] = 1, which means
    Pr[M = m0 | C = c] > 1/2
let the adversary outputs m0 and m1 at step 1
at step 3, if the ciphertext is c, A outputs 0, otherwise A outputs either 0 or 1 with equal probability
    Pr[PrivK(eav, A, Π) = 1]    = Pr[b' = b]
                                = Pr[b' = b | C = c] * Pr[C = c] + Pr[b' = b | C != c] * Pr[C != c]
obviously Pr[b' = b | C != c] = 1/2, as b' is chosen randomly that case
since A outputs 0 when C = c,
    Pr[b' = b | C = c]  = Pr[b = 0 | C = c]
                        = Pr[M = m0 | C = c]
                        > 1/2
    Pr[PrivK(eav, A, Π) = 1]    = Pr[b' = b | C = c] * Pr[C = c] + (1/2) * Pr[C != c]
                                = 1/2 + (Pr[b' = b | C = c] - 1/2) * Pr[C = c]
since Pr[b' = b | C = c] > 1/2, Pr[C = c] > 0, Pr[PrivK(env, A, Π) = 1] > 1/2

2.9
when m != m', c = c', Pr[C = c] > 0, Pr[M = m] > 0, Pr[M' = m'] > 0
Pr[C = c, C' = c'] = Pr[C = c]^2 > 0, Pr[M = m, M' = m'] = Pr[M = m] * Pr[M' = m'] > 0
but Pr[M = m, M' = m' | C = c = C'] = 0
otherwise the encryption scheme encrypts two different plaintext to the same ciphertext with the same key
that makes effective decryption impossible

2.10
use mono-alphabetic cipher on the message space of a single character
then the key is effectively a bijection k: Z26 -> Z26,
    Gen = choose such a bijection from all |K| = 26! bijections
    Enc(k, m) = k(m)
    Dec(k, m) = k^-1(m)
    M = C = Z26
then 
    Pr[M = m, M' = m' | M != M']    = Pr[M = m, M' = m', M != M'] / Pr[M != M']
                                    = Pr[M = m, M' = m'] / Pr[M != M']  // M != M' is trivial when m != m'
    Pr[M = m, M' = m' | C = c, C' = c'] = Pr[M = m, M' = m', C = c, C' = c'] / Pr[C = c, C' = c']

2.11
since Gen needs no input except the uniformly chosen random tape r, k <- Gen outputs k ∈ K with a probability p(k)
make d_Gen the deterministic algorithm that take a random tape r as the input and outputs a k ∈ K
now define a new encryption scheme with key generating algorithm Gen' that take a random tape r and output it directly
    R <- Gen'
the new encryption algorithm Enc'(r, m) = Enc(d_Gen(r), m) to encrypt the message, Dec' similarly defined
now Gen' is uniformly distributed, and Pr[d_Gen(R) = k] = Pr[K = k] since it's the definition of K
Pr[C = c | M = m] is only determined by the randomness of key thus unchanged for the new scheme
so Pr[C = c | M = m0] = Pr[C = c | M = m1] ∀m0, m1 ∈ M, the new scheme is still perfectly secret
and the new encryption scheme has a uniformly distributed key space now

2.12
consider a message space {0, 1} and t = 1
the key space is empty: Gen outputs nothing, or identically Gen always outputs the same k which is unused
Enc discards the input and randomly output 0 or 1
Dec discards the input and randomly output 0 or 1
then Pr[M = m | C = c] = Pr[M = m], since ciphertext is totally independent to the message 
also Pr[Enc(Dec(m))] = Pr[Enc = m] = 1/2
the lower bound of |K| maybe |M| / 2^t

2.13
consider a message space M that follows uniform distribution
for a fixed c, M(c) <= |K|
assume |K| < |M| * (1 - ε), then for more than ε|M| messages c may not decrypt to them
since ∑m∈M(c) Pr[M = m | C = c] = 1, there exists at least one m0 such that 
    Pr[M = m0 | C = c]  >= 1 / |M(c)|
                        >= 1 / |K|
                        > 1 / (1 - ε)|M|
where Pr[M = m0] = 1 / |M|, so
    Pr[M = m0 | C = c] - Pr[M = m0] > 1 / (1 - ε)|M| - 1 / |M|
                                    = ε / (1 - ε)|M|
also for some m1 ∉ M(c):
    Pr[M = m0] - Pr[M = m1 | C = c] = Pr[M = m0]
                                    = 1 / |M|
take |M| = 2, for the scheme to be almost perfectly secret with a margin ε, it must has 
    ε > 1 / 2
but also
    ε / 2(1 - ε) < ε
    1 / 2(1 - ε) < 1
    (1 - ε) > 1/2
which is not possible, so |K| must >= |M| * (1 - ε)

Chapter 3
3.1
a.  if negl1 and negl2 are negligible functions, then for some n1 and n2:
        for any polynomial p, negl1(n) < 1/p(n) and negl2(n) < negl2(n) for n >= max(n1, n2)
    let negl3(n) = negl1(n) + negl2(n)
    for any polynomial p and n >= max(n1, n2):
        negl3(n)    < 1/(2 * p(n)) + 1/(2 * p(n))  // since 2 * p(n) still a polynomial
                    = 1/p(n)
    so negl3 is negligible
b.  for negl4(n) = p(n) * negl1(n) and any polynomial q:
        negl4(n)    < p(n) / p(n)q(n)   // since p(n)q(n) still a polynomial
                    = 1 / q(n) for n >= n1

3.2
n > 3767.76

3.3
for a random plaintext m chosen from {0,1}^n, Pr[|Enc(m)| <= n - i] <= 1/2^(i-1)
since Dec is deterministic and there are 2^(n-i+1) - 1 strings in {0,1}^(n-i), at most
    2^(n-i+1) - 1 / 2^n < 1/2^(i-1)
fraction of strings in {0,1}^n can ever be encrypted to a shorter ciphertext, or Dec(Enc(m)) != m for some |m| = n
the encryption scheme is assumed to be efficient, so there is a polynomial upper bound q that
    |Enc(m)| <= q(|m|+|k|)
both |k| = n, |m| and the encryption method are known to the adversary, so q(|k|+|m|) can be computed efficiently
let A outputs two message, m0 ∈ {0, 1} and m1 uniformly sampled from {0, 1}^(q(n+1) + 2)
A output 0 if the ciphertext c has length |c| <= q(n+1) and 1 otherwise
then
    Pr[PrivKeav(A, Π) = 1]  = Pr[b' = b]
                            = Pr[b' = b | b = 0] / 2 + Pr[b' = b | b = 1] / 2
when m0 is encrypted, |c| <= q(n+1) and A will output 0, makes b' = b 
when m1 is encrypted, Pr[|Enc(m1)| <= q(n+1)] <= 1/2 by the previous argument
    Pr[b' = b | b = 1] = Pr[|Enc(m1)| > q(n+1)] > 1/2
    Pr[PrivKeav(A, Π) = 1]  > 1/2 + (1/2)/2
                            = 3/4
so Definition 3.8 cannot be satisfied

3.4
define Π = (Gen, Enc, Dec) that
    Gen: uniformly sample k from {0, 1}^n on input 1^n
    Enc: for input m,
        pad m to length l(n) with leading 0s
        prepend b(|m|), the binary presentation of |m|, also padded to |b(l(n))| with leading 0s
        encrypt m' defined above with k and a legit stream cipher
    Dec: for input c,
        decrypt c with k to m'
        read first |b(l(n))| bit to get the length of the real message
        truncate m' to the specified length to recover m
then an experiment in this encryption scheme is more powerful than an experiment in the stream cipher
since for any m0, m1 outputted by A, m0', m1' are of the same length
and if A may succeed with m0 and m1 in this scheme with non-negligible probability
A also may succeed with m0' and m1' in the stream cipher, thus contradicts with the assumption

3.5
Pr[PrivKeav(A, Π, n) = 1]   = Pr[output(PrivKeav(A, Π, n, b)) = b]
                            = Pr[output(PrivKeav(A, Π, n, b)) = b | b = 0] * Pr[b = 0] +
                              Pr[output(PrivKeav(A, Π, n, b)) = b | b = 1] * Pr[b = 1]
                            = Pr[output(PrivKeav(A, Π, n, 0)) = 0] * 1/2 +
                              Pr[output(PrivKeav(A, Π, n, 1)) = 1] * 1/2
                            = (1/2) * (1 - Pr[output(PrivKeav(A, Π, n, 0)) = 1] + Pr[output(PrivKeav(A, Π, n, 1)) = 1])
                            = 1/2 + (Pr[output(PrivKeav(A, Π, n, 1)) = 1] - Pr[output(PrivKeav(A, Π, n, 0)) = 1])
                            = 1/2 + (Pr[output(PrivKeav(A, Π, n, 1)) = 1] - Pr[output(PrivKeav(A, Π, n, 0)) = 1])
shorthands: Priv(A, n) and Priv(A, n, b)
1.  if Pr[output(Priv(A, n, 1)) = 1] - Pr[output(Priv(A, n, 0)) = 1] = f(n) for some positive non-negligible function f,
    Pr[Priv(A, n) = 1] = 1/2 + f(n) and Π is not indistinguishable
2.  if Pr[output(Priv(A, n, 0)) = 1] - Pr[output(Priv(A, n, 0)) = 1] = f(n) for some positive non-negligible function f,
    define A' that outputs 1 when A outputs 0 and vice versa
    then Pr[Priv(A', n, 0) = 1] = Pr[Priv(A, n, 0) = 0] = 1 - Pr[Priv(A, n, 0) = 1]
    Pr[output(Priv(A', n, 1)) = 1] - Pr[output(Priv(A', n, 0)) = 1] = f(n)
    Pr[Priv(A', n) = 1] = 1/2 + f(n), Π is not indistinguishable
since |Pr[output(Priv(A, n, 0)) = 1] - Pr[output(Priv(A, n, 1)) = 1]| = f(n) implies 1 or 2, Def 3.8 => Def 3.9
reversely, if Pr[Priv(A, n) = 1] = 1/2 + f(n) for some non-negligible function f,
Pr[output(Priv(A, n, 1)) = 1] - Pr[output(Priv(A, n, 0)) = 1] = f(n)
so Def 3.9 => Def 3.8

3.6
a.  if there is a distinguisher D can distinguish r from G'(s) with non-negligible probability,
    it can also tell the difference between r and G(s') when the s' = s0^|s| for some s
    but Pr[s' = s0^|s|] = 1/2^(|s|/2) and such case is itself negligible
    so G can still be a proper pseudorandom generator even though G' is not
b.  if there is a distinguisher D can tell the difference between r and G'(s) with non-negligible probability,
        |Pr[D(r) = 1] - Pr[D(G'(s)) = 1]| = f(n), s uniformly picked from {0, 1}^n
        |Pr[D(r) = 1] - Pr[D(G(s')) = 1]| = f(n), s' = s1..sn/2
    so equivalently s' is uniformly picked from {0, 1}^(n/2), and D is a distinguisher for G as well
    thus indistinguishability of G implies indistinguishability of G'

3.7
define Π = (Gen, Enc, Dec) identical to construction 3.24 except:
    1.  it prepends F(k, k) to every ciphertext
    2.  Enc(F(k, k)) = k, Dec(k) = F(k, k) as special cases
        not ambiguous since Enc(F(k, k)) will be the only ciphertext of length n (2n otherwise)
    3.  otherwise Dec(c) strips the first n bits from the ciphertext and decrypts the remaining as construction 3.24
since F is a pseudorandom function, it's polynomial time indistinguishable from a random function f <- Func(n)
F(k, k) appearently is just some random string from {0, 1}^n, not predictable from the encryption scheme without the key
an adversary in a multiple-message experiment have to prepare sequences of messages before receiving any ciphertext
it may send F(k, k) as one of the messages by chance, but not with non-negligible probability (by name, 1/2^n)
however a adversary with an encryption oracle can take the first n bits from any previous ciphertext and get F(k, k)
and query the oracle with F(k, k) to get k, the only hidden part in the encryption scheme

3.8
F(m) = F(k, m) maps strings in {0, 1}^d -> {0, 1}^d, where d = O(log(n)) and |k| = O(p(n)) for some polynomial p
as 3.6.1, strings of length d * 2^d are in one-to-one correspondence with functions in Func(d)
d = O(log(n)) => d * 2^d    = O(log(n)) * 2^O(log(n))
                            < c1(log(n)) * 2^c2(log(n))
                            = c1(log(n)) * n^c2
                            = O(n^c2log(n)) for some c2
so the key required to build a truely random function in Func(d) has length polynomial in n
and the scheme permits a key of polynomial length, thus permits truely random functions

3.9
Given a pseudorandom function F that requires a key k of length n, for any polynomial l:
    uniformly sample a random string s ∈ {0, 1}^n
    uniformly sample another random string ctr ∈ {0, 1}^n, regard ctr as a number in binary
    for i from 0 to l(n) / n, compute F(s, (ctr + i) mod 2^n)
    a single F(s, ctr') have length n, combined has length l(n) in total
    concatenate and truncate the result to get G(s, 1^l(|s|))
if F is a pseudorandom function, from the perspect of a polynomial time adversary:
    F(s, ctr + i) and F(s, ctr + j) for any different i, j should be totally random and independent
since l is a polynomial, l(n) / n < 2^n, all (ctr+i) mod 2^n will be pairwise different
if a distinguisher D can distinguish r from G(s, 1^|r|) for |r| = l(|s|),
    |Pr[D(r) = 1] - Pr[D(Gl(s)) = 1]| = ε(n) 
where ε is non-negligible and s <- {0, 1}^n, r <- {0, 1}^l(n)
then another distinguisher D' can distinguish Fk from f <- Func(n), constructed as:
    uniformly sample a random string ctr ∈ {0, 1}^n
    query O(ctr + i) for i = 0 to l(n) / n
    concatenate the result and feed it to D, output 1 if D outputs 1, vice versa
if the oracle of D' is f <- Func(n), then O(ctr), O(ctr+1), .., O(ctr + l(n) / n) is equivalent to r <- {0, 1}^l(n)
    Pr[D'(f, n) = 1] = Pr[D(r) = 1]
if the given oracle is F(s) = F(k, s), then D' is equivalent to G and
    Pr[D'(Fk, n) = 1] = Pr[D(G(k)) = 1], k <- {0, 1}^n
that means
    |Pr[D'(f, n) = 1] - Pr[D'(Fk, n) = 1]| = ε(n)
so by contradiction, such a distinguisher D cannot exist, G is a variable-length pseudorandom generator

3.10
define a distinguisher D as:
    query O(0^n), get c1
    query O(1^n), get c2
    if c1 = ~c2, output 1; otherwise output 0
for any Fk, G'(k) is fixed and 
    G'(k) xor 0^n = G'(k)
    G'(k) xor 1^n = ~G'(k)
so D will always output 1, Pr[D(Fk, n) = 1] = 1
for f <- Func(n), f(1^n) and f(0^n) are independent strings in {0, 1}^n
so Pr[D(f, n) = 1] = Pr[f(0^n) = ~f(1^n)] = 1/2^n
|Pr[D(Fk, n) = 1] - Pr[D(f, n) = 1]| = 1 - 1/2^n is non-negligible, F is not pseudorandom

3.11
for a pseudorandom permutation F and a random permutation f <- Perm(n)
for any polynomial time distinguisher D, there exists a negligible function ε that
    |Pr[D(f, n) = 1] - Pr[D(Fk, n) = 1]| <= ε1(n)
the only way to distinguish a random permutation and a random function is to find some x, y that f(x) = f(y)
but for q different queries, the probability of finding such x and y is:
    coll(q, |{0,1}^n|) <= q^2 / 2^(n+1)
when q is polynomial, this probability is negligible, that means for any polynomial time distinguisher D:
    |Pr[D(f, n) = 1] - Pr[D(g, n) = 1]| <= ε2(n)
where f <- Func(n), g <- Perm(n), ε2 is a negligible function
thus f, g sampled as above:
    |Pr[D(f, n) = 1] - Pr[D(Fk, n) = 1]|    <= |Pr[D(f,n) = 1] - Pr[D(g,n) = 1]| + |Pr[D(g,n) = 1] - Pr[D(Fk,n) = 1]|
                                            <= ε1(n) + ε2(n), which is negligible
so Fk is also indistinguishable from a random function, Fk is a pesudorandom function

3.12
a encryption scheme Π = (Gen, Enc, Dec) has perfect CPA secrecy if for any adversary with unlimited computation power:
    Pr[PrivK(A, Π, n) = 1] = 1/2
while A has access to an oracle Enck, so this condition is stronger than normal perfect secrecy
construct an adversary that
    1. output two messages m0 = 0^n and m1 = 1^n
    2. on receiving the challenge ciphertext c, encrypt m0 with the oracle once and compare the result to c
    3. if the query in step 2 results c, output 0; otherwise output 1
assume b = 1:
    since the key is fixed in the experiment, 
    result of step 2 cannot be c or m0, m1 encrypts to the same ciphertext with the same key
    so A always successfully output b' = b = 1, Pr[b' = 1 | b = 1] = 1
assume b = 0:
    the challenge ciphertext and the oracle query is encrypted independently
    with probability Pr[C = c | M = m0]^2 = Pr[C = c]^2 (by normal perfect secrecy) they will be the same ciphertext
    as c is given as the challenge ciphertext, Pr[C = c] > 0 => Pr[b' = 0 | b = 0] = Pr[C = c]^2 > 0 
accordingly:
    Pr[PrivK(A, Π, n) = 1]  = Pr[b' = b]
                            = Pr[b' = 0 | b = 0] * Pr[b = 0] + Pr[b' = 1 | b = 1] * Pr[b = 1]
                            = Pr[b' = 0 | b = 0] / 2 + 1/2
                            > 1/2
thus no encryption scheme can be perfectly CPA secret

3.13
let F be a pseudorandom permutation, define F' to be
    F'(k, k) = 0^|k|
    F'(k, F^-1(0^|k|)) = F(k, k)
    F'(k, m) = F(k, m) otherwise
then F' is still a permutation as F' just swapped the corresponding value between k and F^-1(0^|k|)
if F is indistinguishable, so is F'
because F' and F only differ at 2/2^n unknown fraction of their domain (both k and F^(0^|k|) unknown to some D)
that makes F and F' indistinguishable in polynomial time
by the transitivity of indistinguishability (in problem 3.11), F' and a random permutation are indistinguishable
but with oracle access of F'^-1, the key can be easily got by F'k^-1(0^|k|) = k
with the key, compare the oracle O(m) with F(k, m) for some input m
F' and f <- Perm(n) are distinguishable with probability 1 - ε(n) for some negligible ε

3.14
Dec: compute F^-1(k, c) and take the last n/2 bits
define an alternative scheme Π' by replacing Fk with a random permutation f
in scheme Π', f(rm) for any m is totally random, and for an adversary A that querys the oracle g(n) times:
a.  if no query result equals to the challenge ciphertext, D gained no information about f^-1(c), A can only guess
b.  if any query O(m) = c, m is the plaintext been encrypted in the experiment, A then compare it to m0 and m1 for b'
    this only happens when m = mb and the two encryption used the same r, with probability p(n) <= 1/2^|r| = 1/2^(n-1)
accordingly, 
    Pr[PrivK(A, Π', n) = 1] <= Pr[b' = b | no O(m) = c] * (1 - p(n)) + Pr[b' = b | some O(m) = c] * p(n)
                            = 1/2 * (1 - p(n)) + 1 * p(n)
                            = 1/2 + p(n) / 2
                            <= 1/2 + 1/2^n
if an adversary can succeed with non-negligible probability with scheme Π, it can distinguish Fk and f
this scheme do not perform the xor operation in construction 3.24, but requires F to be a keyed permutation

3.15
a.  assuming G(k) being a pseudorandom generator, G'(k) = G(k)G(k+1) is not necessarily a pseudorandom generator
    let G be a pseudorandom generator {0, 1}^n -> {0, 1}^l(n), l(n) >= n + 2, define G': {0, 1}^(n+1) -> {0, 1}^l(n):
        G'(s||0) = G(s)
        G'(s||1) = G(s)
    if some D can distinguish G'(s) and r <- {0, 1}^l(n), s <- {0, 1}^n+1
        Pr[D(G'(s)) = 1]    = Pr[D(G'(s)) = 1 | s = s'||0]*Pr[s = s'||0] + Pr[D(G'(s)) = 1 | s = s'||1]*Pr[s = s'||1]
                            = Pr[D(G(s')) = 1] / 2 + Pr[D(G(s')) = 1] / 2
                            = Pr[D(G(s')) = 1] for s' <- {0, 1}^n
        |Pr[D(r) = 1] - Pr[D(G'(s)) = 1]| = |Pr[D(r) = 1] - Pr[D(G'(s')) = 1]|
    D is also a distinguisher of G, by contradiction, D may not exist => G' is a pseudorandom generator
    but for every even s, G'(s) = G'(s + 1)
    if the adversary output m0 = 0^(2n+2), m1 = 0^(n+1)1^(n+1)
    by comparing the first and last half of the ciphertext, it may succeed with probability nearly 3/4
b.  key space is empty, no way to be secure
c.  indistinguishable, for f <- Func(n), f(0^n) is random, makes the scheme analogous to one time pad
    if an adversary can break the scheme, it can distinguish Fk and f
    not CPA-secure, Enc is not probabilistic
d.  analogous to CTR mode of operation, thus CPA-secure

3.16
from the second encryption, the scheme is no longer probabilistic, thus cannot be CPA-secure
namely let the adversary calculate m2 = (IV+1) xor (IV xor m0) and query it, get c', compare c' with c
if mb = m0, c' = c
if mb = m1, c' != c
the adversary can break the scheme with certainty

3.17
ECB:    mi = F^-1(k, ci)
CBC:    m1 = F^-1(k, c1) xor IV
        mi = F^-1(k, ci) xor ci-1
OFB:    m1 = F(k, IV) xor c1
        mi = F(k, IVi-1) xor c1, IVi = F(k, IVi-1)
CTR:    mi = F(k, ctr + i) xor ci
ECB and CTR are fully parallelizable, OFB partially

3.18
if an adversary A can break this scheme, define a distinguisher D that:
    give A 1^n, A outputs m0 and m1
    sample b <- {0, 1}, sample ctr <- {0, 1}^n
    encrypt mb as CTR mode of operation but replace Fk with queries to O with ctr+i
    if A queries Enck, sample a new ctr' <- {0, 1}^n and do the encryption with O(ctr'+i)
    A outputs b'
    outputs 1 if b = b'; 0 otherwise
if O = Fk, A is running PrivK(A, Π, n), Pr[D(n) = 1] = Pr[PrivK(A, Π, n) = 1] = 1/2 + ε(n)
if O = f, A is running PrivK(A, Π', n), Pr[D(n) = 1] = Pr[PrivK(A, Π', n) = 1] <= 1/2 + 2q(n)^2 / 2^n
then |Pr[D(Fk, n) = 1] - Pr[D(f, n) = 1]|   = |ε(n) - 2q(n)^2 / 2^n|
if ε(n) is non-negligible, there is a distinguisher of F, by contradiction Π must be CPA-secure

3.19
a.  for Fk to be a pseudorandom function, 
    Fk should be indistinguishable from a random function f: {0, 1}^lin(n) -> {0, 1}^lout(n) in polynomial time
    again assume the adversary's running time is bounded by a polynomial q
        q(n)/max(lin(n), lout(n)) is an upper bound of the number of queries
        q(n) is an upper bound of the length of any query string
    ctr* <- {0, 1}^lin(n) for the encryption of m0 and m1, ctri <- {0, 1}^lin(n) for ith query to the encryption oracle
    lin(n) may not be logarithm, or 2^lin(n) will be polynomial and for big enough q overlap is guarenteed
        Pr[Overlapi] = (2q(n) - 1) / 2^lin(n)
        Pr[Overlap] <= ∑Pr[Overlapi]
                    = (q(n) / max(lin(n), lout(n))) * (2q(n) - 1) / 2^lin(n)
                    <= 2q(n)^2 / (max(lin(n), lout(n)) * 2^lin(n))
    if Π is CPA-secure, Pr[Overlap] have to be negligible
    thus 1 / (lout(n) * 2^lin(n)) has to be negligible, lin(n) may not be logarithm
    it doesn't matter how small lout(n) is: 
    even lout(n) = 1 it's a totally random bit, can be concatenated to totally random stream assuming no overlap of ctr
b.  for fixed length message of length l(n), for a adversary whose running time is bounded by a polynomial q(n):
        l(n) is an upper bound of the length of any query string 
        q(n) / max(lin(n), l(n)) is an upper bound of the number of queries
    if l(n) / lout(n) >= 2^lin(n), an overlap is guaranteed to happen during a single encryption
    for two choices of ctr1 and ctr2, there is an overlap iff:
        ctr2 - l(n) / lout(n) <= ctr1 <= ctr2 + l(n) / lout(n)
        Pr[Overlapi]    <= 2l(n) / (lout(n) * 2^lin(n))
        Pr[Overlap]     <= (q(n) / max(lin(n), l(n))) * (2l(n) / (lout(n) * 2^lin(n)))   
                        = 2q(n)l(n) / (max(lin(n), l(n)) * lout(n) * 2^lin(n)) 
    if Π is indistinguishable encryption, l(n) / lout(n) < 2^lin(n) for every n > 1
    if Π is CPA-secure, Pr[Overlap] is negligible, lin(n) cannot be logarithm

3.20
a.  if there is a D that distinguishes Fk and f with oracle Fk$ and f$, construct D' as:
        D' runs D as a subroutine
        every time D queries g$:
            sample r <- {0, 1}^n
            query g(r)
            output <r, g(r)> to D
        if D outputs 1, output 1; otherwise output 0
    then 
        Pr[D'(Fk, n) = 1] = Pr[D(Fk$, n) = 1]
        Pr[D'(f, n) = 1] = Pr[D(f$, n) = 1]
        |Pr[D'(Fk, n) = 1] - Pr[D'(f, n) = 1]| = |Pr[D(Fk$, n) = 1] - Pr[D(f$, n) = 1]|
    if D' can distinguish Fk$ and f$, then D can distinguish Fk and f
    if F is a pseudorandom function, F is also a weakly pseudorandom function
b.  F is not pseudorandom, since for any odd seed x
        F(k, x) = F(k, x+1) 
    which only happens with negligible probability for a real random function f
    with a weaker oracle Fk$, the difference is only noticeable when ri = rj + 1 for some ri, rj <- {0, 1}^n
    consider x = x + 1 for odd x, then the problem reduced to the birthday problem and 
        coll(q, N) <= q^2 / 2N <= q^2 / 2^n, q is the total number of queries
    since D is efficient, q is polynomial and coll(q, N) is negligible
    thus F is weakly pseudorandom
c.  consider the weak pseudorandom function F from part b
    F(k, x) = F(k, x+1) for every odd x
    define an adversary A that:
        outputs m0 = 0^2n, m1 = 0^n1^n
        on receiving the challenge ciphertext c, parse c = c1 || c2, compare c1 and c2
        if ctr is odd:
            if c1 = c2, output 0, otherwise 1
        if ctr is even:
            output b <- {0, 1}
    if ctr is odd and b = 0, c1 = F(k, ctr) xor 0^n = F(k, ctr+1) xor 0^n = c2, b' = 0
    if ctr is odd and b = 1, c1 != c2
    if ctr is even, Pr[b' = b] = 1/2
    so A succeeds with probability 3/4, this scheme does not have indistinguishable encryptions
d.  OFB mode with a weak pseudorandom function is CPA-secure, if the message length is fixed as n
    a distinguisher D can 
        sample IV <- {0, 1}^n
        output <IV, F(k, IV) xor m>
    i.e. supply all it needs to break the scheme for some adversary A
    then if A can break the scheme, D can distinguish Fk with the weaker oracle

3.21
define a new scheme Π that:
Gen:    sample k1, k2 <- {0, 1}^n, set k1, k2 as the key for Π1 and Π2, k = <k1, k2>
Enc:    for |m| = n:
        sample r <- {0, 1}^n 
        encrypt m1 = r, m2 = m xor r seperately with Π1 and Π2, get c1 and c2
        (which one encrypted by which scheme doesn't matter)
        output <c1, c2> as the ciphertext 
Dec:    
        on receiving <c1, c2>, decrypt seperately with Π1 and Π2, get m1 and m2
        calculate m = m1 xor m2
an encryption oracle of Enck is equivalent to two encryption oracle Enc1k1 and Enc2k2 combined
if some adversary A1 can break Π1 with an oracle Enc1k1
    Pr[PrivK(A1, Π1, n) = 1] = 1/2 + ε1(n) and ε1 is non-negligible
and Π2 is CPA-secure
if any adversary A can break Π with oracle Enck,
    Pr[PrivK(A, Π, n) = 1] = 1/2 + ε(n) and ε is non-negligible
define an adversary A2 that, with an oracle Enc2k2:
    sample k1 <- {0, 1}^n
    simulate an oracle Enc1k1 and run A to get m0', m1' (Enck equivalent to Enc1k1 and Enc2k2 combined)
    sample r <- {0, 1}^n, define m0 = r xor m0', m1 = r xor m1', output m0 and m1
    on receiving the challenge ciphertext c, give A <Enc1(k1, r), c> and <Enc1(k1, r), Enc2(k2, m0)>
    answer following queries of A as before, until A outputs b'
    outputs b' as well 
if b = 0, c and Enc2(k2, m0) is completely indistinguishable and Pr[b' = b] = 1/2 for any A
if b = 1, A is running in experiment PrivK(A, Π, n), Pr[b' = b] = 1/2 + ε(n)
so Pr[PrivK(A2, Π2, n) = 1] = 1/2 + ε(n)/2, Π2 is not CPA-secure, by contradiction Π is CPA-secure
by a symmetric argument, if Π is not CPA-secure, neither of Π1 nor Π2 can be CPA-secure
so if one of Π1 and Π2 is CPA-secure, Π is CPA-secure

3.22
all of them are block ciphers with plain IV
an adversary can require the decryption of <IV, c1> to get the first n bits of the message mb, thus determine b

Chapter 4
4.1
if t(n) = O(log(n)), there are only 2^t(n) = O(n^c) possible tags
if an adversary outputs (m, t) for random m <- {0,1}^n and t' <- {0,1}^t(n)
    Pr[Mac-forge(A, Π, n) = 1]  = ∑t Pr[Mac(k, m) = t ∧ t = t' | M = m]
                                = ∑t Pr[Mac(k, m) = t | M = m] * Pr[t = t' | M = m] // independent events
                                = ∑t Pr[Mac(k, m) = t | M = m] * Pr[t = t'] // t' independent from m
Pr[t = t'] = 1 / 2^t(n) for any t
∑t Pr[Mac(k, m) = t | M = m] = 1 implies there must be some t that Pr[Mac(k, m) = t | M = m] >= 1 / 2^t(n)
    Pr[Mac-forge(A, Π, n) = 1]  >= 1 / (2^t(n))^2
since 2^t(n) is polynomial, 1 / 2(2^t(n))^2 is non-negligible and Π is not secure

4.2
by authenticate two message m0||m1 and m2||m3, an adversary can get tags of m2||m1 and m0||m3

4.3
can break with exactly the same method in problem 4.2

4.4
a.  for any message m = m0||m1, m0 = m1, |m0| = |m1| = n 
    the computed tag will be F(k, m0) xor F(k, m1) = 0^n
b.  define an adversary that:
        sample m0 <- {0,1}^n
        query m0||m0, get <r, t0>
        define m1 = ~m0 
        output <m1||m1, <r, t0>>
    F(k, r) xor F(k, m0) xor F(k, m0) = F(k, r), so t0 = F(k, r)
    replace m0 with m1 won't change the tag
c.  it's still easy to forge messages that <1>||m0 = <2>||m1
    choose different m0, m1 <- {0,1}^(n/2 - 2) and query for <<1>||m0||01, <2>||m0||10> to recover some F(k, r)
    then the adversary in part b can be reused

4.5
a.  analogous to CCA-security
    define this stronger message authentication experiment Mac-forge-vrfy(A, Π, n) as:
        1.  a random key k is generated by running Gen(1^n)
        2.  the adversary A is given input 1^n and oracle accesses to Mac(k, _) and Vrfy(k, _, _)
            the adversary eventually outputs a pair (m, t)
            let Q denote the set of all messages that A asked to either oracle
        3.  the output of the experiment is defined to be 1 iff Vrfy(m, t) = 1 and m ∉ Q
    A message authentication code Π is secure if for all polynomial-time adversary A there is some negligible function
        Pr[Mac-forge-vrfy(A, Π, n) = 1] <= negl(n)
    a real-world application may be the receiving party acts visibly differently on receiving valid and invalid tags
    like the recent attack on shadowsocks
b.  assume an adversary A with two oracles can break Π with probability ε(n)
    the number of queries it makes to vrfy oracle is bounded by a polynomial q
    define a new adversary A' with access to only Mac oracle that:
        run A as a subroutine 
        pass input 1^n to A
        sample i <- {1 .. q(n)}
        when A queries the Mac oracle, query its own Mac oracle and forward the result to A
        when A queries the Vrfy oracle with (m, t):
            if m is previously queried in Mac oracle and the result is t, return 1 to A
            if m is never queried before and this is the ith query to the vrfy oracle, output (m, t)
            otherwise pass 0 to A
        output whatever A outputs
    define event Vrfy as A will ever query vrfy oracle with a fresh message and get positive answer
    then A' simulates A correctly if i is the first time Vrfy occurs and Π has unique tags
        negl(n) >= Pr[Mac-forge(A', Π, n) = 1] >= Pr[Vrfy] / q(n)
        Pr[Vrfy] <= q(n) / negl(n)
    if Vrfy never happens, either A never queries vrfy oracle or all such queries have result 0
    define another adversary A* that:
        run A as a subroutine
        pass 1^n to A
        when A queries the Mac oracle, query its own Mac oracle and forward the result to A
        when A queries the vrfy oracle with (m, t):
            if m is previously queried in Mac oracle and the result is t, return 1 to A
            otherwise return 0
        output whatever A outputs
    again
        negl(n) >= Pr[Mac-forge(A*, Π, n) = 1]  >= Pr[Mac-forge-vrfy(A, Π, n) = 1 ∧ ¬Vrfy]
        Pr[Mac-forge-vrfy(A, Π, n) = 1] <= Pr[Vrfy] + Pr[Mac-forge-vrfy(A, Π, n) = 1 ∧ ¬Vrfy]
                                        <= q(n) / negl1(n) + negl2(n)
    thus security and unique tags implies this stronger definition of security
c.  thanks https://people.seas.harvard.edu/~salil/cs127/fall13/ps8.pdf
    let Π = (Gen, Mac, Vrfy) be the secure authentication code defined in construction 4.3
    define Π' = (Gen, Mac', Vrfy') that
        Mac':   on input m, let t = Mac(k, m), output t||0^n
        Vrfy':  on input <m, t>, parse t = t'||pad, where |pad| = n = |k|
                output 1 if Vrfy(k, m, t') = 1 and pad = 0^n or #1(pad)-th bit of the key is 1
                output 0 otherwise
    since the adversary have to both satisfy the vrfy algorithm and guess one bit of the key,
        Pr[Mac-forge(A, Π', n) = 1] <= Pr[Mac-forge(A, Π, n) = 1] <= negl(n)
    but with a vrfy oracle, an adversary can:
        query the Mac oracle for some m and get <m, t||0^n>
        make n queries to the vrfy oracle of <m, t||1^i0^(n-i)> to recover the key
        calculate t for some new m', output <m', t>
    and break the stronger sense of security with certainty

4.6
no
again use the weak pseudorandom function define in part b of problem 3.20
F(k, m||0) = F(k, m||1) for every m <- {0,1}^(n-1)
an adversary only need to query some m||0, get <m||0, t> and output <m||1, t>
by the definition <m||1, t> is valid

4.7
the only part changed in the proof of Theorem 4.6 is the proof of claim 4.8:
    Pr[Mac-forge(A, Π, n) = 1 ∧ ¬Repeat ∧ ¬Forge] = 0 
let <m, t> is the output, m = m1 .. md, t = <r, t1 .. td>
again it has 3 cases:
    1.  the identifier r is different from all identifiers used by the Mac oracle: unchanged
    2.  the identifier was used in exactly one of the Mac tag obtained by A from Mac oracle
        let <m', t'>, m' = m'1 .. m'd', t' = <r, t1' .. t'd'> be result of that query:
        a.  |m'| < |m|, m contains more blocks than m', obviously some block r||b||i||mi was never authenticated
        b.  |m'| > |m|, then the last block r||1||d||md was never authenticated
            the only block in t' with b = 1 is the last block r||1||d'||md', and d != d'
        c.  |m'| = |m|, then there is some i that mi != m'i, then r||b||i||mi was never authenticated
    3.  r was used in more than one of the Mac tags obtained by A from its oracle: again can't happen
the tags are slightly shorter this time

4.8
for messages of length n, Mac(k, m) = F(k, 0^n xor m) = F(k, m)
an adversary can query for some message m, obtain <m, t> and output <m||0^n, Mack(t)>
and Mac(k, m||0^n) = F(k, Mac(k, m) xor 0^n) = F(k, t) = Mac(k, t)

4.9
a.  for messages of length n, Mac(k, m) = F(k, IV xor m)
    define an adversary A that:
        sample m <- {0,1}^n 
        query m, obtain IV||t
        calculate m' = ~m, IV' = ~IV 
        output <m', IV'||t>
    since IV xor m = IV' xor m', F(k, IV' xor m') = F(k, IV xor m) = t
    A breaks the authentication code with certainty
b.  define an adversary A that:
        sample m1, m2 <- {0,1}^n
        query m = m1||m2, obtain t = t1||t2
        calculate m1' = t1 xor m2, m2' = t2 xor m1
        output <m1'||m2', t2||t1>
    t1' = F(k, t1 xor m2) = t2 
    t2' = F(k, t1' xor m1') = F(k, t2 xor t2 xor m1) = F(k, m1) = t1
    thus A succeeds if m1||m2 != m1'||m2'
    as F is pseudorandom, m1 = m1' = t1 xor m2 only happends with negligible probability
    A succeeds with probability 1 - negl(n)

4.10
define the second pre-image finding experiment Hash-sec-pre(A, Π, n):
    1.  A key s is generated by running Gen(1^n), an input x <- {0,1}* is sampled
    2.  The adversary A is given s and x, outputs x' ∈ {0,1}*
    3.  The output of the experiment is defined to be 1 iff x != x' and H(s, x) = H(s, x')
a hash function Π = (Gen, H) is second pre-image resistant if for all polynomial time adversary A:
    Pr[Hash-sec-pre(A, Π, n) = 1] <= negl(n)
define the preimage finding experiment Hash-pre(A, Π, n):
    1.  A key s is generated by running Gen(1^n), an input x <- {0,1}* is sampled, y = H(s, x)
    2.  The adversary A is given s and y, outputs x' ∈ {0,1}*
    3.  The output of th experiment is defined to be 1 iff H(s, x') = y
a hash function Π = (Gen, H) is pre-image resistent if for all polynomial time adversary A:
    Pr[Hash-pre(A, Π, n) = 1] <= negl(n)
if for some hash function Π, there is some A that 
    Pr[Hash-sec-pre(A, Π, n) = 1] = ε(n)
define another A' that:
    run A as a subroutine
    upon input s, sample x <- {0,1}* and pass s, x to A
    when A outputs x', output x and x'
A' perfectly simulates A, success of A implies success of A'
    Pr[Hash-coll(A, Π, n) = 1] = Pr[Hash-sec-pre(A, Π, n) = 1] = ε(n)
if ε(n) is non-negligible, Π is not collision-resistent
thus collision-resistance implies second pre-image resistance
if for some hash function Π, there is some A that
    Pr[Hash-pre(A, Π, n) = 1] = ε(n)
the domain of Hs is infinite and the range is finite
with only negligible probability a x <- {0,1}* will be mapped to a Hs(x) with finite pre-image
so it's safe to assume for a uniformly sampled x <- {0,1}*, H(s, x) has infinite pre-image
since A is only given y = H(s, x), x' and x are independent pre-image of Hs and
    Pr[x = x']  = Pr[x = x' | Hs(x) has finite pre-image] * Pr[Hs(x) has finite pre-image]
                + Pr[x = x' | Hs(x) has infinite pre-image] * Pr[Hs(x) has infinite pre-image]
                <= negl(n)
define another A' that:
    run A as a subroutine 
    upon input s, sample x <- {0,1}*, define y = H(s, x), pass s, y to A
    when A outputs x', output x' as well
then Pr[Hash-sec-pre(A, Π, n) = 1]  = Pr[Hash-pre(A, Π, n) = 1 ∧ x != x']
                                    = Pr[Hash-pre(A, Π, n) = 1] - Pr[Hash-pre(A, Π, n) = 1 ∧ x = x']
                                    >= ε(n) - Pr[x = x']
                                    = ε(n) - negl(n)
if ε(n) is non-negligible, A' breaks second pre-image resistance
thus second pre-image resistance implies pre-image resistance

4.11
a.  obviously, a collision in Π is directly a collision in Π1 and Π2 with corresponding keys
    if an adversary A can break Π with non-negligible probability, deifine a new adversary A1 for Π1 that:
        upon receiving s1, generate s2 <- Gen2(1^n) (1^n is implicit in s1)
        run A with (s1, s2), A outputs x and x'
        output x and x'
    if x and x' is a collision in Π,
        H1(s1, x)||H2(s2, x) = H1(s1, x')||H2(s2, x')
        H1(s1, x) = H1(s1, x')
    so x and x' is also a collision in Π1 and
        Pr[Hash-coll(A1, Π1, n) = 1] >= Pr[Hash-coll(A, Π, n) = 1]
    by a symmetric argument,
        Pr[Hash-coll(A2, Π2, n) = 1] >= Pr[Hash-coll(A, Π, n) = 1]
    if Π is not collision resistent, neither Π1 nor Π2 is
    thus if either Π1 or Π2 is collision resistant, Π is collision resistant
b.  a second pre-image x' in Π is obviously a second pre-image in Π1 and Π2
    but when given H1(s1, x), x cannot be calculated and A1 cannot give H1(s1, x)||H2(s2, x) to A
    the break cannot be transferred from A to A1 by the same idea
    namely if Π1 is pre-image resistent and Π2 just outputs x
    upon receiving H1(s1, x)||H2(s2, x) = H1(s1, x)||x
    an adversary can just output x can break pre-image resistance with certainty

4.12
let Π' = (Gen, H^2), if an adversary A' can break Π' with non-negligible probability, define A for Π that:
    upon receiving s, run A' with s, A' outputs (x, x')
    if H(s, x) = H(s, x'), output (x, x')
    if H(s, x) != H(s, x'), output (H(s, x), H(s, x'))
if x, x' is a collision in Π', H(s, H(s, x)) = H(s, H(s, x')) and x != x'
    if H(s, x) = H(s, x'), then x, x' is a collision in Π
    if H(s, x) != H(s, x'), then H(s, x), H(s, x') is a collision in Π as they hashes to the same result
then 
    Pr[Hash-coll(A, Π, n) = 1] >= Pr[Hash-coll(A', Π', n) = 1]
and the collision resistance of Π implies the collision resistance of Π'

4.13
assume an adversary A can break Π = (Gen, H) with non-negligible probability, define A' for (Gen, h) that:
    upon receiving s, pass s to A and A outputs (x, x')
    pad x and x' to multiply of l(n), parse the result as l(n) bit blocks x = x1 .. xb and x' = x'1 .. x'b'
    define z0 = 0^l(n)
    for i = 1 .. b, calculate every zi = h(s, zi-1||xi)
    for j = 1 .. b', calculate every wj = h(s, wj-1||x'j)
    if there exists some i and j that zi-1||xi != wj-1||x'j but zi = wj, output zi-1||xi and wj-1||x'j
    otherwise output 0, 1
as in proof of Theorem 4.14:
if x != x' and H(s, x) = H(s, x'), there must be some collision between different zi-1||xi and wj-1||x'j
thus
    Pr[Hash-coll(A', (Gen, h), n) = 1] >= Pr[Hash-coll(A, Π, n) = 1]
and the collision resistance of (Gen, h) implies the collision resistance of (Gen, H)

4.14
pad and parse the input to B blocks of length l'(n) - l(n), define z0 = 0^l(n) as well 
then |zi-1||xi| = l'(n) is a valid input to hs, |zi| = l(n) for all i
the proof of its collision resistance unchanged

4.15
a.  x and x padded with 0 to a multiply of l(n) hashes to the same result now 
b.  if (x, x') is a collision in this code, zb||L = z'b'||L', zb = z'b' and L = L'
    then h(s, zb||L) = h(s, z'b'||L') and (x, x') is also a collision in (Gen, H)
    so the collision resistance of (Gen, H) implies collision resistance of this code
c.  a collision (x, x') in this scheme implies IV||zb+1 = IV'||z'b+1, the two application chooses the same IV
    since the IV in (Gen, H) can be replaced by any constant, define z0 = IV and (x, x') is also a collision in (Gen, H)
    so the collision resistance of (Gen, H) implies collision resistance of this code 
d.  if (x, x') is a collision in this code, h(s, zb||L) = h(s, z'b'||L')
    if L != L', (zb||L, z'b'||L') is a collision in (Gen, h)
    if L = L', there exists some i that xi != x'i, and zi-1||xi != z'i-1||x'i
    let i* be the maximal of such i, then there must be some i* <= j <= b+1 that
        zj-1||xj != z'j-1||x'j and h(s, zj-1||xj) = h(s, z'j-1||x'j)
    and that's a collision in (Gen, h)
    so the collision resistance of (Gen, h) implies collision resistance of this code
e.  for a collision resistant hash function (Gen, g), define a new hash function (Gen, h) that:
        h(s, <2l(n)>||x) = <l(n)> for some fixed x ∈ {0,1}^n
        h(s, x) = 1g(s, x) otherwise
    where gs: {0,1}^2l(n) -> {0,1}^(l(n)-1) and <k> is the binary representation of k padded to l(n) bits
    then hs: {0,1}^2l(n) -> {0,1}^l(n), <2l(n)> starts with 0 as 2l(n) < 2^l(n)
    <l(n)> is the only hash code starts with 0, a collision in (Gen, h) must be a collision in (Gen, g)
    implies (Gen, h) is collision resistant
    then for any message x' ∈ {0,1}^l(n),
        H(s, x||x') = h(s, h(s, <2l(n)>||x)||x') = h(s, <l(n)>||x') = H(s, x')
    and (x, x||x') is a collision in (Gen, H)

4.16
let (Gen', h) be a fixed-length collision-resistant hash function, hs: {0,1}^l'(n) -> {0,1}^l(n)
let (Gen', H) be the result of applying the Merkle-Damgard transform described in problem 4.14 to (Gen, h)
let IV be fixed constant string of length l(n), opad and ipad be fixed constant strings of length l'(n) - l(n)
define a MAC as:
    Gen:    generate s <- Gen'(1^n), sample k <- {0,1}^(l'(n) - l(n)), output (s, k)
    Mac:    on input m of length L, output the tag:
                t = H(s, (k xor opad)||H(s, k xor ipad)||m)
            using the fixed IV
    Vrfy:   on input (m, t), output 1 iff t = Mac((s, k), m)

4.17
s is not kept secret, and adversary can calculate
even if s is secret, collision resistance puts no restriction on the distribution of s, and the distribution is public
the underlying hash function (Gen', h) may not have that much variation of s <- Gen'(1^n)
if there is only few s may ever be generated by Gen'(1^n)
h(s, m) can be computed correctly with non-negligible probability
assume |k| = l(n), an adversary can query for Mac(k, ε) = H(s, k) = h(s, h(s, IV||k)||<l(n)>) = tk
then it can calculate h(s, tk||<2l(N)>) = tb, and
    Mac(k, <l(n)>) = H(s, k||<l(n)>)    = h(s, h(s, h(s, IV||k)||<l(n)>)||<2l(n)>)
                                        = h(s, tk||<2l(n)>)
                                        = tb
so if the adversary correctly outputs (<l(n)>, tb), it breaks the MAC
if for some s' that Pr[s = s'] is polynomial, the probability of tb to be correct is non-negligible by guessing s = s'
thus the adversary can break the MAC with non-negligible probability

4.18
for Construction 4.5, if for some valid (m, t)
assume an adversary A with oracle access to Mack but cannot query for m can find another different valid tag t' for m
then it must have find Mac(k, m) with a different identifer r' that
    t' = r', t'1 .. t'd
    t'i = Mac'(k, r'||l||i||mi)
since for any different m' != m A queried, a fresh r is chosen and a collision event ri = rj is negligible
assuming all such queries using different r (true with 1 - negl(n) probability),
only one query m' can have the same identifier as t'
    if |m| != |m'|, every block r||l||i||mi are different
    if |m| = |m'|, as m' != m, at least on one position i, mi != m'i
but then A have effectively forged a fresh pair (r'||l||i||mi, t'i) and breaks Π'
so A cannot success with non-negligible probability
since the encryption scheme in Construction 4.19 is CPA-secure,
encrypting a different message m' will never give Enck(m) or decryption is impossible
encrypting the same message m polynomial times will only give the same ciphertext c with negligible probability
(or an adversary has non-negligible probability to differ Enck(m0) and Enck(m1))
so an adversary attacking CCA-security, with 1 - negl(n) probability, is in the same (or weaker) situation to A
such an adversary only have negligible probability to find another valid tag when given (c, t)
denote the event it find another valid tag for any (c, t) as ValidTag
then
    Pr[PrivK(A, Π', n) = 1] <= Pr[ValidQuery ∧ ¬ValidTag]
                            + Pr[ValidTag] 
                            + Pr[PrivK(A, Π', n) = 1 ∧ ¬ValidQuery ∧ ¬ValidTag]
Pr[ValidTag] <= negl(n)
where Pr[ValidQuery ∧ ¬ValidTag] = Pr[ValidQuery] in the original proof
(if no (c, t') with fresh and valid t' is queried, the proof of Claim 4.21 remains true)
and Pr[PrivK(A, Π', n) = 1 ∧ ¬ValidQuery ∧ ¬ValidTag] = Pr[PrivK(A, Π', n) = 1 ∧ ¬ValidQuery] in the original proof
(similar for Claim 4.22)
thus Pr[PrivK(A, Π', n) = 1] <= 1/2 + negl(n) even if Π' uses MAC from Construction 4.5

4.19
if MAC has unique tags, authenticating a message twice will give the same tag
authenticating two different messages will only give the same tag with negligible probability
proof: if for some m0 and m1, Pr[Mac(k, m0) = Mac(k, m1)] = ε(n)
define an adversary A:
    query for m0, get t
    output (m1, t1)
then A succeeds with probability ε(n) and ε(n) must be negligible for secure MAC
define adversary A attacking CPA-security of encrypt-and-authenticate:
    outputs m0 and m1
    upon receiving c = (c', t), query for Enck(m0), get (c'', t')
    if t = t', output 0; otherwise output 1
then Pr[PrivK(A, Π, n) = 1] = Pr[t' = t | b = 0] / 2 + Pr[t' != t | b = 1] / 2
                            = 1/2 + (1 - Pr[t' = t | b = 1]) / 2
                            = 1/2 + (1 - negl(n)) / 2
                            = 1 - negl(n) / 2
thus Π is not CPA-secure

4.20
the encryption scheme in problem 3.14
it's CCA-secure (the problem text claimed so)
but for all ciphertext c there is a corresponding r||m that Fk(r||m) = c as F being a pseudorandom permutation
so there is Deck(c) = m for every c and there is no authenticated communication

4.21
let MAC be any authentication method, and Enc(k, m) just outputs plain m
then EncMac((k1, k2), m) = <m, t> with encryption-and-authenciation method
oracle access to EncMack is equivalent to Mack, Auth(A, Π', n) is equivalent to Mac-forge(A, ΠM, n)
obviously Pr[Auth(A, Π', n) = 1] = Pr[Mac-forge(A, ΠM, n) = 1] <= negl(n)
but the scheme is not secure at all

4.22
in any valid encryption scheme, different messages never encrypt to the same ciphertext
so if at the end of experiment Auth(A, Π', n), the adversary outputs (c, t) and Dec(k, (c, t)) = m != ⊥, m ∉ Q
then for any previous query m' to EncMack, EncMac(k, m') = (c', t'), c' != c
assume Pr[Auth(A', Π', n) = 1] = ε(n) for some A'
define an adversary A attacking experiment Mac-forge(A, ΠM, n) that:
    sample k1 <- GenE(1^n)
    run A' as a subroutine, when A' queries EncMack with m:
        calculate c = Enc(k, m)
        query Mack2(c) = t
        pass <c, t> to A'
    when A' outputs <c, t>, outputs <c, t> as well
denote all queries to Mack2 in this experiment by QM
if Dec(k1, <c, t>) = m != ⊥, m ∉ Q, then c ∉ QM and Vrfy(k2, c, t) = 1
    negl(n) >= Pr[Mac-forge(A, ΠM, n) = 1] >= Pr[Auth(A', Π', n) = 1] = ε(n)
and this scheme has authenticated communication
combined with Theorem 4.20, it's a secure message transmission scheme

Chapter 5
5.1
assume an adversary A can recover key with 100 queries to oracle Fk
define a distinguisher D with oracle access to a (potentially random) function f that:
    run A as a subroutine
    when A queries Fk with m, query f(m) and pass result to A
    denote Q = {m | m is queried so far}
    if A reports an error, output 0
    when A outputs a key k, choose a random m ∉ Q and calculate F(k, m), compare it to f(m)
    if F(k, m) = f(m), output 1; otherwise output 0
when f = Fk, D simulates A and A outputs k correctly, makes Pr[D(Fk, 1^n) = 1] = Pr[F(k, m) = f(m)] = 1
for invalid inputs (f(m) when f is not Fk), A either reports an error or output a wrong result 
if A reports error, only 2^n (those equal to some Fk) in all n! permutations in Perm(n) will not report an error, so
    Pr[D(f, 1^n) = 1 | A reports error] = 0
2^n / n! is negligible so 1 - 2^n / n! is not
if A gives wrong (random) answer, F(k, m) and f(m) is totally independent, makes 
    Pr[D(f, 1^n) = 1 | A gives wrong answer] = Pr[F(k, m) = f(m)] = 1 / 2^n
thus
    Pr[D(Fk, 1^n) = 1] - Pr[D(f, 1^n) = 1]  = 1 - (0 + 1 / 2^n)
is not negligible, F is not pseudorandom

5.2
using 8 S-boxes of 8 bits, the 4-bit α1 may be influenced by 4 S-boxes and 32 bits in ka
then combined with 4 bits from kb, 2^36 possibilities has to be tested
the probability of false positive is still 1/16, roughly 9 input/output pairs are needed to narrow down the answer
9 * 2^36 * 16 < 2^44 in total
if block size is 128 bits, the key must be extended to 256 bits or there is some dependency between ka and kb
the first 4 bits in the result of the first round still only influenced by 32 bits in ka
the probability of false positive still 1/16
but now there's twice the number of portions of ka have to be tested
complexity 9 * 2^36 * 32 < 2^45 in total

5.3
if Fk is 3-round substitution permutation network described in section 5.1
a one-bit difference in input in known position will be propagated to about 8 bits of the result in known position
when ctr is even, ctr and ctr+1 will only be different at the least significant bit, which is known
F(k, ctr) and F(k, ctr+1) will only be different at 8 known position
by choosing m0 = 0^2n and m1 = 0^n1^n, observe c1 and c2
if they are equal except that 8 bits, m0 must be encrypted, the adversary outputs 0; otherwise it outputs 1
if ctr is even, the adversary outputs 0 or 1 randomly
an adversary using this strategy always succeeds when ctr is odd, or with roughly 3/4 posibility in total

5.4
r permutations in a row is equivalent to a single permutation
r key-mixing, when the scheme is open, is equivalent to a single key-mixing
r substitution with a S-box Si is equivalent to one substitution with a S-box defined as Si^r
this construction is equivalent to a one-round substitution-permutation network
private key can be easily recovered in this construction

5.5
a.  (Lr, Rr) = (L0, R0) if r is even, (R0, L0) if r is odd
    a single round computes Li+1 = Ri, Ri+1 = Li xor 0^n = Li, effectively swaps the position of Li and Ri
b.  (L1, R1) = (R0, L0 xor R0)
    (L2, R2) = (L0 xor R0, R0 xor L0 xor R0) = (L0 xor R0, L0)
    (L3, R3) = (L0, L0 xor R0 xor L0) = (L0, R0)
    thus for any r, (Lr, Rr) = (Lk, Rk), k = r mod 3

5.6
in every round of DES
    E(~m) = ~E(m) as E only duplicates some bits, regardless of their exact value
    ~E(m) xor ~ki = E(m) xor ki by the definition of xor
    so f(~ki, ~m) = f(ki, m) for any sub-key
    assume (L'i, R'i) = (~Li, ~Ri)
    L'i+1 = ~Ri = ~Li+1
    R'i+1 = ~Li xor f(~ki, ~Ri) = ~Li xor f(ki, Ri) = ~(Li xor f(ki, Ri)) = ~Ri+1
    (L'i+1, R'i+1) = (~Li+1, ~Ri+1)
by induction, for all r ∈ N, an r round DES(k, x) = ~DES(~k, ~x)

5.7
query c0 = DESk(0^64) and c1 = DESk(1^64)
brute-force search for any key in {0,1}^56, but for every trial k':
    test if DES(k', 0^64) = c0 and if ~DES(k', 0^64) = c1
    if the first equation holds, with high probability k = k'
    if the second equation holds, by problem 5.6 with high probability k = ~k'
thereby one calculation DES(k', 0^64) can rule out 2 possible keys k' and ~k'
and only 2^56 / 2 = 2^55 calculation is necessary

5.8
for one round in the computation of DESk:
    Li+1 = Ri 
    Ri+1 = Li xor f(ki, Ri)
for one round in the computation of DESk^-1:
    Li = Ri+1 xor f(ki, Li+1)
    Ri = Li+1
swap the roles of L and R in DESk^-1 then:
    L'i = Ri 
    R'i = Li
    L'i = R'i+1
    R'i = L'i+1 xor f(ki, L'i+1)
and the result of the final round in DESk^-1 is swapped to get (R'0, L'0) = (L0, R0)
the only difference between DESk and DESk^-1 is the order of ki applied

5.9
a.  when k = 0^56, every sub-key chosen as a portion of k is also 0^48
    every ki = kj and by problem 5.8, DESk = DESk^-1, DES(k, DES(k, m)) = m
    an adversary can always query DESk(c) on receiving a previous query (m, c)
    if DESk(c) = m, with high probability k is some special value
b.  1^56
    0^28||1^28
    1^28||0^28
c.  asymptotically not, only with 1 / 2^54 probability the four keys will be chosen
    also these keys are problematic in any encryption/permutation scheme
    they are highly regular and must be in some rainbow table
    
5.10
a.  in this variation of DES:
        Li+1 = Ri 
        Ri+1 = Li xor ki xor Ri
    then obviously the i-th bit of any sub-key will only affect the i-th bit in L and R
    for a 16-round DES, the first bit in 16 sub-keys can be tested with the first bit in L16 and R16
    there are 2^16 possibilities, with false positive 1/4
    every bit position in sub-keys can be tested independently, thus the total time required to recover all sub-keys is
        2^16 * log(4, 2^16) * 32 = 2^25
b.  define SWAP(L||R) = (R||L) for |L| = |R|
    for an oracle f, define F'(c) = SWAP(f(SWAP(c)))
    by problem 5.8, if every sub-key is the same, SWAP(DES(k, SWAP(DES(k, m)))) = m
    a distinguisher D can first query for some (m, c), and test if F'(c) = m, output 1 if the equation holds
    if f = DESk, D success with certainty
    if f <- Perm(n), F'(c) will be random and Pr[F'(c) = m] = 1 / 2^n
        |Pr[D(DESk, 1^n) = 1] - Pr[D(f, 1^n) = 1]|  = 1/2 + 1/2 * (1 - 1 / 2^n)
                                                    = 1 - 1 / 2^(n+1)

5.11
after acquired 2^12 candidates for both kl and kr, with a new input/output pair (x', y')
each kl can be tested independent to kr by comparing the XOR of round function outputs
the false positive rate is again 1 / 2^16, and this time with high probability only one kl will be valid
so 2^12 tests is necessary to decide kl or kr, 2 * 2^28 + 2 * 2^12 in total

5.12
a.  since F is a block cipher (pseudorandom permutation)
    when k is known, both F(k, m) and F^-1(k, m) can be efficiently computed
    with a known pair (x, y), an adversary can brute-force all k1 ∈ {0,1}^n
    F^-1(k2, F(k1, m)) and F(k1, m) is computable when k1 is known
    all possible k2 can be computed since both input and output of F^-1(k2, F(k1, m)) is known
    assume Fk maps input to random output, for a given pair (x, y)
    roughly 2^n pairs (k1, k2) will be valid among all 2^2n
    by testing another two input/output pairs, with more than 1 - 2^n probability only one pair will remain valid
b.  for all k2 ∈ {0,1}^n, calculate m = F^-1(k2, 0^n) and store k2 in linked lists in a hash table keyed by m
    then for input m, the linked list contains all k2 that F^-1(k2, 0^n) = m can be queried as a table entry
c.  calculate x = F^-1(k1, 0^n), query for x to get (x, y)
    calculate y' = F^-1(k1, y), then y' = F^-1(k2, F(k1, x)) = F^-1(k2, 0^n)
    then all valid k2 can be determined in constant time after the pre-process step
    if there are multiple k2, false positives can be eliminated with further queries to F' in constant time
d.  do the pre-process step in part b
    brute-force all k1 ∈ {0,1}^n, for every k1 query x = F^-1(k1, 0^n)
    total time 2^n + 2^n = O(2^n)

5.13
let i and j be two indexes starting from 0, l0 and l1 denote the two sorted lists
group the elements of l1 by their first entry z, as l1 is sorted this can be done in linear time
then l1' is a list of elements (z, {k2 | F^-1(k2, y) = z})
while i < len(l0):
    while j < len(l1) and l0[i].1 >= l1'[j].1:
        if l0[i].1 = l1'[j].1: 
            add all {(l0[i].2, k2) | k2 ∈ l1'[i].2} to S
        j++
    i++
runtime linear in 
    1. the combined length of the two lists
    2. the combined size of all l1'[j].2 added to S, i.e. all matches

5.14
a variation of meet-in-the-middle attack
query a input/output pair (x, y)
for all kl ∈ {0,1}^28:
    calculate z = the result of DES(kl||0^28, x) after 8 rounds
    store and sort all (z, kl) in a list 
for all kr ∈ {0,1}^28:
    calculate z' = the result of DES^-1(0^28||kr, y) after 8 rounds
    store and sort (z', kr) in another list
then if z = SWAP(z'), kl||kr is a valid private key for the pair (x, y)
as in the case of double encryption, this attack can be carried out in roughly 2 * 2^28 time

5.15
a.  0^112 and 1^112, both h(x) = 0^64
b.  fix some x1 and calculate y' = DES^-1(x1, y)
    brute-force to find x2 that DES(x2, 0^64) = y'
    total runtime 2^56 + 1
c.  given a value y ∈ {0,1}^64, sample x <- {0,1}^56, calculate z = DES^-1(x, y) and z' = DES(x, 0^64)
    let t and t' be two hashtable indexed by z ∈ {0,1}^64
    set t[z] = t'[z'] = x
    if t[z'] or t'[z] is defined, output t[z]||t'[z] (or t[z']||t'[z']); otherwise sample another x and repeat
    since DES is designed as a pseudorandom permutation
    both DES^-1(x1, y) and DES(x2, 0^64) will effectively be random value in {0,1}^64
    thereby the process is roughly equivalent to finding a collision after sampling z <- {0,1}^64 multiple times
    by A.4, this succeeds with probability greater than q(q-1) / (4 * 2^64) for q independent sample
    when q = 2^32, this strategy succeeds with probability 2^32(2^32 - 1) / 2^66 ≒ 1/4

Chapter 6
6.1
for a sum w (assuming no leading 0), take x = 10^(|w|-1), y = w xor x, then f(x, y) = w
by a binary search, inverse of f(x) = x^2 can be find in time O(log(2^|x^2|)) = O(|x|)

6.2
since f is one-way, for any polynomial time algorithm A there is a negligible function negl:
    Pr(x <- {0,1}^n)[A(f(x)) ∈ f^-1(f(x))] <= negl(n)
for every n
define f' on f that:
    f'(0^n) = 0^n 
    f'(x) = f(x) when x != 0^n for some n
then for all A':
    Pr(x <- {0,1}^n)[A'(f'(x)) ∈ f'^-1(x)]  <= Pr[f'(x) = 0^n] 
                                            + Pr[A'(f'(x)) ∈ f'^-1(x) | f'(x) != 0^n] * Pr[f'(x) != 0^n]
                                            <= Pr[f'(x) = 0^n] + Pr[A'(f(x)) ∈ f^-1(x) | f(x) != 0^n]
    Pr[f'(x) = 0^n] = Pr[f'(x) = 0^n | x = 0^n] * Pr[x = 0^n] + Pr[f'(x) = 0^n | x != 0^n] * Pr[x != 0^n]
                    = 1 / 2^n + Pr[f(x) = 0^n | x != 0^n] * (1 - 1 / 2^n)
if Pr[f(x) = 0^n | x != 0^n] = ε(n) is not negligible, an adversary that:
    on input f(x) = 0^n, sample x' <- {0,1}^n / 0^n and output x'
Pr[f(x) = 0^n] >= Pr[f(x) = 0^n | x != 0^n] * Pr[ x != 0^n] = ε(n) * (1 - 1 / 2^n)
Pr[f(x') = 0^n] = ε(n)
as x and x' are independent, this adversary succeeds with probability ε(n)^2 - negl(n)
if ε(n) is not negligible, this probability is not too, in contradiction to the assumption that f is one-way
thereby ε(n) is negligible and Pr[f'(x) = 0^n] <= 1 / 2^n + ε(n) is negligible
    Pr[A'(f(x)) ∈ f^-1(x)]  >= Pr[A'(f(x)) ∈ f^-1(x) | f(x) != 0^n] * Pr[f(x) != 0^n]
                            = Pr[A'(f(x)) ∈ f^-1(x) | f(x) != 0^n] * (1 - ε(n))
if Pr[A'(f(x)) ∈ f^-1(x) | f(x) != 0^n] = ε'(n) is non-negligible
Pr[A'(f(x)) ∈ f^-1(x)]  >= ε'(n) - negl(n) is also non-negligible, in contradiction to f being one-way
thus Pr(x <- {0,1}^n)[A'(f'(x)) ∈ f'^-1(x)]  <= ε(n) + ε'(n) is negligible for all n
therefore f' is one-way
for infinite x, f is trivially invertible 
but such x only exists uniquely in every probability space x <- {0,1}^n, not infinitely
the one-wayness only consider one probability space a time, so infinite invertible x doesn't matter

6.3
errata: length-preserving => length-regular https://www.cs.umd.edu/~jkatz/imc/errata.pdf
since f is a one-way function, it's efficiently computable
the time required to compute f(x) is bounded by some polynomial p(|x|)
define f'(x) = f(x)||10^(p(|x|) - |f(x)|), then for every input x, 
    |f'(x)| = p(|x|) + 1
so f' is length-regular
if some algorithm A' can invert f' with probability ε(n), define A as:
    on input 1^n and f(x), pass f'(x) = f(x)||10^(p(n) - |f(x)|) to A'
    output whatever A' outputs
obviously |x| = n and A simulates A', a correct output of A' is a correct output of A
    Pr[Invert(A, f, n) = 1] = Pr[Invert(A', f, n) = 1] = ε(n) <= negl(n)
thereby f' is one-way

6.4
assume an algorithm A inverts g(x1, x2) correctly with probability ε(2n) (let |x1| = |x2| = n)
define another algorithm A' that:
    on input f(x1), x1 <- {0,1}^n, sample x2 <- {0,1}^n
    pass 1^2n, (f(x1), x2) to A
    when A outputs (x1', x2'), output x1'
A' perfectly simulates A in experiment Invert(A, g, 2n)
when A succeeds, g(x1', x2') = (f(x1'), x2') = (f(x1), x2), f(x1') = f(x1), A also successfully inverts f
then
    negl(n) >= Pr[Invert(A', f, n) = 1] >= Pr[Invert(A, g, 2n) = 1] = ε(2n)
a negligible function is asymptotically smaller than any 1 / p(n) when p is a polynomial, then 
    ∀p∃N, ∀n > N, negl(n) < 1 / p(n)
define p'(n) = p(2n), then p' is also a polynomial, therefore
    ∀p∃N, ∀n > N, negl(n) < 1 / p'(n) = 1 / p(2n)
that means negl(n) is also asymptotically smaller than any 1 / p(2n) when p is a polynomial
if ε(2n) is non-negligible, there is some polynomial p that ε(2n) is not asymptotically smaller than 1 / p(2n)
but it's impossible as negl(n) >= ε(2n) and negl(n) is asymptotically smaller than any 1 / p(2n)
thus ε(2n) is negligible, g is one-way

6.5
assume f is a length-preserving one-way function
define f'(x1, x2) = f(x1)||0^n, |x1| = |x2| = n
|f'(x1, x2)| = |f(x1)| + |x2| = |x1||x2|
if there is an algorithm A that can invert f' with probability ε(2n)
drop the last n bits (that is x2) from the result then A inverts f(x1), that makes negl(n) >= ε(2n)
as proved in problem 6.4, ε(2n) is negligible, f' is one way and length-preserving
but now G(x) = (f'(x), hc(x)) always has 0s at known positions
an distinguisher D that:
    upon input w = w1 .. w2n+1, if wn+1 = .. = w2n = 0 outputs 1; otherwise 0
Pr[D(G(x)) = 1] = 1, Pr[D(r) = 1] = 1 / 2^n
G is not a pseudorandom generator

6.6
=>  let f' be a one-way function defined on {0,1}* -> {0,1}*
    define Π = (Gen, Samp, f) as a family of functions that:
        Gen(1^n) outputs I = 1^n
        Samp(1^n) samples x <- {0,1}^n
        f(I, x) = f'(x)
    then the experiment Invert(A, Π, n) is equivalent to Invert(A, f', n)
    the one-wayness of f' implies the one-wayness of Π
<=  thanks https://people.seas.harvard.edu/~salil/cs127/fall13/lec9.pdf
    as Π = (Gen, Samp, f) is efficiently computable, I <- Gen at most expands 1^n polynomial times
    there must be a polynomial p = c1 * n^c2 that:
        on input 1^n to Gen, both Gen and Samp won't consume more than p(n) coins
    define
        f'(r1, r2) = (I, f(Samp(I; r2))), where 
        |r1| = |r2| = n and I = Gen(1^n'; r1)
        n' is the biggest integer that p(n') <= n
        (as p(n) = c1 * n^c2, p(n) is monotonic and n' can be find with binary search, in time linear to |n|)
    then f' is deterministic, and if an algorithm A can invert f', define another A' attacking Invert(A', Π, n) that:
        on input I and y, run A(I, y) to get (r1, r2)
        output x = Samp(I; r2)
    if A successfully inverts f'(r1, r2) = (I, y), y = f(Samp(I; r2)) = f(x), A' successfully inverts f(I, y)
        negl(n) >= Pr[Invert(A', Π, n) = 1] >= Pr[Invert(A, f', n) = 1] = ε(2n)
    therefore f' must be one-way
    do not work for one-way permutations as f'(r1, r2) is not length-preserving

6.7
if an algorithm A inverts g(x) with non-negligible probability
an other algorithm A' on input f(x) can calculate f(f(x)) and invert it with A
A' succeeds if A succeeds, thus g(x) must be one-way
the same idea also applies to g(x) = (f(x), f(f(x)))

6.8
a.  assume f is a one-way function
    define a non-deterministic machine that, given input 1^n and y:
        guess a 0 or 1, append it to the previous guesses (ε if this is the first guess)
        check if the current guess x makes f(x) = y
        if that is the case, output x and halt
    |x| = n and f(x) can be calculated in time polynomial to |x|
    then this machine solves inversion problem in nondeterministic polynomial time
    if P = NP, a deterministic machine M can simulate this machine in polynomial time
    M inverts f in polynomial time, in contradiction to the assumption
    thus existance of one-way function implies P != NP
    a more formal proof: https://crypto.stackexchange.com/questions/39878
b.  define f on input x ∈ {0,1}^n as:
        calculate n' as biggest integer that n'^2 + n' <= |x|
        (n' can be calculated by binary search, runtime linear in |x|)
        if x = 0^(|x| - n'^2 - n')||x', calculate g(x') where g is subset-sum function defined in 6.1.2
        otherwise f(x) = 0
    for big enough n, n'^2 + n' <= |x| <= (n'+1)^2 + n', |x| = Θ(n'^2), |x'| = Θ(n'^2) = Θ(|x|)
    for any n, inverting f(x) on some input requires solving subset-sum problem on input size Θ(n)
    when P != NP, this cannot be done in polynomial time, Pr[f(A(f(x))) = f(x)] != 1
    but for infinitely many n = n'^2 + n' + 1, define an algorithm that:
        output x' = 10^(n-1)
    with 1/2 probability, x <- {0,1}^n starts with 1 and f(x) = 0 = f(x')
    therefore f is not one-way

6.9
thanks http://u.cs.biu.ac.il/~lindell/89-856/exercise1-solutions-89-856.pdf
(log function in this proof is actually f(x) = ceiling(log(x)), which has integer range)
for a one-way function f, define f' as:
    on input w, calculate n' be the biggest integer that n' + log(n') <= |w|
    parse w = x||i||pad, |x| = n', |i| = log(n'), pad is the reminding bits
    calculate and output f(x)||i||b||pad
    where |i| = log(n') is a binary number in {0 .. |x| - 1}, b is the (i+1)th bit of x
if there is A' probabilistically inverts f'(x, i), define A as:
    on input 1^n and f(x), sample i <- {0 .. n-1}
    run w0 = A'(1^(n + log(n)), f(x)||i||0) and w1 = A'(1^(n + log(n)), f(x)||i||1)
    define x0, x1 as the first n bits of w0 and w1
    if f(x0) = f(x), output x0; otherwise output x1
if A'(f(x)||i||b) for the correct b succeeds, A succeeds too, thereby f' must be one-way
let n' again be the biggest integer that n' + log(n') <= n
then n' + log(n') <= n <= n' + 1 + log(n'+1)
define algorithm Ai guessing ith bit of x <- {0,1}^n from f'(x) as:
    parse f'(x) = f(x)||i'||b||pad as before
    if i > n' + log(n'), output (i - n' + log(n'))th bit in pad
    if n'+1 <= i <= n' + log(n'), output (i - n')th bit in the repsentation of i'
    if i <= n':
        if i = i'+1, output b
        if i != i'+1, output 1 or 0 randomly
obviously, as both i' and pad is encoded in the output, when i > n' Ai always succeeds
when i <= n' and i = i'+1, ith bit of x is encoded in the output and Ai succeeds
when i <= n' and i != i'+1, Ai succeeds with probability 1/2
as i' is randomly chosen from {0 .. n'-1}, Pr[i = i'+1] = 1/n'
therefore
    Pr[f'(A(f'(x))) = xi]   >= 1/n' + (1/2) * (1 - 1/n')
                            = 1/2 + 1/2n'
                            >= 1/2 + 1/2n

6.10
x != y => f(x) != f(y)
f has a hard-core predicate that for all polynomial time algorithm A:
    Pr(x <- {0,1}^n)[A(f(x)) = hc(x)] <= 1/2 + negl(n)
if an algorithm A' can invert f(x), it must be able to calculate x since f is one-to-one
another algorithm then can run A' and calculate hc(x), which succeeds when A' succeeds
if A' succeeds with non-negligible probability, it's in contradiction to hc being a hard-core predicate of f
thus f must be one-way

6.11
by randomly sampling r <- {0,1}^n, Pr[A(y xor r) xor A(y, r xor ei) = gl(x, ei)] >= 1/2 + ε(n)
let gl(x, ei) = b, by taking m independent sample r and take the majority b':
    Pr[b' != b] <= 1 / (4ε(n)^2m)
                = p(n)^2 / 4m   // ε(n) = 1 / p(n)
take m = p(n)^2 / 2:
    Pr[b' != b] <= 1/2
    Pr[b' = b] >= 1/2
therefore is A' repeats step 1a at least p(n)^2 / 2 times, A' succeeds with probability greater than 1/2
by assumptions, p(n) is polynomial

6.12
analogous to Claim 6.16, the constant plays no roles in the proof
define s(x) = Pr(r <- {0,1}^n)[A(f(x), r) = gl(x, r)]
let Sn = {x | s(x) >= 1/2 + ε(n)/2}, then 
    Pr(x, r)[A(f(x), r) = gl(x, r)] = Pr(x, r)[A(f(x), r) = gl(x, r) | x ∈ Sn] * Pr[x ∈ Sn]
                                    + Pr(x, r)[A(f(x), r) = gl(x, r) | x ∉ Sn] * Pr[x ∉ Sn]
                                    <= Pr[x ∈ Sn] + Pr(x, r)[A(f(x)), r) = gl(x, r) | x ∉ Sn]
    Pr[x ∈ Sn]  >= Pr(x, r)[A(f(x), r) = gl(x, r)] - Pr(x, r)[A(f(x), r) = gl(x, r) | x ∉ Sn]
when x ∉ Sn, Pr(r)[A(f(x), r) = gl(x, r)] < 1/2 + ε(n)/2 by definition of Sn
then
    Pr(x, r)[A(f(x), r) = gl(x, r) | x ∉ Sn]    = (1 / |~Sn|) * ∑(x ∈ ~Sn)Pr(r)[A(f(x), r) = gl(x, r)]
                                                < (1 / |~Sn|) * |~Sn| * (1/2 + ε(n))
                                                = 1/2 + ε(n)/2
    Pr(x ∈ Sn)  >= 1/2 + ε(n) - (1/2 + ε(n)/2)
                = ε(n)/2
as x <- {0,1}^n, |Sn| >= 2^n * ε(n)/2

6.13
let l be the expansion factor of G
define Gi(y1|| .. ||yi||xi+1|| .. ||xn) = y1|| .. ||yi||G(xi+1)|| .. ||G(xn)
where yi <- {0,1}^l(n), xi <- {0,1}^n
the output of all Gi has the same length nl(n)
let si be the input to Gi, si <- {0,1}^(i * l(n) + (n-i) * n)
G0 = G' and Gn takes input r <- {0,1}^nl(n) then output it
if there is some D can distinguish G' and r,
    |Pr[D(G'(s0)) = 1] - Pr[D(r) = 1]| = ε(n)
    = |∑(i ∈ {0 .. n-1})Pr[D(Gi(si)) = 1] - ∑(i ∈ {1 .. n})Pr[D(Gi(si)) = 1]|
    <= ∑(i ∈ {0 .. n-1})|Pr[D(Gi+1(si+1)) = 1] - Pr[D(Gi(si)) = 1]|
so there must be some i' that
    |Pr[D(Gi'+1(si'+1)) = 1] - Pr[D(Gi'(si')) = 1]| >= ε(n)/n
define another D' that takes input |w| ∈ {0,1}^l(n) as:
    sample i <- {0 .. n-1}
    sample y1 .. yi <- {0,1}^l(n)
    sample xi+2 .. xn <- {0,1}^n
    compute s = y1|| .. ||yi||w||G(xi+2)|| .. ||G(xn)
    run D(s), output whatever it outputs
then if i = i':
    if w = G(x), x <- {0,1}^n, D'(w) is equivalent to D(Gi'(si'))
    if w = r, r <- {0,1}^l(n), D'(w) is equivalent to D(Gi'+1(si'+1))
thereby
    |Pr[D'(G(s)) = 1] - Pr[D'(r) = 1]|  >= |Pr[D(Gi'(si')) = 1] - Pr[D(Gi'+1(si'+1)) = 1] * Pr[i = i']
                                        >= (ε(n) / (n-1)) * 1 / (n-1)
                                        >= ε(n) / n^2
since G is a pseudorandom generator, ε(n) / n^2 <= negl(n) and ε(n) must be negligible
G' must be a pseudorandom generator

6.14
G is a pseudorandom generator with expansion factor l(n) = 2n, define G(s) = (G0(s)||G1(s))
then G0, G1: {0,1}^n -> {0,1}^n are two length-preserving functions
G': {0,1}^n -> {0,1}^4n is defined as:
    G'(s) = G0(G0(s))||G0(G1(s))||G1(G0(s))||G1(G1(s))
define a function H: {0,1}^2n -> {0,1}^4n:
    H(s0||s1) = G0(s0)||G0(s1)||G1(s0)||G1(s1)
if some D can distinguish G'(s') and H(s):
    |Pr[D(G'(s')) = 1] - Pr[D(H(s)) = 1]| = ε(n)
    s' <- {0,1}^n, s <- {0,1}^2n
define another D' that:
    take input w ∈ {0,1}^2n, parse w = s0||s1, |s0| = |s1| = n
    calculate w' = G0(s0)||G0(s1)||G1(s0)||G1(s1)
    run D(w'), output whatever it outputs
when w = G(s), s <- {0,1}^n, D' simulates D(G'(s))
when w = r <- {0,1}^2n, D' simulates D(H(w))
    |Pr[D'(G(s)) = 1] - Pr[D'(r) = 1]|  = |Pr[D(G'(s)) = 1] - Pr[D(H(r)) = 1]|
                                        = ε(n) <= negl(n)
thereby G'(s) and H(r) are indistinguishable
by rearranging the result, H'(s0||s1) = G0(s0)||G1(s0)||G0(s1)||G1(s1) = G(s0)||G(s1)
by theorem 6.37, H' is a pseudorandom generator
if some D can distinguish H(s), s <- {0,1}^2n and r <- {0,1}^4n
    |Pr[D(H(s)) = 1] - Pr[D(r) = 1]| = ε(n)
H'(s) and r can be easily distinguished with the same probability, in contradicton to H' being pseudorandom
therefore H(s) and r are indistinguishable
by transitivity of indistinguishability, G'(s) and r are indistinguishable, G' is a pseudorandom generator

6.15
such a distinguisher D can:
    query x1 = f(1)
    query x11 = f(11)
    if x11 = G1(x1), output 1; otherwise output 0
if f = Fk, f(1) = G1(k), f(11) = G1(G1(k)), D always outputs 1
if f <- Func(n), f(1) and f(11) are independent strings in {0,1}^n, Pr[D(f, 1^n) = 1] = Pr[x1 = x11] = 1/2^n
therefore
    |Pr[D(Fk, 1^n) = 1] - Pr[D(f, 1^n) = 1]| = 1 - 1/2^n

6.16
define F' with k = k1|| .. ||kn, |ki| = n and input x ∈ {0,1}^p(n) that:
    F'(k, x) = F(k1, x)|| .. ||F(kn, x)
for a random function f: {0,1}^p(n) -> {0,1}^n, define fi(x) be the first i bits of f(x)
define a sequence of keyed functions Fi that, with k = k1|| .. ||kn, |ki| = n and input x ∈{0,1}^p(n) that:
    Fi(k, x) = f1(x)|| .. ||fi(x)||F(ki+1, x)|| .. ||F(kn, x)
then F0 = F', Fn = f
if some D can distinguish F' and f then:
    |Pr[D(F'k, 1^n) = 1] - Pr[D(f, 1^n) = 1]| = ε(n)
    = |∑(i∈{0 .. n-1})Pr[D(Fik, 1^n) = 1] - ∑(i∈{1 .. n})Pr[D(Fik, 1^n) = 1]|
    <= ∑(i∈{0 .. n-1})|Pr[D(Fik, 1^n) = 1] - Pr[D(Fi+1k, 1^n) = 1]|
then for some i' it must have 
    |Pr[D(Fi'ki, 1^n) = 1] - Pr[D(Fi'+1ki+1, 1^n) = 1]| >= ε(n)/n
    ki <- {0,1}^(n * (n - i))
define another D' that, with an oracle f: {0,1}^p(n) -> {0,1}:
    sample i <- {0 .. n-1}
    sample ki+2 .. kn <- {0,1}^n
    run D as a subroutine, when D queries on input x:
        if x is not queried before:
            sample r <- {0,1}^i, pass w = r||f(x)||F(ki+2, x)|| .. ||F(kn, x) to D
            record the pair (x, w) in a hash table
        if x is queried before:
            query the hash table for w, pass w to D
    output whatever D outputs
the hash table effectively constructs a random function f': {0,1}^p(n) -> {0,1}^i on fly
and it's indistinguishable from fi, as both output random r <- {0,1}^i
if i = i'
    when f = Fk, k <- {0,1}^n, D' simulates D(Fi'k, 1^n)
    when f is a random function {0,1}^p(n)
