/// only problems and some labs, skipping all review questions
/// resource site: https://wps.pearsoned.com/ecs_kurose_compnetw_6/216/55463/14198700.cw/-/14198926/index.html
/// errata: https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_6/Errata_6th_Edition.pdf
/// Wireshark Labs: https://github.com/ashly13/Computer-Networking---A-Top-Down-Approach/tree/master/Wirshark%20Labs
/// 1G = 1024M, 1M = 1024K, 1K = 1024

1.1
// all message transmitted will be shown in JSON
the client (teller machine) first sends a message of account ID and (possibly hashed) password:
    {
        id: String,
        password: String
    }
the server receives the message, check the password against the id, sends back either 
    an error or 
    an accepted message and moves into the Verified state
the error should be as general as possible for security reason
    // one of the two is sent
    "ERROR"
    "ACCEPTED"
once accepted, the client can query for account balance:
    "BALANCE"
    // server response, only in Verified state
    {
        balance: Number
    }
    // not in Verified state
    "VERIFICATION REQUIRED"
or try withdraw an amount of cash:
    {
        withdraw: Number
    }
    // server response, one of them, only in Verified state
    "Insufficient balance"
    {
        withdraw: Number
        // client machine disburse cash
    }
    // not in Verified state
    "VERIFICATION REQUIRED"
at the end client issues a logout, server responses and exit Verified state
    "LOGOUT"
    // server response
    "LOGOUT ACCEPTED"
logout must be mandatory on leave, e.g. the teller machine will only login with physical insertion of a debit card
and automatically logout on ejection of the debit card
the channel must be encrypted

1.2
assuming these packets are the only packets in the network
throughput is uniform among links, end host can send the next packet immediately after the current one
end host start sending the last packet at time (P-1)L/R, it will reach the other end host (P-1)L/R + NL/R
total delay is (P + L - 1)L/R

1.3
a.  a circuit-switched network will be more appropriate if
        k is small enough (there's no waste of network capacity)
        client and server of the application is geographically close
        (otherwise it's better to reuse the existing packet-switched Internet)
b.  congestion control is still necessary, routers may not be processing the packets quick enough

1.4
a.  16, 4 between each two neighboring switches
b.  8, 4 on path A -> B -> C, 4 on path A -> D -> C
c.  possible:
        2 on path A -> B -> C
        2 on path A -> D -> C
        2 on path B -> A -> D
        2 on path B -> C -> D

1.5
assume it takes the tollbooth R minutes to process a car 
if all tollbooth operates at the same rate, there's no queuing delay except in front of the first tollbooth
last car in the caravan is processed by the first tollbooth at (P - 1)R
it finishes after the third tollbooth at (P - 1)R + 60 * 150/100 + 3R = (P + 2)R + 90
a.  7R + 90
b.  10R + 90

1.6
a.  m/s sec
b.  L/R sec
c.  m/s + L/R sec
d.  at the A-end of the link
e.  at Host B
f.  somewhere in the link
g.  m / s = L / R
    m / 2.5e8 = 120 / 56 / 1024
    m = 523.1584km

1.7
assume 8-bit bytes (octets)
transmission delay is 56 * 8 /(2 * 1024 * 1024) = 0.2136ms
propagation delay = 2ms
if the bit is the first of a 56-byte packets:
    encode delay = 56 * 8 / (64 * 1024) = 6.8359ms
if the bit is the last of a 56-byte packets:
    no encode delay
overall between 2.2136ms and 0.0495ms

1.8
a.  [3 * 1024 / 150] = 20
b.  10%
c.  C(120, n)0.1^n0.9^(120 - n)
d.  by normal approximation to binomial:
    P(N >= 21)  ≒ P(X >= 21), X ~ N(12, 10.8)
                = 0.00308495

1.9
a.  [1024 * 1024 / 100] = 10485
b.  Σ{N < k <= M}(C(M, k)p^k(1-p)^(M-k))

1.10
assume the end hosts do not incur switch delays
total delay:
    2d_proc + Σi (di / si + L / Ri)
numerical delay:
    0.002 * 3 + (5000 + 4000 + 1000) / 2.5e6 + 1500 * 8 * 3 / (2 * 1024^2) 
    = 0.0272s = 27.2ms

1.11
one transmission delay only without store-and-forward
L/R + Σi di / si

1.12
queueing delay:
    4.5 * 1500 * 8 / (2 * 1024^2) = 0.0257
    (nL + x)/R

1.13
a.  Σk {0 <= k <= N - 1}(kL/R) / N
    = (N-1)L / 2R
b.  if N packets arrives at the same time every LN/R seconds, same to part a
    all N packets can be transmitted in LN/R, two bursts of packets do not interfere with each other

1.14
a.  delay   = IL/R(1 - I) + L/R
            = a(L/R)^2/(1 - L/R) + L/R
b.  https://www.wolframalpha.com/input/?i=plot%28x%2C+x%5E2%2F%281+-+x%29+%2B+x%29

1.15
μ = L/R
delay = aμ^2 / (1 - μ) + μ

1.16
N = 10, d = 10ms + d_trans = 10ms + 1/100s = 20ms
a = N/d = 0.5 packet/ms

1.17
a.  d_end-end = Σi(di_proc + di_trans + di_prop)
b.  E[D] = Σi(di_proc + di_trans + di_prop + d_queue)

1.18
 1  203.98.68.97 (203.98.68.97) [AS10145]  0.278 ms (255)  0.305 ms (255)  0.282 ms (255) (0% loss)
 2  203.98.68.253 (203.98.68.253) [AS10145]  0.493 ms (63)  0.52 ms (63)  0.431 ms (63) (0% loss)
 3  73.194.233.220.static.exetel.com.au (220.233.194.73) [AS10143]  0.898 ms (253)  1.001 ms (253)  0.827 ms (253) (0% loss)
 4  * * * (100% loss)
 5  Bundle-Ether59.chw-edge903.sydney.telstra.net (203.54.151.81) [AS1221]  2.097 ms (251)  1.7 ms (251)  1.529 ms (251) (0% loss)
 6  bundle-ether17.chw-core10.sydney.telstra.net (203.50.11.176) [AS1221]  3.587 ms (250)  2.826 ms (250)  2.558 ms (250) (0% loss)
 7  bundle-ether8.exi-core10.melbourne.telstra.net (203.50.11.125) [AS1221]  14.751 ms (249)  15.076 ms (249)  14.622 ms (249) (0% loss)
 8  bundle-ether2.exi-ncprouter101.melbourne.telstra.net (203.50.11.209) [AS1221]  12.979 ms (248)  12.783 ms (248)  12.743 ms (248) (0% loss)
 9  www.telstra.net (203.50.5.178) [AS1221]  12.518 ms (247)  12.594 ms (247)  12.6 ms (247) (0% loss)
a.  // skipped
b.  // skipped
c.  3 I guess? one anonymous, exetel and telstra
 1  gigabitethernet3-3.exi1.melbourne.telstra.net (203.50.77.49)  0.287 ms  0.269 ms  0.241 ms
 2  bundle-ether3-100.exi-core10.melbourne.telstra.net (203.50.80.1)  1.984 ms  1.542 ms  2.115 ms
 3  bundle-ether12.chw-core10.sydney.telstra.net (203.50.11.124)  12.604 ms  12.037 ms  12.733 ms
 4  bundle-ether1.oxf-gw11.sydney.telstra.net (203.50.6.93)  12.356 ms  12.309 ms  12.970 ms
 5  bundle-ether1.sydo-core03.sydney.reach.com (203.50.13.98)  47.815 ms  48.011 ms  46.750 ms
 6  i-73.paix-core02.telstraglobal.net (202.84.247.45)  200.086 ms  199.183 ms  200.618 ms
 7  i-92.paix02.telstraglobal.net (202.84.247.41)  199.623 ms  199.929 ms  200.372 ms
 8  liberty_global-peer.eqnx03.pr.telstraglobal.net (134.159.63.85)  198.252 ms  198.181 ms  198.250 ms
 9  be2015.ccr21.sfo01.atlas.cogentco.com (154.54.7.173)  200.120 ms  200.052 ms  199.748 ms
10  be3109.ccr21.slc01.atlas.cogentco.com (154.54.44.138)  215.362 ms  215.043 ms  214.991 ms
11  be3037.ccr21.den01.atlas.cogentco.com (154.54.41.146)  225.486 ms  225.537 ms  225.987 ms
12  be3035.ccr21.mci01.atlas.cogentco.com (154.54.5.90)  237.224 ms  237.282 ms  237.601 ms
13  be2831.ccr41.ord01.atlas.cogentco.com (154.54.42.166)  249.493 ms  248.886 ms  248.849 ms
14  be2717.ccr21.cle04.atlas.cogentco.com (154.54.6.222)  256.835 ms  256.020 ms  256.339 ms
15  be2993.ccr31.yyz02.atlas.cogentco.com (154.54.31.226)  263.587 ms  263.391 ms  263.084 ms
16  38.104.158.202 (38.104.158.202)  269.711 ms  268.513 ms  268.584 ms
d.  roundtrip delay skyrocketed from 12ms to 269ms

1.19
a.  http://traceroute.sdv.fr/
    1	wblindix.sdv.fr      	212.95.66.126      	0.129 ms
    2	border-gateway2.sdv.fr      	212.95.69.227      	0.749 ms
    3	6k-2-sfr-str-e2-3-sdv-plurimedia.customers-sfr-str.ielo.net      	212.85.149.172      	0.894 ms
    4	frpar-th2-c6k1.as29075.net      	185.96.186.74      	6.655 ms
    5	te0-1-0-7.frpar-th2-a9k1.as29075.net      	185.96.186.239      	6.915 ms
    6	be4.frpar-th2-n55h1.as29075.net      	185.18.172.147      	6.945 ms
    7	hu0-0-1-0.frpar-eqx3-n55h1.as29075.net      	185.96.186.118      	7.084 ms
    10	4.14.33.54      	4.14.33.54      	153.228 ms
    11	138.197.244.228      	138.197.244.228      	152.676 ms
    12	138.197.248.207      	138.197.248.207      	173.624 ms
    13	159.203.251.185      	159.203.251.185      	153.57 ms
    https://www.as30781.net/nettools/traceroute/
    #1	JAGUAR-AS (AS30781)	85.31.192.253	be3-200.hr01-corp.mar02.jaguar-network.net	0.851 ms	
    #2	JAGUAR-AS (AS30781)	78.153.231.39	be1.er02.mar02.jaguar-network.net	0.779 ms	
    #3	*	*	*	*	*
    #4	*	*	*	*	*
    #5	AS3356	4.14.33.54	4.14.33.54	162.868 ms	
    #6	*	*	*	*	*
    #7	*	*	*	*	*
    #8	DOSFO (AS14061)	159.203.251.185	159.203.251.185	169.888 ms	
    one in common: 4.14.33.54, a Level 3 Communications switcher in Fremont, US
    it should be the transatlantic link, AS29075 preceding it is in France
b.  http://www.han.de/cgi-bin/nph-trace.cgi
    1  * * *
    2  ae3-u100.cr-nunki.sxb1.bb.godaddy.com (87.230.112.2)  0.369 ms  0.264 ms  0.311 ms
    3  ae4.cr-vega.sxb1.bb.godaddy.com (87.230.114.66)  0.361 ms  0.342 ms  0.317 ms
    4  lag-125.ear2.Paris1.Level3.net (213.242.120.245)  6.538 ms  6.814 ms  7.003 ms
    5  * * *
    6  4.14.33.54 (4.14.33.54)  164.563 ms  164.506 ms 4.14.33.70 (4.14.33.70)  162.352 ms
    7  138.197.244.226 (138.197.244.226)  159.937 ms 138.197.244.230 (138.197.244.230)  159.463 ms  165.193 ms
    8  * * *
    9  159.203.251.185 (159.203.251.185)  157.534 ms  162.840 ms  162.609 ms
    the same transatlantic link 4.14.33.54 appeared
c.  #traceroute www.linkwan.com
    traceroute to www.linkwan.com (218.16.120.36), 30 hops max, 60 byte packets
    1  104.236.128.253 (104.236.128.253)  0.369 ms  0.314 ms  0.272 ms
    2  138.197.248.222 (138.197.248.222)  0.643 ms  11.188 ms  0.520 ms
    3  138.197.244.225 (138.197.244.225)  1.192 ms 138.197.244.229 (138.197.244.229)  1.161 ms 138.197.244.231 (138.197.244.231)  1.171 ms
    4  lag-112.ear2.SanJose1.Level3.net (4.14.33.69)  1.705 ms lag-111.ear2.SanJose1.Level3.net (4.14.33.53)  1.724 ms  1.893 ms
    5  ae-1-9.edge2.SanJose3.Level3.net (4.69.209.181)  1.819 ms ae-3-19.edge2.SanJose3.Level3.net (4.69.209.189)  2.103 ms  1.964 ms
    6  CHINA-TELEC.edge2.SanJose3.Level3.net (4.53.210.118)  5.784 ms CHINA-TELEC.edge2.SanJose3.Level3.net (4.53.210.210)  5.039 ms  4.991 ms
    7  202.97.50.77 (202.97.50.77)  8.361 ms  8.284 ms  8.205 ms
    8  202.97.89.137 (202.97.89.137)  180.948 ms  180.921 ms  180.882 ms
    9  202.97.94.97 (202.97.94.97)  178.113 ms  178.151 ms  178.428 ms
    10  202.97.94.145 (202.97.94.145)  178.605 ms  178.601 ms  178.553 ms
    11  113.96.254.17 (113.96.254.17)  176.119 ms 113.96.254.37 (113.96.254.37)  190.280 ms  190.465 ms
    12  218.16.126.205 (218.16.126.205)  178.072 ms  178.474 ms  178.818 ms
    13  121.14.130.134 (121.14.130.134)  177.900 ms  184.418 ms  184.616 ms
    14  218.16.120.36 (218.16.120.36)  177.238 ms  177.315 ms  177.094 ms
    #traceroute v-www.ihep.ac.cn
    traceroute to v-www.ihep.ac.cn (202.38.128.8), 30 hops max, 60 byte packets
    1  104.236.128.253 (104.236.128.253)  12.702 ms  12.722 ms  12.711 ms
    2  138.197.248.206 (138.197.248.206)  0.719 ms  0.866 ms 138.197.248.222 (138.197.248.222)  0.737 ms
    3  64.86.208.18 (64.86.208.18)  0.486 ms 64.86.208.16 (64.86.208.16)  0.488 ms  0.473 ms
    4  if-ae-22-2.tcore2.sqn-san-jose.as6453.net (64.86.21.101)  2.298 ms  2.240 ms  2.263 ms
    5  if-ae-1-2.tcore1.sqn-san-jose.as6453.net (63.243.205.1)  2.300 ms  2.277 ms  2.325 ms
    6  be6453.ccr41.sjc03.atlas.cogentco.com (154.54.12.141)  2.175 ms  2.184 ms  2.307 ms
    7  be3669.ccr21.sfo01.atlas.cogentco.com (154.54.43.9)  3.485 ms  3.477 ms be3670.ccr22.sfo01.atlas.cogentco.com (154.54.43.13)  3.454 ms
    8  be3694.ccr21.pdx01.atlas.cogentco.com (154.54.84.30)  21.975 ms  22.066 ms be3693.ccr21.pdx01.atlas.cogentco.com (154.54.81.66)  22.323 ms
    9  be3701.ccr21.hkg02.atlas.cogentco.com (154.54.87.122)  155.931 ms  155.930 ms  155.908 ms
    10  154.18.4.2 (154.18.4.2)  157.582 ms  157.347 ms  157.375 ms
    11  8.201 (159.226.254.5)  190.629 ms  190.336 ms  190.597 ms
    12  8.200 (159.226.254.49)  196.974 ms 8.201 (159.226.254.41)  191.384 ms  191.588 ms
    13  8.198 (159.226.254.158)  191.225 ms 8.209 (159.226.254.162)  199.614 ms  199.600 ms
    14  * * *
    15  sslvpn1.ihep.ac.cn (202.122.36.2)  202.456 ms  202.438 ms  202.276 ms
    16  * * *
    17  * * *
    18  * * *
    19  * * *
    20  * * *
    21  * * *
    22  * * *
    23  * * *
    24  * * *
    25  * * *
    26  * * *
    27  * * *
    28  * * *
    29  * * *
    30  * * *
    only the first two
    they do diverge before reaching China

1.20
min(Rs, Rc, R/M)

1.21
one path:
    max(k){min(i){Rki}}
all paths:
    Σk min(i){Rki}

1.22
p(loss) = 1 - (1-p)^N
X ~ Geometric((1-p)^N), E[X] = 1 / (1-p)^N

1.23
a.  trace of last bit of packet 1 
        L/Rs:   leaves A
        +d_prop: reaches switch
        +L/Rc:  leaves switch
        +d_prop: reaches B
    trace of last bit of packet 2
        // no queueing in between: Rc >= Rs
        2L/Rs: leaves A
        +d_prop: reaches switch
        +L/Rc:  leaves switch
        +d_prop: reaches B
    inter-arrival time is L/Rs
b.  possible:
        last bit of the first packet leaves the switch at L/Rs + d_prop + L/Rc
        last bit of the second packet reaches the switch at 2L/Rs + d_prop
        L/Rc > L/Rs
    T >= L/Rc - L/Rs

1.24
40 * 8 * 1024^2 / 100 / 3600 / 24 = 38.8361days
FedEx overnight is much better

1.25
a.  d_prop = 20000 / 2.5e8 = 0.08s
    R * d_prop = 2Mb/s * 0.08s = 0.16Mb
b.  min(800_000b, 0.16Mb) = 0.16Mb
c.  the maximum number of bits in the link
d.  20000 / 0.16 / 1024^2 = 119.209m, slightly longer than a football field
e.  R * d_prop / m = Rm/s / m = R/s

1.26
R = s

1.27
a.  1Gb/s * 0.08s = 0.08Gb
b.  min(800_000b, 0.08Gb) = 800_000b
c.  1Gb/s / 2.5e8m/s = 4.295m

1.28
a.  d = L/R + d_prop = 800_000 / 2 * 1024^2 + 0.08s = 0.381s + 0.08s = 0.461s
b.  one packet:
        L/R:    last bit sent
        +d_prop: last bit received, acknowledge sent
        +d_prop: acknowledge received 
    20(2 * d_prop + L/R) = 3.2s + 0.381s = 3.581s
c.  a is quicker but less reliable, the whole message has to be resent on failure

1.29
a.  36000km / 2.4e8m/s = 0.15s
b.  10Mb/s * 0.15s = 1.5Mb
c.  x / 10Mb/s >= 60s
    x >= 600Mb

1.30
these stickers they attach to your baggage (what's the name of it?)
seats and seat numbers of passengers

1.31
a.  8e6 / 2Mbps = 3.815s each link
    11.444s in total
b.  1e4 / 2Mbps = 0.005s
    2nd packet received at 0.010s
c.  last packet sent from source at 0.005 * 800 = 4s
    last packet received by the destination at 4s + 2 * 0.005 = 4.010s
    almost three times better than no segmentation
d.  failure recovery: destination can require the source to only resend failed segments instead of the whole file
e.  more work for both switches and hosts
    may be complications if the segments are received out-of-order

1.32
propagation delays hit harder with message switching

1.33
N = F/S
last packet is received by the first switch at NL/R, +2L/R it reaches the destination
d(F(80 + S)/SR + 2(80 + S)/R)/dL
= d(80F/SR + F/R + 160/R + 2S/R)/dL
= -80F/RS^2 + 2/R = 0
-40F + S^2 = 0
S = (40F)^(1/2)

1.34
they are both a ISP and a telephone service provider
they somehow can transmit packets between the two networks

2.1
a.  false, the client will send four requests
b.  true, with persistent connections
c.  false, each request is sent as a single TCP segment with nonpersistent connections
d.  false, Date: is the time the object is fetched from the server, the text is describing Last-Modified:
e.  false, GET is sent with empty message body

2.2
USER <SP> <username> <CRLF>
PASS <SP> <password> <CRLF>
ACCT <SP> <account-information> <CRLF>
CWD  <SP> <pathname> <CRLF>
CDUP <CRLF>
SMNT <SP> <pathname> <CRLF>
QUIT <CRLF>
REIN <CRLF>
PORT <SP> <host-port> <CRLF>
PASV <CRLF>
TYPE <SP> <type-code> <CRLF>
STRU <SP> <structure-code> <CRLF>
MODE <SP> <mode-code> <CRLF>
RETR <SP> <pathname> <CRLF>
STOR <SP> <pathname> <CRLF>
STOU <CRLF>
APPE <SP> <pathname> <CRLF>
ALLO <SP> <decimal-integer>
    [<SP> R <SP> <decimal-integer>] <CRLF>
REST <SP> <marker> <CRLF>
RNFR <SP> <pathname> <CRLF>
RNTO <SP> <pathname> <CRLF>
ABOR <CRLF>
DELE <SP> <pathname> <CRLF>
RMD  <SP> <pathname> <CRLF>
MKD  <SP> <pathname> <CRLF>
PWD  <CRLF>
LIST [<SP> <pathname>] <CRLF>
NLST [<SP> <pathname>] <CRLF>
SITE <SP> <string> <CRLF>
SYST <CRLF>
STAT [<SP> <pathname>] <CRLF>
HELP [<SP> <string>] <CRLF>
NOOP <CRLF>
functionality of these commands are specified in section 4.1 of RFC 959

2.3
DNS: resolve host to IP
UDP: for DNS
TCP: for HTTP

2.4
a.  gaia.cs.umass.edu/cs453/index.html
    from Host: and path after GET method
b.  1.1, from HTTP/1.1
c.  persistent, from Connection: keep-alive
d.  unknown, not part of HTTP protocol
e.  Netscape Navigator 7.2, from User-Agent: header
    different browser supports different subset of HTML, CSS and javascript
    it's mainly resolved by client-side shim scripts and css vendor prefixes now
    back in the days server sent different version of pages to client with different browsers

2.5
a.  yes, status code is 200
    reply provided at Tue, 07 Mar 2018 12:39:45 GMT
b.  Sat, 10 Dec2005 18:27:46 GMT, from Last-Modified: header
c.  3874, from Content-Length: header
d.  <!doc, the first five bytes following two <cr><lf>
    yes, from Connection: Keep-Alive header

2.6
a.  by header Connection: close, from section 8.1.2,
        " Persistent connections provide a mechanism by which a client and a
        server can signal the close of a TCP connection. This signaling takes
        place using the Connection header field (section 14.10). Once a close
        has been signaled, the client MUST NOT send any more requests on that
        connection."
    both client and server can signal the close of a connection
b.  apparently none
c.  no. from section 8.1.4, 
        "A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy."
d.  it's possible, from section 8.1.4:
        " A client, server, or proxy MAY close the transport connection at any
        time. For example, a client might have started to send a new request
        at the same time that the server has decided to close the "idle"
        connection. From the server's point of view, the connection is being
        closed while it was idle, but from the client's point of view, a
        request is in progress."

2.7
2RTT0 + Σ(i>0)RTTi
TCP 3-way handshake + transmission + RTTs for DNS

2.8
a.  8 * 2RTT0 = 16RTT0, 2RTT0 for each object
b.  [8/5] * 2RTT0 = 4RTT0
c.  assume all objects are requested in turn, tcp connection already established for the HTML file
    8RTT0, one for each object

2.9
a.  Δ = 0.0540
    β = 16
    d   = Δ / (1 - Δβ)
        = 0.0540 / (1 - 0.0540 * 16)
        = 0.3971
    d_total = d + 2 = 2.3971
b.  0.6 * 850000 / 100Mbps +
    0.4 * d_total
    = 0.9637

2.10
propagation delay can be ignored
parallel and persistent connection can at most skip all the 3 * 11 = 33 control packets
which is a gain of 33 * 200 / 150 = 44 secs
the objects has to be sent through the link with no less than 11 * 100K / 150 = 7509.333 secs
no significant gain from parallel nor persistent connections

2.11
a.  yes: assume Bob uses N parallel connections, each connection get 1/(N + 4) of the total throughput
    Bob gets N / (N + 4) of the total throughput instead of 1 / (N + 4) of other users
b.  no as reasoned above: every user gets 1/5 of the total throughput

2.12
./network/application/printout
most sites today are HTTPS only, to which connection starts with HTTP CONNECT method:
    CONNECT www.icann.org:443 HTTP/1.1
    Host: www.icann.org:443
    Proxy-Connection: keep-alive
    User-Agent: // omitted
all GET requests to non-HTTPS sites do not have If-Modified-Since: header
some explicitly have header disabling caches:
    GET http://milk.com/ HTTP/1.1
    Host: milk.com
    Proxy-Connection: keep-alive
    Pragma: no-cache
    Cache-Control: no-cache
    Upgrade-Insecure-Requests: 1
maybe for security reasons

2.13
FROM: in SMTP is required, only left null on notification of errors
From: in mail data is optional
only the From: in mail data is shown to the users as they and their mail server are not communicating on SMTP

2.14
SMTP mark the end with a period on a single line
HTTP uses Content-Length: header to indicate the length of the message body
HTTP cannot use the same method as SMTP, period on its own line is valid HTTP message content

2.15
Mail Transfer Agents
"Jonny" <tennis5@pp33head.com>, others on the chain are MTAs

2.16
it's meant to provide unique ids of mails consistent across sessions:
    "The unique-id of a message is an arbitrary server-determined
    string, consisting of one to 70 characters in the range 0x21
    to 0x7E, which uniquely identifies a message within a
    maildrop and which persists across sessions.  This
    persistence is required even if a session ends without
    entering the UPDATE state.  The server should never reuse an
    unique-id in a given maildrop, for as long as the entity
    using the unique-id exists."

2.17
a.  C: delete 1
    C: quit
    S: +OK POP3 server signing off
b.  C: quit
    S: +OK POP3 server signing off
c.  C: list
    S: 1 <random number>
    S: 2 <random number>
    // user saw no new mails
    C: quit
    S: +OK POP3 server signing off

2.18
a.  quoting from wikipedia:
        "WHOIS (pronounced as the phrase "who is") is a query and response protocol that is widely used for querying
        databases that store the registered users or assignees of an Internet resource, such as a domain name, an IP
        address block or an autonomous system, but is also used for a wider range of other information."
b.  1.1.1.1
    APNIC and Cloudflare DNS Resolver project
    9.9.9.9
    Global Public Recursive DNS Resolver Service
c.  > set type=NS
    > ietf.org
    Server:         8.8.8.8
    Address:        8.8.8.8#53

    Non-authoritative answer:
    ietf.org        nameserver = ns1.hkg1.afilias-nst.info.
    ietf.org        nameserver = ns1.yyz1.afilias-nst.info.
    ietf.org        nameserver = ns1.mia1.afilias-nst.info.
    ietf.org        nameserver = ns1.ams1.afilias-nst.info.
    ietf.org        nameserver = ns0.amsl.com.
    ietf.org        nameserver = ns1.sea1.afilias-nst.info.

    Authoritative answers can be found from:
    > set type=A
    > ietf.org
    Server:         8.8.8.8
    Address:        8.8.8.8#53

    Non-authoritative answer:
    Name:   ietf.org
    Address: 4.31.198.44
    > set type=MX
    > ietf.org
    Server:         8.8.8.8
    Address:        8.8.8.8#53

    Non-authoritative answer:
    ietf.org        mail exchanger = 0 mail.ietf.org.

    Authoritative answers can be found from:
    and exactly the same results from 1.1.1.1
d.  > bing.com
    Server:         1.1.1.1
    Address:        1.1.1.1#53

    Non-authoritative answer:
    Name:   bing.com
    Address: 13.107.21.200
    Name:   bing.com
    Address: 204.79.197.200
    Yes, it has three
e.  It's not an US entity so not registered on ARIN I guess
f.  they can get physical location of the institution with whois database
    they can do all tropes from spy movies instead of hacking the server remotely behind a computer
    nslookup resolves domain to IP, and IP (especially IPv6) indicates physical address
g.  mostly because of oversight: https://whois.icann.org/en/whats-horizon

2.19
a.  // skipped
b.  // will show one entry from each query, there can be 20+ of them in a single query
    $ dig @a.root-servers.net google.com
    com.                    172800  IN      NS      e.gtld-servers.net.
    google.com.             172800  IN      NS      ns2.google.com.
    google.com.             300     IN      A       172.217.160.11
    $ dig @a.root-servers.net ietf.org
    org.                    172800  IN      NS      d0.org.afilias-nst.org.
    ietf.org.               86400   IN      NS      ns1.mia1.afilias-nst.info.
    ietf.org.               300     IN      A       4.31.198.44

2.20
It depends on the strategy of the cache
a well-designed cache usually keeps most used data in it more frequently to reduce miss rate of the most accessed site
sample the cache at different time and the most frequently seen server in the cache probably is the most accessed site 

2.21
by measuring RTT of nslookup from local dns
if a site is accessed recently, its IP should be in cache of the local DNS
nslookup would take no more than a few milliseconds

2.22
./network/application/problems
N = 10, u = 307200 bps, dcs = 7680.000 secs, dp2p = 7680.000 secs
N = 10, u = 716800 bps, dcs = 7680.000 secs, dp2p = 7680.000 secs
N = 10, u = 2097152 bps, dcs = 7680.000 secs, dp2p = 7680.000 secs
N = 100, u = 307200 bps, dcs = 51200.000 secs, dp2p = 25903.557 secs
N = 100, u = 716800 bps, dcs = 51200.000 secs, dp2p = 15616.203 secs
N = 100, u = 2097152 bps, dcs = 51200.000 secs, dp2p = 7680.000 secs
N = 1000, u = 307200 bps, dcs = 512000.000 secs, dp2p = 47558.781 secs
N = 1000, u = 716800 bps, dcs = 512000.000 secs, dp2p = 21524.852 secs
N = 1000, u = 2097152 bps, dcs = 512000.000 secs, dp2p = 7680.000 secs

2.23
a.  transmit to each client with rate us/N
    it's possible as us/N <= d_min <= di for all i, us/N * N = us <= us
    each client will receive the file in time F / (us/N) = NF / us 
b.  transmit to each client with rate d_min
    it's possible as d_min <= di for all i, N * d_min <= us
    each client will receive the file in time F / d_min
c.  immediately follows part a and b

2.24
// thanks Kumar 2006: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.5807&rep=rep1&type=pdf
a.  let si be the transmit rate from server to peer i
    let ul = Σ(i > 0)ui, us <= (ul + us)/N, Nus <= ul + us, ul/(N - 1) >= us
    si = (1 - δ)ui / (N - 1)
    δ = (ul / (N - 1) - us) / (ul / (N - 1))
    0 <= δ <= 1, (N-1)si <= ui, peer i can redistribute the bits it's receiving to all other peers
    Σsi = Σ(i>0)(1 - δ)ui / (N - 1)
        = (1 - δ) / (N - 1) * Σ(i>0)ui
        = (1 - δ) / (N - 1) * ul
        = us
    the rates can be supported by the server
    the file can be distributed in time F/us
b.  let si = ui / (N - 1) + δ for i >= 1
    δ = (us - ul/(N - 1)) / N >= 0
    Σsi = Σ(i>0)ui/(N - 1) + Nδ
        = ul/(N-1) + us - ul(N-1)
        = us
    each peer redistributes ui/(N-1) fresh bits it's receiving from server to other peers
    peer i receives
        ui/(N-1) + δ + Σ(k != i)uk/(N - 1)
        = Σ(i>0)ui/(N-1) + δ
        = ul/(N-1) + (us - ul/(N-1)) / N
        = (us + ul)/N
    and the file can be distributed in time F / ((us + ul)/N) = NF / (us + ul)
c.  immediately follows part a and b

2.25
N nodes and N(N-1)/2 edges
overlay networks is abstracted over routers and such

2.26
a.  possible, if a peer for which Bob is a neighbor, either 
        1.  there's no more than 3 peers supplying data to the peer
        2.  Bob is optimistically unchoked
    Bob will receive data from the peer even if he doesn't upload
b.  the same as part a, but also share data among these computers and these computers only, with a customized client
    some bittorrent clients have this functionality built in

2.27
peer 3 asks its first second successor (peer 4) for its successor (peer 8)
peer 3 replaces its second successor (peer 5) with the answer 

2.28
15 asks 1
1 asks 3
3 asks 4
4 asks 5
5 realizes it's the predecessor of 6, inform 8 and pass the info back to 6

2.29
if all the known peers are stored in a trie, closest peer can be find in a single O(n) traverse of the trie
difference at nth most significant position suppresses all n-1 less significant bits

2.30
possible, two geographically distant peers may be assigned neighboring identifiers
if the DHT passes messages from neighbor to neighbor, the RTT would be huge 

2.31
a.  before taking any input:
    Error: Os { code: 10061, kind: ConnectionRefused, message: "No connection could be made because the target machine actively refused it." }
    error: process didn't exit successfully: `target\debug\tcp_client.exe 4444 5555` (exit code: 1)
    there's no server to accept the TCP handshakes
b.  aaaa // input
    Error: Os { code: 10054, kind: ConnectionReset, message: "An existing connection was forcibly closed by the remote host." }
    error: process didn't exit successfully: `target\debug\udp_client.exe 4444 5555` (exit code: 1)
    UDP socket only found there's no server on trying to send the packet
c.  the same errors

2.32
not necessary, client port is attached to the datagram
before UDPClient has any port number system allocated for it, later it has port number 5432

2.33
for Chrome it's fixed at 6
it reduces the time wasted on RTTs, but may exhaust the socket resource on the server

2.34
the bytes are received in exact the order been sent, no need to reorder them
additional paddings (including length / format info) would be necessary if the message has variable length

2.35
"free and open-source cross-platform web server software"
it's open-source hence free of charge
provides standard HTTP server features (it is the standard btw)

2.36
key: the SHA-1 hash of a torrent
value: address of peers

Socket Assignment 1
./network/application/web-server

Socket Assignment 2
./network/application/udp-ping
packet structure resembles ICMP echo request/reply

Socket Assignment 3
./network/application/mail
successfully sent to local MailSlurper server and ProtonMail
failed on Gmail due to reputation issue

Socket Assignment 4
./network/application/web-proxy
again most accesses to HTTPS sites start with CONNECT method, which this program does not handle

3.1
a.  (A > 1023, 23)
b.  (B > 1023, 23)
c.  (23, A)
d.  (23, B)
e.  possible
f.  possible: they may be different packets in the same connection

3.2
reverse of the source / dest. ports flowing from client to server
reverse of the IPs in the packets from client to server

3.3
./network/transport/problems
00000000 + 01010011 = 01010011
01010011 + 01100110 = 10111001
10111001 + 01110100 = 00101110
complement of the sum is 11010001
CPUs back then and now can detect if the result of the last operation is all zero in bits
without additional bit operations (by status flags)
the same checksum procedure can be reused at sender and receiver
with 1's complement, the receiver computes checksum of the received packet (including the sender checksum)
if the checksum is correct, the result should be all zero in bits
1-bit error will not go undetected:
    change 1 bit in any byte, the new sum is 2^n bigger or smaller than the old sum
    if the new sum didn't overflow, the sum is changed
    if the new sum did overflow, the LSB will change
    if the changed bit is the LSB and it causes overflow, all bits above it in the sum is changed
2-bit error may go undetected:
    e.g. two bytes switch their LSB, sum will not change

3.4
a.  00111110
b.  10111111
c.  01011101, 01100100

3.5
no, refer 3.3

3.6
the receiver do not double ACK an already received packet
assume the following events occurred:
    sender send packet 0
    receiver received packet 0 correctly, send ACK
    sender received corrupted ACK, retransmit packet 0
receiver will be in state "Wait for 1 from below", but all it will receive is retransmission of packet 0
sender will be in state "Wait for ACK or NAK 0", receive only NAK from receiver and stuck

3.7
because it's a stop-and-wait protocol and the link cannot reorder segments
sender will not move to the next sequence number unless the current packet is ACKed
only two packets (and their retransmissions) may be in the link from sender to receiver at any time
which packet is ACKed can be inferred from the ACK field in the packet

3.8
// the same to rdt2.2 receiver
Wait for 0:
    rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && has_seq0(rcvpkt) => {
        extract_data(rcvpkt, data);
        deliver_data(data);
        sndpkt = make_pkt(ACK, 0, checksum);
        udt_send(sndpkt);
        state_transfer();
    },
    rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || has_seq1(rcvpkt) => {
        sndpkt = make_pkt(ACK, 1, checksum);
        udp_send(sndpkt);
    }
Wait for 1:
    // symmetric

3.9
=>  send pkt 0
<=  rcv pkt 0 (corrupted)
    send ACK 1
=>  rcv ACK 1 (corrupted)
    timeout
    send pkt 0

3.10
Wait for call 0 from above:
    rdt_send(data) => {
        sndpkt = make_pkt(0, data, checksum);
        udt_send(sndpkt);
        timer_start();
        state_transfer();
    }
Wait for ACK or NAK 0:
    rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && isACK(rcvpkt) => {
        timer_stop();
        state_transfer();
    },
    rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isNAK(rcvpkt)) => (),
    timeout => {
        udt_send(sndpkt);
        timer_start();
    }
Wait for call 0 from above:
    // symmetric
Wait for ACK or NAK 0:
    // symmetric
if packet is lost, no ACK from receiver, sender timeout in RTT and retransmit
on receiving an ACK or NAK:
    NAK means the packet is corrupted, wait for timeout and retransmit
    ACK means one of the two:
        the receiver is sync with the sender, ACK for the current sequential number
        the receiver is waiting for the next sequential number, ACK for the current sequential number was sent but lost
    both case the sender should move to the next sequential number await for call from above
    by waiting at least RTT before retransmission, sender will never receive an ACK to the last sequential number
    in no situation the sender may move to the next sequential number faster than the receiver
if ACK is lost:
    timeout in RTT and retransmit

3.11
assume the following events occurred:
    =>  send pkt 0
    <=  rcv pkt 0 (move to Wait for 1 from below)
        send ACK 0 (corrupted)
    =>  rcv ACK 0 (corrupted)
        send pkt 0
    =>  (waiting for ACK)
    <=  (waiting for pkg)
if the action is removed, both receiver and sender will deadlock
if the event is removed from Wait for 0 from below, when the first pkg 0 is corrupted
receiver has no action corresponding to the event and deadlock

3.12
for each ACK with wrong sequential number the sender will retransmit the packet
assume the following events occurred:
    =>  send pkt 0
    <=  rcv pkt 0 (corrupted)
        send ACK 1 (delayed)
    =>  (timeout) send pkt 0
        rcv ACK 1
        send pkt 0
if the link is congested, number of retransmission may grow linearly, packet n may be transmitted n times

3.13
assume the following events occurred:
    =>  send pkt 0
    <=  rcv pkt 0
        send ACK 0 (delayed), move to state 1
    =>  (timeout) send pkt 0
    =>  rcv ACK 0, move to state 1
        send pkt 1
    <=  rcv pkt 1
        send ACK 1, move to state 0
    =>  rcv ACK 1, move to state 0
        send pkt 0 (lost)
    <=  rcv pkt 0 (delayed)
        send ACK 0, move to state 1
    =>  rcv ACK 0, move to state 1
second pkt 0 is lost, but sender receives an old ACK 0 and moves to the next sequential number
second pkt 0 will never be retransmitted

3.14
without ACK, there's no way to implement a pipelined sender: all packets sent so far has to be cached
sender by no means can confirm if a packet is correctly sent or an NAK is awfully delayed
in stop-and-wait protocol, when data is sent infrequently,
    when there's no response from receiver, sender will send packets anyway
    receiver may only detect packet loss when there's gaps in the packets received
    may be minutes later to when the packet is sent
when data is sent frequently with few bit errors:
    receiver will detect packet loss relatively fast, an NAK will arrive at sender almost immediately
    it's similar to GBN protocol, even though required cache size is still unbounded

3.15
ignore propagation delay, RTT = 30msec
let window size be w packets
    0.98 * 1Gbps * 30msec <= w * 1500byte
    w >= 2631

3.16
sender upon receiving ACK corresponding to its state will advance and send the next packet immediately
it defeats all design principles of rdt3.0, nothing holds anymore
e.g. lost packets are not retranmitted

3.17
Host A
Await:
    rdt_send(data) => {
        rdt_unable_to_send(data); 
    }
    rdt_rcv(packet) => {
        extract(packet, data);
        deliver_data(data);
        move_to_state(Ready);
    }
Ready (Init):
    rdt_send(data) => {
        packet = make_pkt(data);
        udt_send(packet);
        move_to_state(Await);
    }
    rdt_rcv(packet) => {
        // should be impossible
    }
Host B
// symmetric, init state is Await

3.18
// assume initial sequential number is established during handshaking 
Sender
    Data0
        rdt_send(data) => {
            packet0 = make_pkt(data, sn + 1);
            udt_send(packet0);
            move_to_state(Data1);
        }
    Data1
        rdt_send(data) => {
            packet1 = make_pkt(data, sn + 2);
            udt_send(packet1);
            timer_start();
            move_to_state(Await);
        }
    Await
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 1 => {
            move_to_state(Await1);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 2 => {
            move_to_state(Await0);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn <= sn => {
            // ignore duplicated ACK
        }
        timeout => {
            udt_send(packet0);
            udt_send(packet1);
            timer_start();
        }
    Await0
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 1 => {
            timer_stop();
            sn += 2;
            move_to_state(Data0);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn != sn + 1 => {
            // ignore other ACK
        }
        timeout => {
            udt_send(packet0);
            timer_start();
        }
    Await1
    // symmetric to Await0
Receiver
    Await
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 1 => {
            extract_data(rcvpkt, data0);
            packet = make_pkt(ACK, sn + 1);
            udt_send(packet);
            move_to_state(Await1);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 2 => {
            extract_data(rcvpkt, data1);
            packet = make_pkt(ACK, sn + 2);
            udt_send(packet);
            move_to_state(Await0);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn <= sn => {
            // duplicated ACK
            packet = make_pkt(ACK, rcvpkt.sn);
            udt_send(packet);
        }
    Await0
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 1 => {
            extract_data(rcvpkt, data1);
            deliver_data(data0);
            deliver_data(data1);
            packet = make_pkt(ACK, sn + 1);
            udt_send(packet);
            sn += 2;
            move_to_state(Await);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn != sn + 1 => {
            // duplicated ACK
            packet = make_pkt(ACK, rcvpkt.sn);
            udt_send(packet);
        }
    Await1
    // symmetric to Await0
if first packet is lost:
    =>  send pkt sn + 1 (lost), => Data1
        send pkt sn + 2, => Await
    <=  rcv pkt sn + 1
        send ACK sn + 1, => Await1
    =>  rcv ACK sn + 1, => Await1
    =>  (timeout) send pkt sn + 2
    <=  rcv pkt sn + 2
        send ACK sn + 2, => Await
    =>  rcv ACK sn + 2, => Data0
if second ACK is lost:
    =>  send pkt sn + 1, => Data1
        send pkt sn + 2, => Await
    <=  rcv pkt sn + 1
        send ACK sn + 1, => Await1
    <=  rcv pkt sn + 2
        send ACK sn + 2 (lost), Await
    =>  rcv ACK sn + 1, => Await1
    =>  (timeout) send pkt sn + 2
    <=  rcv pkt sn + 2 (current sn' = sn + 2, duplicated ACK)
        send ACK sn + 2
    =>  rcv ACK sn + 2, => Data0

3.19
Host A
// should be almost the same to 3.18
// instead of two different packets from the same host, it's two identical packets from different hosts
// initial sequential bit is established in protocol or during handshake
    Data
        rdt_send(data) => {
            packet = make_pkt(data);
            udt_send(packet, sn);
            timer_start();
            move_to_state(Await);
        }
    Await
        rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && rcvpkt.sn == sn && rcvpkt.sender = B => {
            move_to_state(AwaitC);
        }
        rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && rcvpkt.sn == sn && rcvpkt.sender = C => {
            move_to_state(AwaitB);
        }
        rdt_rcv(rcvpkt) && (corrupted(rcvpkt) || rcvpkt.sn != sn) => {
            // ignore corrupted or delayed ACK
        }
        timeout => {
            udt_send(packet);
            timer_start();
        }
    AwaitB
        rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && rcvpkt.sn == sn && rcvpkt.sender = B => {
            // flip sequential bit
            sn = !sn;
            move_to_state(Data);
        }
        rdt_rcv(rcvpkt) && (corrupted(rcvpkt) || rcvpkt.sn != sn || revpkt.sender != B) => {
            // ignore corrupted, delayed or duplicated ACK
        }
        timeout => {
            udt_send(packet);
            timer_start();
        }
    AwaitC
    // symmetric
Host B
    Await
        rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && rcvpkt.sn == sn => {
            extract_data(rcvpkt, data);
            deliver_data(data);
            packet = make_pkt(ACK, sn, B);
            udt_send(packet);
            sn = !sn;
        }
        rdt_rcv(rcvpkt) && (corrupted(rcvpkt) || rcvpkt.sn != sn) => {
            // for both corrupted and delayed data
            // channel cannot reorder packets, different sn must be last packet
            packet = make_pkt(ACK, !sn, B);
            udt_send(packet);
        }
Host C
// symmetric
sender packet format:
    source port
    target port
    data length
    checksum
    sequential number
    data
receiver ACK packet format:
    source port
    target port
    checksum
    sequential number
    machine number (B or C)

3.20
separate rdt3.0 for both A -> C and B -> C with application layer protocol reading data from them alternatively
in a single FSM: rdt3.0 receiver with duplicated states for each sender

3.21
Host A
    Request
        rdt_request => {
            packet = make_pkt(R, sn);
            udt_send(packet);
            timer_start();
            move_to_state(Await);
        }
    Await
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn => {
            extract_data(rcvpkt, data);
            deliver_data(data);
            sn += 1;
            move_to_state(Request);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn != sn => {
            // cannot happen: B => A channel is reliable, data with each sequential number is sent once
        }
        timeout => {
            udt_send(packet);
            timer_start();
        }
Host B
    Await
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn => {
            udt_send(D);
            sn += 1;
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn < sn => {
            // duplicated request
        }
request packet format:
    source port
    target port
    sequential number
    request R
data packet format:
    source port
    target port
    sequential number
    data D

3.22
a.  min:
        sender has sent packet with sn k - 1, it may not be ACKed (the ACK packet may be lost or delayed)
        if the packet in sender's window with minimum sn is earlier than k - 1, packet k - 1 is in the window too
        k - 1 - (4 - 1) = k - 4 is the minimum possible sn in the window
    max:
        receiver didn't send ACK for sn = k
        if sender received ACK for all packets up to k - 1, its window starts with k
        k + 3 is the maximum possible sn in the window
b.  sender sent packet k - 1, it must has received ACK for sn = k - 5, otherwise k - 1 is not in the window
    ACKs sent by receiver have non-decreasing sn:
        when receiver is expecting sn = k, all ACK from it has sn <= k
    ACK with sn = k - 5 arrived, currently expecting sn = k, channel cannot reorder packets
    [k - 5, k - 1] are the possible sn in ACK field of packets in the channel
    k - 5 is possible in response to a delayed retransmission of packet k - 5

3.23
let w be window size, receiver is expecting sn = n
GBN:
    as arguments in 3.22, sn - w - 1 cannot wrap to sn + w - 1 or a wrong packet will be ACKed
    sn + w - 1 - (sn - w - 1) < k, 2w < k, w < k/2
SR:
    assume the next in-order packet the receiver is expecting is n
    min and max: same to GBN
    ACKs in the channel:
        earliest ACK is same to GBN
        SR protocol may also send ACK for out-of-order packets up to n + w - 1
    w < k/2 again

3.24
a.  true; with window size = 1, SR is equivalent to stop-and-wait rdt3.0
    rdt3.0 sender may receive delayed ACK for earlier sn
b.  true; same to part a
c.  true; with window size 1 there's no cumulative acknowledgement
d.  true; with window size 1 there's no out-of-order acknowledgement

3.25
a.  UDP packet sizes are decided by the application layer caller on each call
    TCP packet sizes are decided by MSS and the data may be segmented arbitrarily by the TCP implementation
b.  UDP has no congestion control, a packet is sent immediately when called from above
    TCP may buffer the data if it's not in the sender's window or outright deny it

3.26
a.  2^32 = 4GB
b.  4GB * ((536 + 66) / 536) / 155Mbps = 237.438s

3.27
a.  sn = 207
    source port = 302
    dest port = 80
b.  ack = 207
    source port = 80
    dest port = 302
c.  ack = 127
    source port = 80
    dest port = 302
d.  =>  send pkt { sn = 127, length = 80 }
    =>  send pkt { sn = 207, length = 40 }
    <=  rcv pkt { sn = 127, length = 80 }
        send ACK { sn = 207 } (lost)
    <=  rcv pkt { sn = 207, length = 40 }
        send ACK { sn = 247 }
    =>  (timeout) send pkt { sn = 127, length = 80 }
    =>  rcv ACK { sn = 247 }
    <=  rcv pkt { sn = 127, length = 80 }
        send ACK { sn = 247 }
    =>  rcv ACK { sn = 247 }

3.28
flow control happens at two places:
1.  the application on Host A will eventually fill the buffer of TCP sender, blocking the thread or get IO error
2.  ACKs from Host B to Host A will have smaller and smaller rwnd field
    once rwnd <= current un-ACKed bytes in sender's window sender will stop sending new packets

3.29
a.  to protect itself from SYN flood attack
    with SYN cookies, to create an open / half open TCP connection on the server
    the attacker must maintain one TCP connection with the server for at least one RTT
    which significantly reduces the intensity of possible attacks
b.  no, it must maintain TCP connection for one RTT
    hash function is computationally impractical to reverse
    the attacker cannot forge the cookie without actually knowing the secret number
c.  no, the cookie contains information of both the source and target IP
    cookies collected from other hosts with different IP would be found invalid when server received the ACK
    in practice SYN cookies also contain temporal information
    even cookies collected on the same host won't be valid most of the time

3.30
a.  assume the link from router to target host has small transmission rate compared to source to router links
    naturally packets will pile up at the router
    if the router has small buffer they are lost and after timeout sender will retransmit them
    if the router has big buffer they still will be retransmitted
    however this time the buffered packets will be transmitted too, wasting more channel capacity
b.  the maximum achievable throughput won't be improved (limited by links)
    if the senders can eliminate retransmission of buffered packets entirely
    from sender's view the receiver are having bigger buffer, hence bigger rwnd and it might help increasing throughput

3.31
./network/transport/problems
after observed sample rtt = 106ms, EstimatedRTT = 100ms, DevRTT = 5ms, TimeoutInterval = 120ms
after observed sample rtt = 120ms, EstimatedRTT = 102ms, DevRTT = 8ms, TimeoutInterval = 134ms
after observed sample rtt = 140ms, EstimatedRTT = 106ms, DevRTT = 14ms, TimeoutInterval = 162ms
after observed sample rtt = 90ms, EstimatedRTT = 104ms, DevRTT = 14ms, TimeoutInterval = 160ms
after observed sample rtt = 115ms, EstimatedRTT = 105ms, DevRTT = 13ms, TimeoutInterval = 157ms

3.32
a.  αΣ(1 <= i <= 5)RTTi(1-α)^(i-1), where RTT5 is the estimated RTT before observing RTT4
b.  αΣ(1 <= i <= n+1)RTTi(1-α)^(i-1), where RTTn+1 is the estimated RTT before observing RTTn
c.  earlier observations has exponentially diminishing weights in the sum

3.33
the sender cannot be sure whether the ACK is in response to the original packet or the retransmission

3.34
LastByteRcvd is the last byte received in order, receiver has sent ACK for the packet containing the byte
also LastByteRcvd is the maximum sn the receiver has sent in ACK field so far
if the ACK is received by the sender, SendBase = LastByteRcvd + 1 (all following packets are not ACKed)
otherwise SendBase <= LastByteRcvd

3.35
there is an ACK packet from receiver with y = LastByteRcvd + 1, while it may be lost 

3.36
referring https://tools.ietf.org/html/rfc2001#section-3
    "Since TCP does not know whether a duplicate ACK is caused by a lost
    segment or just a reordering of segments, it waits for a small number
    of duplicate ACKs to be received.  It is assumed that if there is
    just a reordering of the segments, there will be only one or two
    duplicate ACKs before the reordered segment is processed, which will
    then generate a new ACK.  If three or more duplicate ACKs are
    received in a row, it is a strong indication that a segment has been
    lost.  TCP then performs a retransmission of what appears to be the
    missing segment, without waiting for a retransmission timer to
    expire."

3.37
a.  GBN:
        =>  5 packets first, 4 more packets after timeout
        <=  4 ACKs for the first group, 4 more for the retransmission
    SR:
        =>  5 packets first, 1 more packets after timeout
        <=  4 ACKs for the first group, 1 more for the retransmission
    TCP:
        =>  5 packets
            (timeout if no fast retransmit)
            1 packet
            1 packet
            1 packet
            1 packet
        <=  4 ACKs (all with same sn)
            1 ACK
            1 ACK
            1 ACK
            1 ACK
b.  TCP with fast retransmit

3.38
sending rate is approximately cwnd / RTT since sender can only send cwnd bytes before stopping and waiting for ACK
when RTT is not the limiting factor (e.g. transmit rate is low), cwnd may not reflect the true rate

3.39
no premature timeout:
    link capacity is exhausted, increase λin anymore and the new packets will all lost
    higher proportion of packets will lost, causing more retransmission
    fewer packets among R/2 would be original packets, λ_out would be lower
premature timeout:
    maximum rate from sender to route is R/2
    maximum rate from router to receiver is (R/2)/2 = R/4
    increasing λ'_in cannot increase λ_out

3.40
a.  [0, 6] and [23, 26], cwnd is increasing exponentially
b.  [6, 16] and [17, 22], cwnd is increasing linearly
c.  by triple duplicated ACK, cwnd is roughly halved
d.  by timeout, cwnd is set to 1
e.  32, shown by transfer from slow start to congestion avoidance at 6
f.  21, 42 / 2 on triple duplicated ACK
g.  14, 29 / 2 on timeout
h.  7
i.  ssthresh = 8 / 2 = 4
    cwnd = ssthresh + 3 = 7
j.  ssthresh = 42 / 2 = 21
    cwnd = 1 + (18 - 17) = 2
k.  (1 + 6) * 6 / 2 = 21

3.41
no, the throughput of 1 and 2 will go back and forth on the same line
increase the same amount in congestion avoidance, cause timeout, then decrease the same constant amount

3.42
TCP is a pipelined protocol
without cwnd, long timeout would not stop sender from sending packets into the channel

3.43
not flow control: rwnd is too big to be a limitation
not congestion control: no loss or duplicated ACK
when send buffer is full, TCP socket will block the application thread or return IO error

3.44
a.  6RTT
b.  (1 + 6) * 6 / 2 MSS / 6RTT
    = 3.5MSS / RTT

3.45
a.  during a period, total number of packets sent is 
        Σ(W/2 <= i <= W)i
        = (W/2 + W) * (W/2 + 1) / 2
        = 3W^2/8 + 3W/4
    among which a single packet is lost, lost rate is 1/(3W^2/8 + 3W/4)
b.  L = 1/(3W^2/8 + 3W/4)
    3W^2/8 + 3W/4 - 1/L = 0
    W^2 + 2W - 8/3L = 0
    W = ((3L + 8) / 3L)^(1/2) - 1
    asymptotically W^2 = 8L/3, W = (8/3L)^(1/2) = 1.633L^(1/2)
    average rate = 0.75W MSS / RTT = 1.225 / L^(1/2) MSS/RTT

3.46
a.  W * MSS / RTT = 10Mbps
    W * 1500byte / 0.15sec = 10Mbps
    W = 10 * 1024^2 * 0.15 / (1500 * 8) = 131.072 segments
b.  average window size = 0.75W = 98.304 segments
    average throughput = 0.75W / RTT = 7.5Mbps
c.  W / 2 = 65.536 secs

3.47
let wb be window size in bytes
wb = 1500byte * W = 10Mbps * 0.15sec = C * RTT
with any smaller window size the TCP sender won't be able to send packets quick enough

3.48
a.  W = 10 * 1024^3 * 0.15 / (1500 * 8) = 134217.728 segments
b.  average window size = 0.75W = 100663.296 segments
    average throughput = 0.75W MSS / RTT = 7.5Gbps
c.  W / 2 = 67108.864 secs
    possible solution: switch to TCP CUBIC

3.49
average throughput = W' = 0.75W / RTT
T = W/2 = W' * RTT / 0.75

3.50
./network/transport/problems
a.  at the end of t =   50ms, C1.cwnd = 5,C2.cwnd = 10,
    at the end of t =  100ms, C1.cwnd = 3,C2.cwnd = 5,
    at the end of t =  150ms, C1.cwnd = 2,C2.cwnd = 5,
    at the end of t =  200ms, C1.cwnd = 1,C2.cwnd = 3,
    at the end of t =  250ms, C1.cwnd = 1,C2.cwnd = 3,
    at the end of t =  300ms, C1.cwnd = 1,C2.cwnd = 2,
    at the end of t =  350ms, C1.cwnd = 1,C2.cwnd = 2,
    at the end of t =  400ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  450ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  500ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  550ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  600ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  650ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  700ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  750ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  800ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  850ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  900ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  950ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t = 1000ms, C1.cwnd = 1,C2.cwnd = 1,
b.  no, C1 with shorter rtt will receive ack more frequently, has more chance to increase its cwnd

3.51
./network/transport/problems
a.  at the end of t =  100ms, C1.cwnd = 8,C2.cwnd = 5,
    at the end of t =  200ms, C1.cwnd = 4,C2.cwnd = 3,
    at the end of t =  300ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t =  400ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  500ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t =  600ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  700ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t =  800ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  900ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1000ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1100ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1200ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1300ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1400ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1500ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1600ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1700ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1800ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1900ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 2000ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 2100ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 2200ms, C1.cwnd = 1,C2.cwnd = 1,
b.  yes
c.  yes, they have the same rtt
    when the link capacity is exceeded all cwnd will be penalized at the same time
    when the link capacity is not exceeded all cwnd will increase at the same time
    maximum cwnd is 2 for both of them
d.  no, synchronized hosts will increase / decrease cwnd at the same time
    either waste link capacity or experience lost at the same time, amplitude of total sending rate will be bigger
    this phenomenon is called "TCP global synchronization"
    and is addressed by a mechanism called "random early detection (RED)"
    by which packets are dropped with different probability for different hosts

3.52
total number of packets send before a loss is
    Σ(0 <= i <= k)(W/2) * (1 + a)^i, where (1 + a)^k = 2, k = log(1 + a, 2)
    = (W/2)(1 - (1 + a)^(k + 1)) / (1 - (1 + a))
    = (W/2)(1 - 2(1 + a)) / -a
    = (W/2)(-2a - 1) / -a
    = (W/2)(1 + 2a) / a
    = W(1 + 2a)/2a
lost rate is
    L = 2a / W(1 + 2a)
this algorithm spends log(1 + a, 2) to increase its congestion window size from W/2 to W, independent to W

3.53
L   = (1.22 * MSS / (RTT * B))^2
    = 1.859e-12

3.54
pro:    TCP will resume at speed in the range [W/2, W], utilizing more link capacity than slow start
con:    W estimation through cwnd and ssthresh may not be accurate anymore due to congestion or other connections
        TCP may experience or cause packet loss
alternative: start with cwnd = 1 and do slow start

3.55
a.  response will go to address Y
b.  the server can be certain, it sent SYNACK to the address Y and got a valid response

3.56
after sending a packet, ACK will come back in time RTT
let cwnd = k * pkt, if (k - 1)S/R < RTT, kS/R < S/R + RTT, the server have to wait for another ACK
otherwise the server can send packets at full speed
a.  4S/R > S/R + RTT > 2S/R
    0:      =>  send ACK    
    0.5RTT: <=  rcv ACK, send SYNACK
    1RTT:   =>  rcv SYNACK, send request
    1.5RTT: <=  rcv request, start sending pkt 0
    S/R + 1.5RTT    <=  send pkt  
    S/R + 2.0RTT    =>  rcv pkt 0, send ACK 0
    S/R + 2.5RTT    <=  rcv ACK 0, cwnd = 2, start sending pkt 1 and 2
    2S/R + 2.5RTT   <=  send pkt 1
    3S/R + 2.5RTT   <=  send pkt 2
    2S/R + 3.0RTT   =>  rcv pkt 1, send ACK 1
    3S/R + 3.0RTT   =>  rcv pkt 2, send ACK 2
    2S/R + 3.5RTT   <=  rcv ACK 1, cwnd = 3, start sending pkt 3, 4 and 5
    3S/R + 3.5RTT   <=  rcv ACK 2, cwnd = 4, send pkt 3, start sending pkt 6, wait no more
    pkt 14 will be sent at time 3S/R + 3.5RTT + 11S/R = 14S/R + 3.5RTT
    will be received at time 14S/R + 4RTT
a pair of lists [a, b], [c, d] indicates the congestion window where a, b were sent, c, d can be sent but not yet
sum of length of the two lists should be cwnd / MSS
b.  RTT > 4S/R
    0:      =>  send ACK    
    0.5RTT: <=  rcv ACK, send SYNACK
    1RTT:   =>  rcv SYNACK, send request
    1.5RTT: <=  rcv request, cwnd = 1, [], [0]
    S/R + 1.5RTT    <=  [0], []
    S/R + 2.0RTT    =>  rcv pkt 0, send ACK 0
    S/R + 2.5RTT    <=  rcv ACK 0, cwnd = 2, [], [1, 2]
    2S/R + 2.5RTT   <=  [1], [2]
    3S/R + 2.5RTT   <=  [1, 2], []
    2S/R + 3.0RTT   =>  rcv pkt 1, send ACK 1
    3S/R + 3.0RTT   =>  rcv pkt 2, send ACK 2
    2S/R + 3.5RTT   <=  rcv ACK 1, cwnd = 3, [2], [3, 4]
    3S/R + 3.5RTT   <=  rcv ACK 2, cwnd = 4, [3], [4, 5, 6]
    4S/R + 3.5RTT   <=  [3, 4], [5, 6]
    5S/R + 3.5RTT   <=  [3, 4, 5], [6]
    6S/R + 3.5RTT   <=  [3, 4, 5, 6], []
    3S/R + 4RTT     =>  rcv pkt 3, send ACK 3
    4S/R + 4RTT     =>  rcv pkt 4, send ACK 4
    5S/R + 4RTT     =>  rcv pkt 5, send ACK 5
    6S/R + 4RTT     =>  rcv pkt 6, send ACK 6
    3S/R + 4.5RTT   =>  rcv ACK 3, cwnd = 5, [4, 5, 6], [7, 8]
    cwnd will grow to 8 with 8 packets remaining, all will be sent in a row
    7 will be sent at 4S/R + 4.5RTT, 14 will be sent at 11S/R + 4.5RTT and received at 11S/R + 5RTT
c.  S/R > RTT
    0:      =>  send ACK    
    0.5RTT: <=  rcv ACK, send SYNACK
    1RTT:   =>  rcv SYNACK, send request
    1.5RTT: <=  rcv request, cwnd = 1, [], [0]
    S/R + 1.5RTT    <=  [0], []
    S/R + 2.0RTT    =>  rcv pkt 0, send ACK 0
    S/R + 2.5RTT    <=  rcv ACK 0, cwnd = 2, [], [1, 2]
    2S/R + 2.5RTT   <=  [1], [2]
    server at full speed from now on
    pkt 1 is sent at 2S/R + 2.5RTT, pkt 14 will be sent at 15S/R + 2.5RTT and received at 15S/R + 3RTT

Assignment
./network/transport/gbn
log of a test run, sending u32 numbers from 0 to 19
rtt: 100ms, loss rate: 10%, corrupt rate: 10%, sending window: 4, sending timeout: 1000ms
[2019-09-30T14:05:43Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 0]
[2019-09-30T14:05:43Z INFO  gbn::protocol] Send packet: Packet { sn = 0, data = [0, 0, 0, 0] }
[2019-09-30T14:05:43Z INFO  gbn::channel] Channel lost packet: Packet { sn = 0, data = [0, 0, 0, 0] }
[2019-09-30T14:05:43Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 1]
[2019-09-30T14:05:43Z INFO  gbn::protocol] Send packet: Packet { sn = 1, data = [0, 0, 0, 1] }
[2019-09-30T14:05:43Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 2]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Send packet: Packet { sn = 2, data = [0, 0, 0, 2] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 3]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Send packet: Packet { sn = 3, data = [0, 0, 0, 3] }
[2019-09-30T14:05:44Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 3, data = [0, 0, 0, 3] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 4]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 5]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 6]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 1, data = [0, 0, 0, 1] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 7]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver send ACK 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 8]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 9]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 10]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 11]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 12]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 13]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 14]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 15]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 16]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 17]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 18]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 19]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 2, data = [0, 0, 0, 2] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver send ACK 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver send ACK 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Sender received packet: ACK { sn = 4294967295 }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Duplicated ACK to packet 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Sender received packet: ACK { sn = 4294967295 }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Duplicated ACK to packet 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Sender received packet: ACK { sn = 4294967295 }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Duplicated ACK to packet 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Sender timed out, retransmitting unacknowledged packets
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmitting packet 0
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmitting packet 1
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 0, data = [0, 0, 0, 0] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmitting packet 2
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver send ACK 0
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmitting packet 3
[2019-09-30T14:05:44Z INFO  gbn::channel] Channel lost packet: ACK { sn = 0 }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmission done, restart sender timer
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 1, data = [0, 0, 0, 1] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 1
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 2, data = [0, 0, 0, 2] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 2
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 3, data = [0, 0, 0, 3] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 3
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 1 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 0
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 1
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 4, data = [0, 0, 0, 4] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 5, data = [0, 0, 0, 5] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 2 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 2
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 6, data = [0, 0, 0, 6] }
[2019-09-30T14:05:45Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 6, data = [0, 0, 0, 6] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 3 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 3
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 7, data = [0, 0, 0, 7] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 4, data = [0, 0, 0, 4] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 4
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 5, data = [0, 0, 0, 5] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::channel] Channel lost packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 7, data = [0, 0, 0, 7] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 4 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 4
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 8, data = [0, 0, 0, 8] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 9, data = [0, 0, 0, 9] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 8, data = [0, 0, 0, 8] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 9, data = [0, 0, 0, 9] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Sender timed out, retransmitting unacknowledged packets
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmitting packet 6
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmitting packet 7
[2019-09-30T14:05:46Z INFO  gbn::channel] Channel lost packet: Packet { sn = 6, data = [0, 0, 0, 6] }
[2019-09-30T14:05:46Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 7, data = [0, 0, 0, 7] }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmitting packet 8
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmitting packet 9
[2019-09-30T14:05:46Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 8, data = [0, 0, 0, 8] }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmission done, restart sender timer
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 9, data = [0, 0, 0, 9] }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender timed out, retransmitting unacknowledged packets
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmitting packet 6
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmitting packet 7
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmitting packet 8
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmitting packet 9
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmission done, restart sender timer
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 6, data = [0, 0, 0, 6] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 6
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 7, data = [0, 0, 0, 7] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 7
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 8, data = [0, 0, 0, 8] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 8
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 9, data = [0, 0, 0, 9] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 9
[2019-09-30T14:05:47Z INFO  gbn::channel] Channel lost packet: ACK { sn = 9 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 6 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 6
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 10, data = [0, 0, 0, 10] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 7 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 7
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 11, data = [0, 0, 0, 11] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 8 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 8
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 12, data = [0, 0, 0, 12] }
[2019-09-30T14:05:47Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 12, data = [0, 0, 0, 12] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 10, data = [0, 0, 0, 10] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 10
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 11, data = [0, 0, 0, 11] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 10 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 9
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 10
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 13, data = [0, 0, 0, 13] }
[2019-09-30T14:05:47Z INFO  gbn::channel] Channel lost packet: Packet { sn = 13, data = [0, 0, 0, 13] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 14, data = [0, 0, 0, 14] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 11 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 15, data = [0, 0, 0, 15] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 11 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Duplicated ACK to packet 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 14, data = [0, 0, 0, 14] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 15, data = [0, 0, 0, 15] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 11 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Duplicated ACK to packet 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 11 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Duplicated ACK to packet 11
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender timed out, retransmitting unacknowledged packets
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmitting packet 12
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmitting packet 13
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmitting packet 14
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmitting packet 15
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmission done, restart sender timer
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 12, data = [0, 0, 0, 12] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 12
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 13, data = [0, 0, 0, 13] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 13
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 14, data = [0, 0, 0, 14] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 14
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 15, data = [0, 0, 0, 15] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 15
[2019-09-30T14:05:48Z INFO  gbn::channel] Channel lost packet: ACK { sn = 15 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 12 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 12
[2019-09-30T14:05:48Z INFO  gbn::protocol] Send packet: Packet { sn = 16, data = [0, 0, 0, 16] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 13 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 13
[2019-09-30T14:05:48Z INFO  gbn::protocol] Send packet: Packet { sn = 17, data = [0, 0, 0, 17] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 14 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 14
[2019-09-30T14:05:48Z INFO  gbn::protocol] Send packet: Packet { sn = 18, data = [0, 0, 0, 18] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 16, data = [0, 0, 0, 16] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 16
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 17, data = [0, 0, 0, 17] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 17
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 18, data = [0, 0, 0, 18] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 18
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 16 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 15
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 16
[2019-09-30T14:05:48Z INFO  gbn::protocol] Send packet: Packet { sn = 19, data = [0, 0, 0, 19] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 17 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 17
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 18 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 18
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 19, data = [0, 0, 0, 19] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 19
[2019-09-30T14:05:48Z INFO  gbn::protocol] Channel disconnected / terminate signal received, tear down sender
[2019-09-30T14:05:48Z INFO  gbn::channel] Channel disconnected
[2019-09-30T14:05:48Z INFO  gbn::protocol] Terminate signal received, tear down receiver
[2019-09-30T14:05:48Z INFO  gbn::channel] Channel disconnected
[2019-09-30T14:05:48Z WARN  gbn::channel] Send terminate but the receiver was already dropped

4.1
a.  in favor of datagram. a single point of failure usually will break a whole VC which must then be reestablished
    according to lengthy and complicated protocol, while datagram architecture may detect the point of failure and 
    route packets through an other router
b.  in favor of VC, one may even argue that any protocol that reserves resource on router for a particular connection
    is indeed VC
c.  VC will have more overhead, a VC have to be established somehow before transmitting packets, on the other hand
    datagram protocol can send packets from the start

4.2
a.  2^8 = 256
b.  impossible, all link along the path is assigned the same VC number, if < 256 VCs are in progress there must be free
    VC numbers
c.  for a router B on the path, let A be the previous router on the path and be C the succeeding router on the path 
    B is informed about the VC number x along A -> B link of this particular VC 
    B chooses an arbitrary unused VC number y on the link B -> C, informs C about this number
    B adds an entry that sends packets from (the corresponding interface of) A with VC number x to C with VC number y

4.3
VC:
    incoming interface, incoming VC number, outgoing interface, outgoing VC number
datagram:
    destination IP, outgoing interface

4.4
a.  H3 -> 3
b.  no, datagram forwarding table is independent to source IP
c.  1, <VC number H1A>, 3, <VC number AB>
    2, <VC number H2A>, 4, <VC number AC>
d.  B:
        1, <VC number AB>, 2, <VC number BD>
    C:
        1, <VC number AC>, 2, <VC number CD>
    D:
        1, <VC number BD>, 3, <VC number DH3-1>
        2, <VC number CD>, 3, <VC number DH3-2>

4.5
a.  no VC number can be assigned, all VC number is occupied in at least one of the links
b.  2^4 = 16

4.6
in a connection-oriented service, there may not be an actual underlying connection in network-layer, e.g. TCP can be
built on IP protocol and datagram, while in a connection service like VC there is a connection in network-layer

4.7
a.  no, only one packet may enter a shared bus at a time
b.  yes as described in section 4.3.2 
c.  no as described in section 4.3.2, only one packet can be sent through a bus, the second has to wait

4.8
a.  (n-1)D, where D = t_read + t_process + t_write for a single packet
    all n - 1 packets before the last one must be read, processed and written to the output bus until the final packet 
    may be forwarded
b.  (n-1)D, where D = t_prepend_tag + t_bus_read + t_output
    almost the same to memory switch, t_bus_read and t_prepend_tag may be significantly faster than t_read and t_process
c.  0 in most optimistic case, all packets can be sent to their destination concurrently

4.9
minimal:
    ([x], [xy], [zy])
    ([], [x], [z])
    ([], [], [])
worst:
    ([x], [xy], [zy])
    ([], [xy], [y])     // input 2 blocking on x
    ([], [y], [])
    ([], [], [])

4.10
a.  224.0.0.0/10    0
    224.64.0.0/16   1
    224.65.0.0/16   2
    224.32.0.0/10   2
    otherwise       3
b.  11001000 10010001 01010001 01010101
    no prefix matches, otherwise -> interface 3
    11100001 01000000 11000011 00111100
    matches 224.32.0.0/10, interface 2
    11100001 10000000 00010001 01110111
    no prefix matches, otherwise -> interface 3

4.11
00000000 - 00111111     0
01000000 - 01011111     1
01100000 - 10111111     2
11000000 - 11111111     3

4.12
10000000 - 10111111     1
11000000 - 11011111     0
11100000 - 11111111     2
otherwise               3

4.13
223.1.17.0/28   Subnet 3    // 16 IPs
223.1.17.0/25   Subnet 1    // 128 - 16 = 112 IPs
223.1.17.128/25 Subnet 2    // 128 IPs

4.14
200.23.16.0/21  0
200.23.24.0/24  1
200.23.24.0/21  2
otherwise       3

4.15
already in decimal notation

4.16
128.119.40.128 is itself an IP can be assigned to this network
128.119.40.64/28
128.119.40.80/28
128.119.40.96/28
128.119.40.112/28

4.17
214.97.254.0/31     Subnet D    // 2 IPs
214.97.254.2/31     Subnet E    // 2 IPs
214.97.254.4/31     Subnet F    // 2 IPs
214.97.254.0/25     Subnet B    // 128 - 2 * 3 = 122 IPs
214.97.254.128/25   Subnet C    // 128 IPs
214.97.255.0/24     Subnet A    // 256 IPs

4.18
Wellesley College (https://www.wellesley.edu/)
    107.20.0.0/14 (AWS)
    Ashburn,
    Virginia,
    United States,
    North America
Williams College (https://www.williams.edu/)
    104.16.0.0/12 (Cloudflare cloud)
    United States,
    North America	
Vassar College (https://www.vassar.edu/)
    143.229.0.0/16 (the only one not hosted on cloud services)
    Poughkeepsie,
    New York,
    United States,
    North America	
Both services seems cannot provide precise location of an IP address, only for a range (CIDR) of IPs

4.19
4 fragments are generated
assuming no option fields
ID      Length      Offset      Flag
422     680         0           0
422     680         85          0
422     680         170         0
422     360         255         1

4.20
if the file is transferred by UDP and link is reliable:
    ceil(5e6 / (1500 - IP_HEADER - UDP_HEADER)) = 3397
if the file is transferred by TCP:
    no idea, ACK packets may be nondeterministic

4.21
a.  192.168.0.0     router
    192.168.0.1-3   3 hosts
b.  24.34.112.235, <PORT_MAPPED_A1>    192.168.1, <PORT_A1>
    24.34.112.235, <PORT_MAPPED_A2>    192.168.1, <PORT_A2>
    24.34.112.235, <PORT_MAPPED_B1>    192.168.2, <PORT_B1>
    24.34.112.235, <PORT_MAPPED_B2>    192.168.2, <PORT_B2>
    24.34.112.235, <PORT_MAPPED_C1>    192.168.3, <PORT_C1>
    24.34.112.235, <PORT_MAPPED_C2>    192.168.3, <PORT_C2>
    PORT_MAPPED_* must be distinct but PORT_A1 may be equal to PORT_B1

4.22
a.  assume packet is frequently sent that all hosts send at least one packet 
    meantime packets are sparse enough that there's duplicated IDs 
    record each ID, group into consecutive ranges, count the number of ranges
b.  it's now indistinguishable between a single host generating a huge number of packets
    and many hosts generating a few packets each

4.23
it may be possible with reverse connection and a server in the middle
both hosts connect to the server's open ports, and the server tunnels packets between them

4.24
./network/network/problems
yzwxvu
yzwxu
yzwvxu
yzwvu
yzwu
yxwvu
yxwu
yxvwu
yxvu
yxu
ywxvu
ywxu
ywvxu
ywvu
ywu

4.25
./network/network/problems
x ~> z
    xyz
    xywz
    xwz
    xwyz
    xvwz
    xvwyz
    xvuwz
    xvuwyz
    xuwz
    xuwyz
    xuvwz
    xuvwyz
z ~> u
    zyxwvu
    zyxwu
    zyxvwu
    zyxvu
    zyxu
    zywxvu
    zywxu
    zywvxu
    zywvu
    zywu
    zwyxvu
    zwyxu
    zwxvu
    zwxu
    zwvxu
    zwvu
    zwu
z ~> w
    zyxw
    zyxvw
    zyxvuw
    zyxuw
    zyxuvw
    zyw
    zw

4.26
./network/network/problems
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
           ∞           ∞         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x

4.27
./network/network/problems
Shortest paths from t
   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(x),p(x)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
         2,t         4,t           ∞           ∞         7,t           ∞
         2,t         4,t         5,u           ∞         7,t           ∞
         2,t         4,t         5,u         7,v         7,t           ∞
         2,t         4,t         5,u         7,v         7,t           ∞
         2,t         4,t         5,u         7,v         7,t        15,x
         2,t         4,t         5,u         7,v         7,t        15,x
         2,t         4,t         5,u         7,v         7,t        15,x
Shortest paths from u
   D(t),p(t)   D(v),p(v)   D(w),p(w)   D(x),p(x)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
         2,u         3,u         3,u           ∞           ∞           ∞
         2,u         3,u         3,u           ∞         9,t           ∞
         2,u         3,u         3,u         6,v         9,t           ∞
         2,u         3,u         3,u         6,v         9,t           ∞
         2,u         3,u         3,u         6,v         9,t        14,x
         2,u         3,u         3,u         6,v         9,t        14,x
         2,u         3,u         3,u         6,v         9,t        14,x
Shortest paths from v
   D(t),p(t)   D(u),p(u)   D(w),p(w)   D(x),p(x)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
         4,v         3,v         4,v         3,v         8,v           ∞
         4,v         3,v         4,v         3,v         8,v           ∞
         4,v         3,v         4,v         3,v         8,v        11,x
         4,v         3,v         4,v         3,v         8,v        11,x
         4,v         3,v         4,v         3,v         8,v        11,x
         4,v         3,v         4,v         3,v         8,v        11,x
         4,v         3,v         4,v         3,v         8,v        11,x
Shortest paths from w
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(x),p(x)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
           ∞         3,w         4,w         6,w           ∞           ∞
         5,u         3,w         4,w         6,w           ∞           ∞
         5,u         3,w         4,w         6,w        12,v           ∞
         5,u         3,w         4,w         6,w        12,v           ∞
         5,u         3,w         4,w         6,w        12,v        14,x
         5,u         3,w         4,w         6,w        12,v        14,x
         5,u         3,w         4,w         6,w        12,v        14,x
Shortest paths from x
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
           ∞           ∞         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
Shortest paths from y
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(x),p(x)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
         7,y           ∞         8,y           ∞         6,y        12,y
         7,y           ∞         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
Shortest paths from z
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(x),p(x)   D(y),p(y)
           ∞           ∞           ∞           ∞           ∞           ∞
           ∞           ∞           ∞           ∞         8,z        12,z
           ∞           ∞        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z

4.28
// assume sync update
./network/network/problems
init:
       u   v   x   y   z
   u   0   1   ∞   2   ∞
   v   1   0   3   ∞   6
   x   ∞   3   0   3   2
   y   2   ∞   3   0   ∞
   z   ∞   6   2   ∞   0
first iter:
       u   v   x   y   z
   u   0   1   4   2   7
   v   1   0   3   3   5
   x   4   3   0   3   2
   y   2   3   3   0   5
   z   7   5   2   5   0
second iter:
       u   v   x   y   z
   u   0   1   4   2   6
   v   1   0   3   3   5
   x   4   3   0   3   2
   y   2   3   3   0   5
   z   6   5   2   5   0

4.29
// thanks solutions manual
invariant: 
    after k iteration, DV of a node contains shortest path cost to other nodes consist of at most k + 1 links
initialization:
    k = 0, all nodes know the link cost to (path cost of length 1) their neighbors
    as link cost is non-negative, that's the shortest path to these neighbors
maintenance:
    at the start of iteration k, all nodes know the shortest path cost to nodes with length <= k
    for a specific node A, a path of length <= k + 1 must first traverse one of one of A's neighbor then 
    take the shortest path of length <= k from its neighbor to the destination
    in iteration k, all of A's neighbors pass message of shortest path of length <= k to A
    A hence calculates shortest paths with length <= k + 1 with Bellman-Ford equation
the DVs will converge after at most d - 1 iterations, where d is the longest simple path in the graph

4.30
a.  w   y   u
    2   4   7
b.  c(x, w): 2 -> 3
c.  c(x, y): 5 -> 6

4.31
./network/network/problems
init:
       x   y   z
   x   0   3   4
   y   3   0   6
   z   4   6   0
no update

4.32
unlike increasing link cost, decreasing link cost will not cause routing loop
let the link be (u, v), the DV of u and v will be updated immediately to the correct result since
any simple path from u that traverses (u, v) must visit v first, otherwise the path is not simple
the remaining path from v cannot traverse (u, v) again in any direction
the old DV of v (which u is already informed about) will suffice
the information of the updated c(u, v) will then be propagated to other nodes
in turn of their number of hops from u or v
connecting two nodes is equivalent to decreasing the link cost from infinity to a finite number

4.33
can be derived from proof in 4.29
non-increasing: minimum path cost of length <= k + 1 cannot exceed minimum path cost of length <= k by subset relation
stable: no simple path can have length greater than d, after d iterations the costs will no longer change

4.34
a.  w to z: c(w, x) = 5, w to y: c(w, x) = None
    y to z: c(y, x) = 4, y to w: c(y, x) = 4
    z to w: c(z, x) = None, z to y: c(z, x) = 6
b.  count-to-infinity will still happen between y and z
    z is unaware of the next hop of w being y so will inform y the already out-of-date information of path costs 
    in a 3-step loop:
        y update c(y, x) = c(z, x) + c(y, z) = 9, to w: c(y, x) = 9, to z: c(y, x) = None
        w update c(w, x) = c(y, x) + c(w, y) = 10, to y: c(w, x) = None, to z: c(w, x) = 10
        z update c(z, x) = c(w, x) + c(z, w) = 11, to w: c(z, x) = None, to y: c(z, x) = 11
    at iteration 33, c(z, y) + c(y, x) = 51, z will route via (z, x) instead, DV will stabilize next iteration
c.  set c(y, z) >= 60 - 6 = 54
    y will choose to route via (y, x) in the first iteration, no routing loop will be formed

4.35
by AS-PATH attributes
if ASN of a router is included in AS-PATH of an advertisement it will drop it

4.36
no, it's affected by the import policy of the AS

4.37
a.  eBGP from 4c
b.  iBGP from 3b
c.  eBGP from 3a
d.  iBGP

4.38
// assume no local preference
a.  I1, AS-PATH is the same, NEXT-HOP distance to 3a -> 1c interface in RIP is measured by number of hops, 
    and I1 points to the path of minimum length
b.  I2, AS-PATHs have the same length, NEXT-HOP distance via I2 to 2a is shorter than via I1 to 3a
c.  I1, AS-PATH via AS4 -> AS3 is shorter than via AS4 -> AS5 -> AS2

4.39
in B:   
    the administrator of B may adjust the LOCAL_PREF attribute of routers in B to send packets with destination D
    via its west coast exit
in C:
    the administrator of C may adjust the MULTI_EXIT_DISC attribute of BGP messages from D, thus the routers in B may
    prefer sending through the east coast entry of C all other factors being equal

4.40
// assume providers do not advertise unnecessary paths
view of W:
    no link between B and C, otherwise B or C provides free rides to another
view of Y:
    no link between B and C, B will not shoulder traffic from C to X, the same below
    no link between B and X
    no link between A and B

4.41
bittorrent, X receives segments of a data from W via B, then send it through another TCP link via C to Y
effectively routes the segment on the path W -> A -> B -> X -> C -> Y

4.42
A to B: A-W and A-V 
A to C: A-V
C receives: B-A-W, B-A-V, A-V

4.43
Y and Z are in a peering agreement, Z will advertise all its paths to Y
Y and X are in a peering agreement, Y will advertise all its paths, including paths via Z, to X
there's nothing Z can do to prevent X routes its traffic to Z

4.44
./network/network/problems
graph {
    0 [label="t"]
    1 [label="u"]
    2 [label="v"]
    3 [label="w"]
    4 [label="x"]
    5 [label="y"]
    6 [label="z"]
    0 -- 1 [label="2"]
    2 -- 4 [label="3"]
    1 -- 2 [label="3"]
    1 -- 3 [label="3"]
    4 -- 5 [label="6"]
    4 -- 6 [label="8"]
}
by documentation (https://docs.rs/petgraph/0.4.13/petgraph/algo/fn.min_spanning_tree.html) 
it's calculated by Kruskal's algorithm

4.45
unicast:
    each packet traverses 5 links, 32 * 5 = 160 cost
broadcast:
    each link is traversed once
    2 + 4 + 8 + 16 + 32 = 64 - 2 = 62 cost
a long simple path of routers with all receivers attached to the last router 
if there are n receivers, each packet will be sent n times through the path with unicast
but only once with broadcast

4.46
B: // B will always receive packet from A
C: A -> C
D: A -> C -> E -> D

4.47
path not in shortest-path tree:
    (E, F), (E, D), (E, C), (C, A), {(D, B) or (C, B)}, (D, G)

4.48
./network/network/problems
shortest path tree:
    (z, x), (z, y), (x, v), (x, w), (v, t), (v, u)

4.49
./network/network/problems
p(A) = Some('C')
p(B) = Some('C')
p(C) = None
p(D) = Some('E')
p(E) = Some('C')
p(F) = Some('C')
p(G) = Some('D')
it's a shortest path tree, in general may not be the minimum spanning tree

4.50
./network/network/problems
p(t) = Some('v')
p(u) = Some('v')
p(v) = None
p(w) = Some('v')
p(x) = Some('v')
p(y) = Some('v')
p(z) = Some('x')

4.51
a 4-node graph:
    c(A, B) = 2, c(A, C) = 2, c(A, D) = 2, c(B, C) = 1, c(C, D) = 1
{(A, B), (A, C), (A, D)} is a shortest path tree with total link cost 6
a minimum spanning tree {(A, C), (B, C), (C, D)} has total link cost 4

4.52
each time step a node receiving a packet will duplicate and send the packet to two neighbors
in time step t, 2^(t - 1) packets are transmitted

4.53
with transport or application layer information embedded in the data section of network layer packets

4.54
the description of multicast in this chapter is too vague to design anything on it
if the multicast protocol permits any participant to be a sender
each host may broadcast it's identity to the multicast group 
otherwise the only sender may broadcast its IP in the multicast group and receivers can send back their identity 
through out-of-band unicast channel

4.55
according to RFC5771, IPv4 multicast addresses ranges from 224.0.0.0 to 239.255.255.255, 265302000 in total
2 group collision probability is 1/265302000
1000 group collision probability is, by approximation,
    1 - e^(-k(k - 1) / 2N)
    = 0.00188098874

Assignment 5
./network/network/icmp-ping

5.1
1110 1
0110 0
1001 0
1101 1
1100 0

5.2
a single bit frame with 2-d even parity scheme:
    1 0
    1 0
assume one-bit error, the error must be the column parity bit 
(switch any other bit and the frame would  still be invalid)
or both the data bit and the column parity bit is wrong but it's indistinguishable from the single bit error

5.3
./network/link/problems
11110011 11011111

5.4
./network/link/problems
a.  11100110 11100001
b.  10100000 10011011
c.  11111111 11111010

5.5
// assume 4-bit remainder, according to most textbooks & wikipedia remainder has order one lower than the generator
// (i.e. one bit shorter than the generator)
// see Computer Networks: A Systems Approach, Larry L. Peterson & Bruce S. Davie, 5e
// also https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks
./network/link/problems
0100

5.6
./network/link/problems
a.  0000
b.  1111
c.  1001

5.7
a.  let D * 2^r + R be the frame, it must have D * 2^r + R = nG
    if the ith bit is altered by the channel, the frame received is D * 2^r + R + 2^i = nG + 2^i
    with G = 1001, there's no 2^i = nG for any n:
        for any n, let the lowest 1-bit in n be 2^p, the highest 1-bit in n be 2^q
        p <= q, the lowest 1-bit in nG is 2^p * 1 = 2^p, the highest 1-bit in nG is 2^q * 1000 = 2^(q + 3)
        no other bits in n can override these two 1-bits, nG contains at least 2 1-bits, nG != 2^i
    // polynomial remainder is unique over GF(p^m) when p is prime, GF(p^m) is the Galois Field, proof not given
    there must be unique (m, R') pair where 2^i = mG + R' and R is a polynomial lower than G
    nG + 2^i = (n + m)G + R', D * 2^r + R + 2^i is not divisible by G, one bit error will always be detected
b.  again the frame received is D * 2^r + R + E = nG + E, where E has odd number of 1-bits
    with G = 1001, one step of long division (XOR) will not change the parity of the remaining data:
        // ./network/link/problems
        1000 XOR 1001 = 0001
        1001 XOR 1001 = 0000
        1010 XOR 1001 = 0011
        1011 XOR 1001 = 0010
        1100 XOR 1001 = 0101
        1101 XOR 1001 = 0100
        1110 XOR 1001 = 0111
        1111 XOR 1001 = 0110
    but the order of the data is reduced by at least 1
    also any E with order <= 3 and odd number of 1-bits is not divisible by 1001
    therefore E and D * 2^r + R + E is not divisible by 1001, odd number of bit error will always be detected

5.8
a.  dNp(1-p)^(N-1)/dp 
    = N(1-p)^(N-1) - N(N-1)p(1-p)^(N-2)
    = N(1 - p - (N-1)p)(1-p)^(N-2)
    = N(1 - p - Np + p)(1-p)^(N-2)
    = N(1-Np)(1-p)^(N-2) = 0
    p = 1/N
b.  lim(N -> ∞)Np(1-p)^(N-1)
    = lim(N -> ∞)(1-1/N)^(N-1)
    = lim(N -> ∞)(1-1/N)^N * 1/(1 - 1/N)
    = 1/e

5.9
// skipped, similar to 5.8

5.10
a.  throughput: pa(1 - pb) frame / slot
    efficiency: pa(1 - pb) + pb(1 - pa)
b.  throughput of A:  pa(1 - pb) = 2pb(1 - pb)
    throughput of B:  pb(1 - pa) = pb(1 - 2pb)
    not always twice as large, only when 
        pa(1 - pb) = 2pb(1 - pa)
        pa - papb = 2pb - 2papb
        papb = 2pb - pa
        pa = (2pb - pa)/pb
c.  throughput of A:    2p(1 - p)^(N-1) frame / slot 
    throughput of other: p(1 - p)^(N-2)(1 - 2p) frame / slot

5.11
a.  (1 - p(1 - p)^4)^4 * p(1 - p)^4
b.  4p(1 - p)^4
c.  (1 - 4p(1 - p)^4)^2 * 4p(1 - p)^4
d.  4p(1 - p)^4 frame / slot

5.12
N = 15
⡁ ⢀⠎⠉⢆                                                        0.4
⠄ ⢸  ⠘⡄
⠂ ⡇   ⢱
⡁⢀⠇   ⠈⢆
⠄⢸      ⡇
⠂⡇      ⢸
⣱⠁       ⢇
⢼⢀⢤      ⠘⡄
⢺⠃ ⢇      ⠘⡄
⣹  ⠘⡄      ⠸⡀
⡿   ⠘⡄      ⢣
⡇    ⢱       ⠑⡄
⡇     ⢣       ⠈⢆
⡇      ⠑⢄       ⠉⠢⡀
⡇        ⠑⠤⢄⣀     ⠈⠒⠢⠤⣀⣀⣀
⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁ 0.0
0.0                                                      1.0
N = 25
⡁⢀⠞⡄                                                          0.4
⠄⡸ ⢣
⠂⡇ ⠸⡀
⣹   ⢣
⢼   ⠈⡆
⢺    ⢇
⣹    ⢸
⣜⢄    ⡇
⣿ ⡇   ⢱
⡇ ⢱   ⠘⡄
⡇ ⠸⡀   ⠘⡄
⡇  ⡇    ⢱
⡇  ⠸⡀    ⢣
⡇   ⠑⡄    ⠑⢄
⡇    ⠈⠢⣀⡀   ⠑⠤⢄⣀⣀
⠁⠈ ⠁⠈ ⠁⠈⠈⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁ 0.0
0.0                                                      1.0
N = 35
⡁⡔⡇                                                           0.4
⢼ ⢸
⢺ ⠸⡀
⣹  ⡇
⢼  ⢇
⡎  ⢸
⡇  ⠸⡀
⡇⡀  ⢇
⡏⢇  ⠘⡄
⡇⠸⡀  ⢇
⡇ ⡇  ⢸
⡇ ⢣   ⡇
⡇ ⠸⡀  ⠸⡀
⡇  ⢇   ⠑⢄
⡇  ⠈⠒⢄  ⠈⠢⠤⣀⡀
⠁⠈ ⠁⠈ ⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁ 0.0
0.0                                                      1.0

5.13
Q / (Q/R + d_poll)

5.14
// assume the square boxes are switches
a.  Host A: 192.168.1.1
    Host B: 192.168.1.2
    R1 -> Subnet 1: 192.168.1.0
    R1 -> Subnet 2: 192.168.2.0
    R2 -> Subnet 2: 192.168.2.1
    Host C: 192.168.2.2
    Host D: 192.168.2.3
    R2 -> Subnet 3: 192.168.3.0
    Host E: 192.168.3.1
    Host F: 192.168.3.2
b.  Host A: AA-AA-AA-AA-AA-AA
    Host B: BB-BB-BB-BB-BB-BB
    R1 -> Subnet 1: 00-00-00-00-00-11
    R1 -> Subnet 2: 00-00-00-00-00-12
    R2 -> Subnet 2: 00-00-00-00-00-22
    Host C: CC-CC-CC-CC-CC-CC
    Host D: DD-DD-DD-DD-DD-DD
    R2 -> Subnet 3: 00-00-00-00-00-23
    Host E: EE-EE-EE-EE-EE-EE
    Host F: FF-FF-FF-FF-FF-FF
c.  1.  Host E looks for entry for IP address of Host B in its forward table, finds the interface of R2 in Subnet 3
    2.  Host E looks for 192.168.3.0 in its ARP table, finds 00-00-00-00-00-23
    3.  Host E insert IP datagram in a frame with destination MAC above to the link
    4.  R2 receives the frame, extract datagram and destination IP, looks for 192.168.1.2 in its forwarding table
    repeat between R2 -> R1 and R1 -> B
d.  1.  same to above
    2.  Host E looks for 192.168.3.0 in its ARP table and find nothing
    3.  Host E sends ARP query for 192.168.3.0 to FF-FF-FF-FF-FF-FF from EE-EE-EE-EE-EE-EE
    4.  R2 receives the query, find out 192.168.3.0 is the IP address of its interface
        sends the IP and MAC address (00-00-00-00-00-23) of its interface back to EE-EE-EE-EE-EE-EE
    5.  Host E updates its ARP table upon receiving the ARP response
    same to part c from now on

5.15
a.  the switch between E and F is transparent to them and R1 will not response to ARP queries from E for the IP of F
    ARP table of Host E should have an entry (<IP of F>, <MAC of F>) in it after ARP query
    source IP: <IP of Host E>
    source MAC: <MAC of Host E>
    destination IP: <IP of Host F>
    destination MAC: <MAC of Host F>
b.  no, Host E will perform an ARP query to find next-hop of B's IP in its forwarding table
    in this case R1's interface to Subnet 3
    source IP: <IP of Host E>
    source MAC: <MAC of Host E>
    destination IP: <IP of Host B>
    destination MAC: <MAC of R1 -> Subnet 3 interface>
c.  S1 will find a match of B's MAC address and forward the frame only to the channel between itself and B
    also S1 will update is ARP table with the MAC and IP address of A
    R1 will not receive the frame containing this message
    B will not send ARP query for A's MAC address, the source of the query is contained in the query
    once S1 receives the ARP response, as it now has the MAC and IP address of A in its ARP table
    it will forward the frame to the channel between itself and A

5.16
a.  the same if the switch between E and F has ARP entry of both E and F
b.  now E and B are in the same subnet, E will perform an ARP query to find B's MAC address
    source IP: <IP of Host E>
    source MAC: <MAC of Host E>
    destination IP: <IP of Host B>
    destination MAC: <MAC of Host B>
c.  the same

5.17
10Mbps: 100 * 512 / (10 * 1024^2) = 0.0048828125s
10Mbps: 100 * 512 / (100 * 1024^2) = 0.00048828125s

5.18
the channel would appear to B to be idle before t = 325
if A has less than 325 bits to transmit at t = 325 and B started transmission at t = 324
A will detect the collision only after finish transmitting
at worst case B's signal reach A at t = 325 - 1 + 325 = 649

5.19
the retransmission may collide again if their value of K is close enough
the channel would be idle again at t = 245 + 245 = 490
then A immediately starts the retransmission at t = 490
B schedules the retransmission to begin at t = 490 + 512 = 1002
at t = 490 + 245 = 735 A's signal reaches B
minimum frame size is 576 bits > 1002 - 735 = 267 bits, B will abort retransmission and wait for the channel to be idle

5.20
a.  p_success = Np(1-p)^(N-1)
    x = E[X], X ~ Geometric(p_success) 
    = (1 - p_success) / p_success
    = (1 - Np(1-p)^(N-1)) / Np(1-p)^(N-1)
    = 1/Np(1-p)^(N-1) - 1
b.  dx/dp = (Np - 1) / (Np^2(1-p)^N) = 0
    p = 1/N
c.  x = 1/Np(1-p)^(N-1) - 1
    = 1/(1-1/N)^(N-1) - 1
    lim(N -> ∞)x = e - 1
    lim(N -> ∞)(k / (k + x)) = k / (k + e - 1)
d.  lim(k -> ∞)(k / (k + e - 1)) = 1

5.21
i.  src IP: <IP of A>
    src MAC: <MAC of A>
    dest IP: <IP of F>
    dest MAC: <IP of R1>
ii. src IP: <IP of A>
    src MAC: <MAC of R1>
    dest IP: <IP of F>
    dest MAC: <IP of R2>
iii.src IP: <IP of A>
    src MAC: <MAC of R2>
    dest IP: <IP of F>
    dest MAC: <MAC of F>

5.22
i.  src IP: <IP of A>
    src MAC: <MAC of A>
    dest IP: <IP of F>
    dest MAC: <MAC of R2>
ii. src IP: <IP of A>
    src MAC: <MAC of A>
    dest IP: <IP of F>
    dest MAC: <IP of R2>
iii.src IP: <IP of A>
    src MAC: <MAC of R2>
    dest IP: <IP of F>
    dest MAC: <MAC of F>

5.23
// assume all links are full-duplex
1100Mbps, 200Mbps between two servers (each downloading the other at rate 100Mbps)
900Mbps among hosts: among each department, each host downloads from other 2 at rate 50Mbps per host

5.24
500Mbps, 200Mbps between two servers as before
300Mbps among hosts: among each department, only one download of 100Mbps can be achieved at a time

5.25
the entire network is a single bus with maximum throughput 100Mbps

5.26
i.  B -> E
    + B_IP, B_MAC
    broadcasted to all links except S -> B
ii. E -> B
    + E_IP, E_MAC
    only send to S -> B link
iii.A -> B
    + A_IP, A_MAC
    only send to S -> B link
iv. B -> A 
    only send to S -> A link

5.27
a.  8P / (128 * 1024)
b.  L = 1500 bytes, P = L - 5 = 1495 bytes
    1495 * 8 / (128 * 1024) = 0.09124755859375s
    L = 50 bytes, P = L - 5 = 45 bytes
    45 * 8 / (128 * 1024) = 0.00274658203125s
c.  Ethernet header is 6 + 6 + 2 + 4 + 8 = 26 bytes
    (1500 + 26) * 8 / (622 * 1024 ^ 2) = 0.0000187s
    (50 + 26) * 8 / (622 * 1024 ^ 2) = 9.322e-7s
d.  when transmission delay is negligible, smaller packet can greatly reduce total delay 

5.28
1.  EE host send a frame:
        src (<IP of EE>, <MAC of EE>)
        dest (<IP of CS>, <MAC of R>)
    to the VLAN switch at one of port 2-8
2.  VLAN switch (with a complete ARP table) forwards the frame: 
        src (<IP of EE>, <MAC of EE>)
        dest (<IP of CS>, <MAC of R>)
    to port 1
3.  R receives the frame and send a frame:
        src (<IP of EE>, <MAC of R>)
        dest (<IP of CS>, <MAC of CS>)
    back to to port 1
4.  VLAN switch forwards the frame:
        src (<IP of EE>, <MAC of R>)
        dest (<IP of CS>, <MAC of CS>)
    to one of port 9-15
5.  CS host receives the frame

5.29
R5:
    _   0   A   0
R6:
    _   1   A   0
R4:
    0   10  A   0
    1   8   A   1
    _   12  D   0

5.30
R5:
    _   2   D   0
R6:
    _   3   D   0
R4:
    3   12  D   0
    2   2   D   1
R2:
    2   2   D   0
R1:
    2   12  D   1

5.31
1.  PC sends a DHCP request in UDP segment
        src: (68, <0.0.0.0>, <PC_MAC>)
        dest: (67, <255, 255, 255, 255>, <FF-FF-FF-FF-FF-FF>)
    to the link
2.  local DHCP server receives the request, allocates a new <PC_IP>, send response in UDP segment
        src: (67, <DHCP_IP>, <DHCP_MAC>)
        dest: (68, <PC_IP>, <PC_MAC>)
    containing local gateway and DNS server IP to the link
3.  PC want to query DNS server for the domain name but doesn't know the MAC address of DNS server
    sends ARP query to the link
        src: (<PC_IP>, <PC_MAC>)
        dest: (<DNS_IP>, <FF-FF-FF-FF-FF-FF>)
4.  ARP query picked up by the DNS server, server sends ARP response
        src: (<DNS_IP>, <DNS_MAC>)
        dest: (<PC_IP>, <PC_MAC>)
5.  PC receives ARP response and updates its ARP table
    sends DNS query to DNS server in UDP segment 
        src: (<PORT>, <PC_IP>, <PC_MAC>)
        dest: (53, <DNS_IP>, <DNS_MAC>)
    containing the domain name of the web server
6.  DNS query is routed to the DNS server with forwarding tables established by some intra network routing protocol
    DNS server send response in UDP segment 
        src: (53, <DNS_IP>, <DNS_MAC>)
        dest: (<PORT>, <PC_IP>, <PC_MAC>)
    containing the IP of the web server 
7.  PC does another ARP query to find the MAC address of the local gateway
8.  PC send TCP SYN to the web server in TCP segment
        src: (<PORT>, <PC_IP>, <PC_MAC>)
        dest: (80, <SERVER_IP>, <GATEWAY_MAC>)
9.  after inter and intra network forwarding web server receives the SYN, sends SYNACK
        src: (80, <SERVER_IP>, <SERVER_MAC>)
        dest: (<PORT>, <PC_IP>, <SERVER_GATEWAY_MAC>)
10. PC receives SYNACK and sends HTTP request in TCP stream
        // same to 8.
11. web server receives HTTP request in TCP stream
        // same to 9.
    
5.32
a.  all the flows have to go all the way up to the border router and all the way down to rack 9 - 12
    sharing the same link of 10Gbps, 10Gbps / 80 = 125Mbps
b.  there are 4 * 10Gbps links from Tier-2 switch of rack 9-12 to the network
    in full speed each flow can transmit at rate 40Gbps / 80 = 500Mbps
c.  bottle necks:
        host to TOR: 1Gbps / 2 = 500Mbps
        TOR to Tier-2: 10Gbps / 20 = 500Mbps
        Tier-2 outgoing: 4 * 10Gbps / 80 = 500Mbps
        Tier-2 incoming: 4 * 10Gbps / 160 = 250Mbps
    each flow cannot have rate exceeding 250Mbps

5.33
a.  100% - 99.9% = 0.1%
b.  0.1%^2 = 0.0001%
c.  not enough information: 
    how to share a rack between two applications? 
    how to lock and release the rack to one application so it's temporarily unavailable to another?
    some protocol is missing here

6.1
(-1, 1, -1, 1, -1, 1, -1, 1)
(1, -1, 1, -1, 1, -1, 1, -1)

6.2
(1, -1, 1, 1, 1, -1, 1, 1)
(1, -1, 1, 1, 1, -1, 1, 1)

6.3
d0 = ΣZ*0,m * c2m / M = (2 + 2 + 2 + 2) / 8 = 1
d1 = ΣZ*1,m * c2m / M = (2 + 2 + 2 + 2) / 8 = 1

6.4
(1, 1, 1, 1, -1, -1, -1, -1) and the complement
d0 would be 0 at receiver by both code

6.5
a.  under CSMA/CA, if both AP transmit at the same time, collision will occur
    none of them will receive the CSMA/CA ACK from the mobile station
    both of them enter the backoff phase and wait for a random interval
    the AP with a shorter interval will retransmit first, the other will freeze the count down after sensing the signal
    both of them will operate at a rate lower than the physical limit
b.  there will be no collision, channel 1 and 11 are separated by more than 4 channels
    both AP may operate normally

6.6
fairness, if the second frame is sent immediately, this AP will occupy the channel as long as it has frames to send

6.7
according to Figure 6.12
DIFS + s_RTS/R + SIFS + s_CTS/R + SIFS + 1000/R + SIFS + s_ACK/R
where
    s_RTS, s_CTS, s_ACK: size of the named frames
    R: transmission rate

6.8
a.  0.5 message / slot
    the message must be relayed by B, which can only receive or send the message in each time slot
    a loop of 2 states transmits at the maximum possible rate:
    1.  C send, B receive, A silent
    2.  C silent, B send, A receive
b.  2 messages / slot
    only B can hear A, only C can hear D, their sending signals will not collide
    a loop of 1 state:
    1.  A send, B receive, C receive, D send
c.  1 message / slot
    only one of A and C can send at the same time otherwise their signals collide at B
    a loop of 2 states transmits at the maximum possible fair rate:
    1.  A send, B receive, C silent, D silent
    2.  A silent, B silent, C send, D receive
d.  a.  the same
    b.  the same
    c.  2 messages/ slot, no collision at B
e.  a.  0.25 message / slot
        no collision, each message traverses two links, each link costs two time slots (forward & ACK)
    b.  1 message / slot, same to above
    c.  1 message / slot
        B and C can send at the same time, their destinations cannot hear the other sender
        a loop of 2 states transmits at the maximum possible rate:
        1.  A send, B receive, C receive, D ACK
        2.  A receive, B ACK, C send, D receive
    
6.9
Access Code: 72
    preamble: 4
    sync word: 64
    trailer: 4
Header: 54
    AM_ADDR: 3
        active member address, limited to 2^3 = 8 active members
    TYPE: 4
    FLOW: 1
        flow control bit, 0 when the receive buffer is full
    ARQN: 1
        ARQ response
    SEQN: 1
        sequential number 
    HEC: 8
        error check code
Payload: 0-2754

6.10
a.  10Mbps, all time and frequency slots to A
    it's not fair as only A receives anything at all
    fairness: equal chance (in terms of time slots) to be served
b.  let w, x, y, z be the fraction of slots assigned to A, B, C and D
    10w = 5x = 2.5y = z
    w + x + y + z = 1
    w + 2w + 4w + 10w = 1
    w = 1/17
    average transmission rate = 10w + 5x + 2.5y + z = 4 * 10w = 40/17Mbps
c.  average transmission rate = 3Mbps
    by linear programming 
    https://online-optimizer.appspot.com/?model=ms:JX8oXtNAlygHhOvph9NrZnF1F3nAu2hn
    var w >= 0;
    var x >= 0;
    var y >= 0;
    var z >= 0;
    maximize t: 10*w + 5*x + 2.5*y + z;
    subject to c1: w + x + y + z == 1;
    subject to c2: 2*z - 10*w >= 0;
    subject to c3: 2*z - 2.5*y >= 0;
    subject to c4: 2*z - 5*x >= 0;
    subject to c5: 5*y - 10*w >= 0;
    subject to c6: 5*y - 5*x >= 0;
    subject to c7: 5*y - z >= 0;
    subject to c8: 10*x - 10*w >= 0;
    subject to c9: 10*x - 2.5*y >= 0;
    subject to c10: 10*x - z >= 0;
    subject to c11: 20*w - 5*x >= 0;
    subject to c12: 20*w - 2.5*y >= 0;
    subject to c13: 20*w - z >= 0;
    end;
    w = 0.1, x = 0.2, y = 0.2, z = 0.5

6.11
a.  no, the route information have to be propagated through the network
b.  a natural consequence of a
c.  10s of seconds with BGP

6.12
the same as Figure 6.24
mobile -> correspondent home agent
    <CORRES_PERMA_IP>
-> correspondent foreign agent
    <CORRES_COA> | <CORRES_PERMA_IP>
-> correspondent 
    <CORRES_PERMA_IP>

6.13
the packets from correspondent is now routed through home agent -> foreign agent -> mobile agent, it may not be the 
least-cost route to the foreign agent hence may have higher RTT
encapsulation / decapsulation at home and foreign agents may further increase the delay

6.14
chaining:
    no protocol specified in the text
    in theory only messages between BSs are necessary, neither B nor C has to inform the MSC
no chaining:
    the same sequence of messages in Figure 6.31, repeated twice (A -> B and B -> C)

6.15
possible if they registered themselves to the foreign agent at different time
the same COA may be recycled and reused

6.16
by sending VLR address instead of MSRN to HLR, the system is more distributed
but a call incurs more initial delay from more indirection

7.1
time of arrival
    b1: t1
    b2: +(1D, 2D)
    b3: +(2D, 3D)
    b4: +(2D, 3D)
    b5: +(2D, 3D)
    b6: +(3D, 4D)
    b7: +(4D, 5D)
    b8: +(8D, 9D)
a.  5: b1, b4, b5, b6, b7 will arrive in time
b.  7: all except b8
c.  t1:     [b1]
    +D:     []
    +2D:    [b2]
    +3D:    [b3, b4, b5]
    +4D:    [b4, b5, b6]
    +5D:    [b5, b6, b7]
    +6D:    [b6, b7]
    +7D:    [b7]
    +8D:    []
    +9D:    [b8]
    +10D:   []
    3 at most
d.  2Δ, b8 arrives at t > t1 + 8Δ

7.2
a.  assume no delay, no lost, no jitter
    Q/x before playout
    Q/(r - x) before freezing
b.  at first Q/x the buffer won't be consumed 
    then the buffer is full after (B - Q) / (x - r)
    Q/x + (B - Q) / (x - r) in total

7.3
a.  H/2
b.  if H > 2r, the client will experience no freezing after T/2
    otherwise there will be freezing from time to time
c.  floor(Q / (HT / 2)) * T + ((2 * frac(Q / (HT / 2)) * T) / H)^(1/2)
d.  Q = HT/2, initial playout delay will be T
    in a period rT is consumed where HT/2 is received
    H > 2r, rT < HT/2, the buffer will never be empty
e.  Q = (r^2 * T) / 8H
    initial delay = rT / 2H, at when x(t) = r/2
    at when x(t) = r, t = rT / H, the buffer is empty and start to grow until t = T
    at t = T, the accumulated buffer is (T - rT/H)^2 * (H/T) / 2
    before next time x(t) = r, (rT/H)^2 * (H/T) / 2 bits in the buffer will be consumed
    since H > 2r, T - rT/H > rT/H, the buffer will not be depleted in the next period and any period after
    if Q < (r^2 * T) / 8H, the buffer will be depleted before rT/H
f.  // skipped

7.4
a.  (x - r)E
b.  min((x - r)E, r(T - E))

7.5
a.  N^2
b.  2N

7.6
a.  h * (1000 / 20) + 8000 = 50h + 8000
b.  RTP header: 12 bytes
    UDP header: 8 bytes
    IP header: 20 bytes
    h = 40 

7.7
// skipped, similar to 3.32

7.8
// skipped

7.9
a.  dn  = Σ(ri - ti)/n = (Σ(i<n)(ri - ti) + (rn - tn)) / n
        = (Σ(i<n)(ri - ti)/(n-1) * (n-1) + (rn - tn)) / n
        = (dn-1(n-1) + (rn - tn)) / n
b.  network fluents over time instead of being random sample around a constant average
    delay estimate in 7.3 give more recent delays more weights, better reflects the nature of Internet delays

7.10
they are almost the same, while TCP estimates round-trip delay but multimedia applications estimate one-way delays

7.11
a.  [7, 9, 8, 7, 9, 8, 8]
b.  packet 3, 4, 6, 7, 8
c.  packet 3, 6
d.  2

7.12
./network/multimedia/problems
a.  [7.000, 7.200, 7.280, 7.252, 7.427, 7.484, 7.536]
b.  [0.000, 0.180, 0.234, 0.236, 0.370, 0.384, 0.392]

7.13
a.  both adds 25% to the transmission rate
    the first scheme may only start playout after receiving 5 chunks, maximum additional delay equals to the 
    transmission time of four chunks, while the second scheme add delay at most transmission time of 1/4 chunk
b.  first:
        the first packet is recovered by xor-ing all the four packets following
        the audio quality is not affected
    second:
        the first packet is replaced by a low bit rate version
        the audio quality is lower
c.  first:
        the lost packet cannot be recovered, user will experience gaps between sounds
    second:
        every packet is replaced by the low bit rate version
        audio is of lower quality but complete

7.14
a.  initiator: r(N-1) bits
    participants: r bits
    r(N-1) + r(N-1) = 2r(N-1) bits in total
b.  r bits per participant, rN in total
c.  r(N-1) per participant, rN(N-1) in total

7.15
a.  UDP sockets have unique (IP, PORT) tuple so yes
b.  by synchronization source identifier in RTP header

7.16
a.  false, it may be streaming over UDP
b.  true, different media type can be specified in each RTP packet
c.  false, not specified in RFC3550
d.  not always, according to RFC3550:
    "A participant need not use the same SSRC identifier for all the RTP sessions in a multimedia session"
e.  true, it's the definition of Diffserv
f.  false, a INVITE message indicates the media type the sender want to receive
g.  false, that indicates Alice want to receive at port 48753
h.  true
i.  true
j.  false, didn't find G.711 in RFC3261

7.17
a.  1123
b.  112

7.18
./network/multimedia/problems
a.  Departure times: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    Delays: [1, 2, 2, 3, 3, 3, 4, 3, 4, 3, 3, 4]
    Avg delay: 2.917
b.  Departure times: [1, 5, 2, 7, 3, 8, 4, 10, 6, 11, 9, 12]
    Delays: [1, 5, 1, 6, 1, 5, 1, 5, 1, 4, 1, 4]
    Avg delay: 2.917
c.  Departure times: [1, 2, 3, 5, 6, 4, 7, 8, 9, 10, 12, 11]
    Delays: [1, 2, 2, 4, 4, 1, 4, 3, 4, 3, 4, 3]
    Avg delay: 2.917
d.  packet is chosen so that the served ratio after the packet's departure is closer to 2:1
    Departure times: [3, 1, 4, 2, 7, 5, 10, 6, 11, 8, 12, 9]
    Delays: [3, 1, 3, 1, 5, 2, 7, 1, 6, 1, 4, 1]
    Avg delay: 2.917
e.  they are all the same
    sum of the departure time is fixed at Σ(1..12)
    sum of the arrival time is also fixed, sum of the delay = the difference is fixed as well as the average delay

7.19
./network/multimedia/problems
a.  Departure times: [1, 5, 6, 2, 3, 4, 7, 8, 10, 11, 9, 12]
    Delays: [1, 5, 5, 1, 1, 1, 4, 3, 5, 4, 1, 4]
    Avg delay: 2.917
b.  Departure times: [1, 5, 6, 2, 3, 4, 7, 8, 9, 10, 12, 11]
    Delays: [1, 5, 5, 1, 1, 1, 4, 3, 4, 3, 4, 3]
    Avg delay: 2.917
c.  Departure times: [3, 1, 2, 5, 10, 11, 4, 6, 7, 8, 12, 9]
    Delays: [3, 1, 1, 4, 8, 8, 1, 1, 2, 1, 4, 1]
    Avg delay: 2.917

7.20
./network/multimedia/problems
t = 0, In queue: [0, 1, 2], tokens: 2, output = [0, 1]
t = 1, In queue: [2, 3], tokens: 1, output = [2]
t = 2, In queue: [3, 4], tokens: 1, output = [3]
t = 3, In queue: [4, 5], tokens: 1, output = [4]
t = 4, In queue: [5], tokens: 1, output = [5]
t = 5, In queue: [], tokens: 1, output = []
t = 6, In queue: [6, 7], tokens: 2, output = [6, 7]
t = 7, In queue: [8, 9], tokens: 1, output = [8]
t = 8, In queue: [9], tokens: 1, output = [9]

7.21
./network/multimedia/problems
t = 0, In queue: [0, 1, 2], tokens: 2, output = [0, 1]
t = 1, In queue: [2, 3], tokens: 2, output = [2, 3]
t = 2, In queue: [4], tokens: 2, output = [4]
t = 3, In queue: [5], tokens: 2, output = [5]
t = 4, In queue: [], tokens: 2, output = []
t = 5, In queue: [], tokens: 2, output = []
t = 6, In queue: [6, 7], tokens: 2, output = [6, 7]
t = 7, In queue: [8, 9], tokens: 2, output = [8, 9]

7.22
won't change, the bucket cannot hold more than 2 tokens

7.23
let burst size be b, average rate be r, peak rate be p
the first bucket has size = b and rate = r
the second bucket has size = rate = p
the first bucket can police the average rate and size as always
the second bucket mandates that no more than p packets can be outputted in each slot

7.24
invariant:
    with b initial token, for any integer t a packet flow conforms to (r, b) specification does not have to wait
initialization:
    t = 1, r + b packets at most in a time interval of 1
    b packets can be relayed immediately, r packets can be sent through with tokens generated during that time interval
induction:
    assume invariant hold for all length k, let t = k + 1
    let r0 be the number of packets arrived at the first time interval of length 1
    if r0 <= r,
        the remaining flow has <= rt + b - r0 <= rk + b packets, it is a (r, b) flow of length k 
        the token at t = 1 is at least b, by induction no packet has to wait
    if r0 > r,
        by definition of (r, b) flow, r + b >= r0 > r, packets don't have to wait in the first slot
        the remaining flow has <= rt + b - r0 = rk + (b - (r0 - r)) packets, it is a (r, b - (r0 - r)) flow of length k
        the bucket has at least b - (r0 - r) tokens at t = 1, by induction no packet has to wait

7.25
immediate result if the WFQ serves each class FIFO

8.1
./network/security
uasi si mj cmiw lokngch
wasn't that fun

8.2
26! / (26 - 7)! = 3315312000 = 3e9

8.3
it's sufficient. shift of the two ciphers can be determined as well as the pattern
(if the pattern is shorter than the sentence)

8.4
./network/security
a.  [05, 05, 05, 05, 05, 05, 05, 05]
b.  [05, 05, 05, 05, 05, 05, 05, 85]
c.  [05, 05, 05, 05, 05, 05, 05, 05]
    [85, 05, 05, 05, 05, 05, 05, 05]

8.5
an 8 to 8 table is of size 2^8 * 8 = 2048 bits
2048 * 8 = 16384 bits in total
much smaller than 2^64 * 64

8.6
a.  011 011 011
b.  it's the same 3-bit pattern repeated 3 times
c.  100 110 101

8.7
n = 33, z = 20, e = 3, d = 7
a.  cannot be encrypted: message in ASCII encoding is greater than n
b.  same to part a

8.8
a.  n = 55, z = 40
b.  gcd(3, 40) = 1
c.  d = 27
d.  m^e = 8^3 = 2^9 = 512
    c = 512 % 55 = 17

8.9
a.  S = TB^SA = g^SB^SA = g^SA^SB = TA^SB = S' mod p
b.  TA = g^SA = 2^5 = 32 = 10 mod 11
    TB = g^SB = 2^12 = 4 mod 11
c.  S = TB^SA = 1 mod 11
d.  Trudy can impersonate Alice to Bob and impersonate Bob to Alice
    do the DH key exchange separately with Alice and Bob using its own private key ST
    end up sharing S and S' (possibly different) with Alice and Bob

8.10
// without a nonce this protocol is vulnerable to replay attacks
a.  (K_A_KDC(A, B, KS), K_B_KDC(A, B, KS))
b.  K_B_KDC(A, B, KS)

8.11
IOU990.10BOB

8.12
according to [Katz & Lindell, 2007], an encryption scheme
    compute c = enc(S2, m)
    compute t = mac(S1, c)
    send <c, t>
is CCA-secure if enc is CPA-secure and mac is secure message authentication code with unique tags

8.13
the .torrent file contains hash of all blocks
peers downloading a block first checks the hash of the block

8.14
the network layer protocol is usually implemented on hardware level
where digital signatures are too slow compared to MAC

8.15
Trudy -> Bob: I'm Alice
Bob -> Trudy: R
Bob -> Trudy: I'm Bob
Trudy -> Bob: R
Bob -> Trudy: K_AB(R)
Trudy -> Bob: K_AB(R) // replay

8.16
a.  // skipped
b.  Alice -> Bob: I'm Alice (intercepted)
    Trudy -> Bob: I'm Alice
    Bob -> Alice: R
    Alice -> Bob: K_Priv(R) (intercepted)
    Trudy -> Bob: K_Priv(R)

8.17
// skipped, already on Figure 8.19

8.18
// reference: https://en.wikipedia.org/wiki/Transport_Layer_Security#Protocol_details
a.  impossible, nothing distinguishes Alice from anyone else
b.  the public key of Bob is contained in his certificate

8.19
a.  by client, client key exchange messages are send by clients
b.  216.75.194.220:443
c.  79 + 204 = 283
d.  3
e.  contains the PMS encrypted by the server's public key
f.  first byte: bc, last byte: 29
g.  6: client hello, server hello, certificate, server hello done, client key exchange, change cipher spec
h.  7: + change cipher spec (server)

8.20
Trudy has to modify sequence numbers of all the following packets and ACKs during this session
otherwise the deleted packet will be retransmitted

8.21
the attacker cannot authenticate the packet with correct authentication key
the packet won't pass unnoticed

8.22
a.  false, only datagram to hosts in the same VPN will be sent in IPSec
b.  false, it will encapsulate the IP datagram in a new IP datagram with different source / dest IP address
    IP address in the original datagram is not touched
c.  false, IP / IPSec protocol is in network layer, they know no port number
d.  false, R1 will resend with a new sequence number

8.23
R2 will detect a reused sequence number in ESP header and discard the packet / alert the administrator

8.24
a.  11 01011010 1010
b.  // skipped
c.  the 5th bit
d.  let the data be AB, both A and B are 4-bit long
    let the first 8 bits of the key stream be CD
    (A ^ C ^ 0x80 ^ C) ^ (B ^ D ^ 0x80 ^ D)
    = (A ^ 0x80) ^ (B ^ 0x80)
    = A ^ B ^ 0x0 = A ^ B

8.25
a.  allow 222.22/16 outside TCP >1023 53 _ X
    allow outside 222.22/16 53 >1023 _ X
b.  allow outside 222.22.0.12 TCP >1023 80 any X
    allow 222.22.0.12 outside TCP 80 >1023 ACK X
c.  deny all all all all

8.26
// only confidentiality
a.  Alice -> Proxy1: K1+(S1)
b.  Alice -> Proxy1: K1+(K2+(S2))
    Proxy1 -> Proxy2: K2+(S2)
c.  Alice -> Proxy1: S1(S2(R))
    Proxy1 -> Proxy2: S2(R)

9.1
overhead:
    request and response has bigger overhead for the extra request messages
notification time:
    trapping messages will be sent immediately on events
    request-response model will only be informed periodically
robustness:
    when a trapping messages is lost it will never reach the managing entity
    a lost request or response will not go unnoticed, the managing entity can retransmit on timeout

9.2
SNMP is designed to monitor and control attributes of network nodes
as a consequence it should rely on as less capacity of the target node as possible while remain in application layer
TCP in contrary to UDP is more complicated and more vulnerable to network and software conditions 
e.g. congestion, out of memory

9.3
1.3.6.1.2.1.5

9.4
http://oid-info.com/get/1.3.6.1.4.1
1.3.6.1.4.1

9.5
1.3.6.1.4.1.2
http://oid-info.com/get/1.3.6.1.4.1.2

9.6
length may not be necessary given the type
for instance a 32-bit integer is always 4 octets

9.7
47Michael23165

9.8
47Sridhar23145