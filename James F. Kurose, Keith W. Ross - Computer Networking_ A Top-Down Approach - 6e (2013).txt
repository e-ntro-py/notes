/// only problems and some labs, skipping all review questions
/// resource site: https://wps.pearsoned.com/ecs_kurose_compnetw_6/216/55463/14198700.cw/-/14198926/index.html
/// errata: https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_6/Errata_6th_Edition.pdf
/// Wireshark Labs: https://github.com/ashly13/Computer-Networking---A-Top-Down-Approach/tree/master/Wirshark%20Labs
/// 1G = 1024M, 1M = 1024K, 1K = 1024

1.1
// all message transmitted will be shown in JSON
the client (teller machine) first sends a message of account ID and (possibly hashed) password:
    {
        id: String,
        password: String
    }
the server receives the message, check the password against the id, sends back either 
    an error or 
    an accepted message and moves into the Verified state
the error should be as general as possible for security reason
    // one of the two is sent
    "ERROR"
    "ACCEPTED"
once accepted, the client can query for account balance:
    "BALANCE"
    // server response, only in Verified state
    {
        balance: Number
    }
    // not in Verified state
    "VERIFICATION REQUIRED"
or try withdraw an amount of cash:
    {
        withdraw: Number
    }
    // server response, one of them, only in Verified state
    "Insufficient balance"
    {
        withdraw: Number
        // client machine disburse cash
    }
    // not in Verified state
    "VERIFICATION REQUIRED"
at the end client issues a logout, server responses and exit Verified state
    "LOGOUT"
    // server response
    "LOGOUT ACCEPTED"
logout must be mandatory on leave, e.g. the teller machine will only login with physical insertion of a debit card
and automatically logout on ejection of the debit card
the channel must be encrypted

1.2
assuming these packets are the only packets in the network
throughput is uniform among links, end host can send the next packet immediately after the current one
end host start sending the last packet at time (P-1)L/R, it will reach the other end host (P-1)L/R + NL/R
total delay is (P + L - 1)L/R

1.3
a.  a circuit-switched network will be more appropriate if
        k is small enough (there's no waste of network capacity)
        client and server of the application is geographically close
        (otherwise it's better to reuse the existing packet-switched Internet)
b.  congestion control is still necessary, routers may not be processing the packets quick enough

1.4
a.  16, 4 between each two neighboring switches
b.  8, 4 on path A -> B -> C, 4 on path A -> D -> C
c.  possible:
        2 on path A -> B -> C
        2 on path A -> D -> C
        2 on path B -> A -> D
        2 on path B -> C -> D

1.5
assume it takes the tollbooth R minutes to process a car 
if all tollbooth operates at the same rate, there's no queuing delay except in front of the first tollbooth
last car in the caravan is processed by the first tollbooth at (P - 1)R
it finishes after the third tollbooth at (P - 1)R + 60 * 150/100 + 3R = (P + 2)R + 90
a.  7R + 90
b.  10R + 90

1.6
a.  m/s sec
b.  L/R sec
c.  m/s + L/R sec
d.  at the A-end of the link
e.  at Host B
f.  somewhere in the link
g.  m / s = L / R
    m / 2.5e8 = 120 / 56 / 1024
    m = 523.1584km

1.7
assume 8-bit bytes (octets)
transmission delay is 56 * 8 /(2 * 1024 * 1024) = 0.2136ms
propagation delay = 2ms
if the bit is the first of a 56-byte packets:
    encode delay = 56 * 8 / (64 * 1024) = 6.8359ms
if the bit is the last of a 56-byte packets:
    no encode delay
overall between 2.2136ms and 0.0495ms

1.8
a.  [3 * 1024 / 150] = 20
b.  10%
c.  C(120, n)0.1^n0.9^(120 - n)
d.  by normal approximation to binomial:
    P(N >= 21)  ≒ P(X >= 21), X ~ N(12, 10.8)
                = 0.00308495

1.9
a.  [1024 * 1024 / 100] = 10485
b.  Σ{N < k <= M}(C(M, k)p^k(1-p)^(M-k))

1.10
assume the end hosts do not incur switch delays
total delay:
    2d_proc + Σi (di / si + L / Ri)
numerical delay:
    0.002 * 3 + (5000 + 4000 + 1000) / 2.5e6 + 1500 * 8 * 3 / (2 * 1024^2) 
    = 0.0272s = 27.2ms

1.11
one transmission delay only without store-and-forward
L/R + Σi di / si

1.12
queueing delay:
    4.5 * 1500 * 8 / (2 * 1024^2) = 0.0257
    (nL + x)/R

1.13
a.  Σk {0 <= k <= N - 1}(kL/R) / N
    = (N-1)L / 2R
b.  if N packets arrives at the same time every LN/R seconds, same to part a
    all N packets can be transmitted in LN/R, two bursts of packets do not interfere with each other

1.14
a.  delay   = IL/R(1 - I) + L/R
            = a(L/R)^2/(1 - L/R) + L/R
b.  https://www.wolframalpha.com/input/?i=plot%28x%2C+x%5E2%2F%281+-+x%29+%2B+x%29

1.15
μ = L/R
delay = aμ^2 / (1 - μ) + μ

1.16
N = 10, d = 10ms + d_trans = 10ms + 1/100s = 20ms
a = N/d = 0.5 packet/ms

1.17
a.  d_end-end = Σi(di_proc + di_trans + di_prop)
b.  E[D] = Σi(di_proc + di_trans + di_prop + d_queue)

1.18
 1  203.98.68.97 (203.98.68.97) [AS10145]  0.278 ms (255)  0.305 ms (255)  0.282 ms (255) (0% loss)
 2  203.98.68.253 (203.98.68.253) [AS10145]  0.493 ms (63)  0.52 ms (63)  0.431 ms (63) (0% loss)
 3  73.194.233.220.static.exetel.com.au (220.233.194.73) [AS10143]  0.898 ms (253)  1.001 ms (253)  0.827 ms (253) (0% loss)
 4  * * * (100% loss)
 5  Bundle-Ether59.chw-edge903.sydney.telstra.net (203.54.151.81) [AS1221]  2.097 ms (251)  1.7 ms (251)  1.529 ms (251) (0% loss)
 6  bundle-ether17.chw-core10.sydney.telstra.net (203.50.11.176) [AS1221]  3.587 ms (250)  2.826 ms (250)  2.558 ms (250) (0% loss)
 7  bundle-ether8.exi-core10.melbourne.telstra.net (203.50.11.125) [AS1221]  14.751 ms (249)  15.076 ms (249)  14.622 ms (249) (0% loss)
 8  bundle-ether2.exi-ncprouter101.melbourne.telstra.net (203.50.11.209) [AS1221]  12.979 ms (248)  12.783 ms (248)  12.743 ms (248) (0% loss)
 9  www.telstra.net (203.50.5.178) [AS1221]  12.518 ms (247)  12.594 ms (247)  12.6 ms (247) (0% loss)
a.  // skipped
b.  // skipped
c.  3 I guess? one anonymous, exetel and telstra
 1  gigabitethernet3-3.exi1.melbourne.telstra.net (203.50.77.49)  0.287 ms  0.269 ms  0.241 ms
 2  bundle-ether3-100.exi-core10.melbourne.telstra.net (203.50.80.1)  1.984 ms  1.542 ms  2.115 ms
 3  bundle-ether12.chw-core10.sydney.telstra.net (203.50.11.124)  12.604 ms  12.037 ms  12.733 ms
 4  bundle-ether1.oxf-gw11.sydney.telstra.net (203.50.6.93)  12.356 ms  12.309 ms  12.970 ms
 5  bundle-ether1.sydo-core03.sydney.reach.com (203.50.13.98)  47.815 ms  48.011 ms  46.750 ms
 6  i-73.paix-core02.telstraglobal.net (202.84.247.45)  200.086 ms  199.183 ms  200.618 ms
 7  i-92.paix02.telstraglobal.net (202.84.247.41)  199.623 ms  199.929 ms  200.372 ms
 8  liberty_global-peer.eqnx03.pr.telstraglobal.net (134.159.63.85)  198.252 ms  198.181 ms  198.250 ms
 9  be2015.ccr21.sfo01.atlas.cogentco.com (154.54.7.173)  200.120 ms  200.052 ms  199.748 ms
10  be3109.ccr21.slc01.atlas.cogentco.com (154.54.44.138)  215.362 ms  215.043 ms  214.991 ms
11  be3037.ccr21.den01.atlas.cogentco.com (154.54.41.146)  225.486 ms  225.537 ms  225.987 ms
12  be3035.ccr21.mci01.atlas.cogentco.com (154.54.5.90)  237.224 ms  237.282 ms  237.601 ms
13  be2831.ccr41.ord01.atlas.cogentco.com (154.54.42.166)  249.493 ms  248.886 ms  248.849 ms
14  be2717.ccr21.cle04.atlas.cogentco.com (154.54.6.222)  256.835 ms  256.020 ms  256.339 ms
15  be2993.ccr31.yyz02.atlas.cogentco.com (154.54.31.226)  263.587 ms  263.391 ms  263.084 ms
16  38.104.158.202 (38.104.158.202)  269.711 ms  268.513 ms  268.584 ms
d.  roundtrip delay skyrocketed from 12ms to 269ms

1.19
a.  http://traceroute.sdv.fr/
    1	wblindix.sdv.fr      	212.95.66.126      	0.129 ms
    2	border-gateway2.sdv.fr      	212.95.69.227      	0.749 ms
    3	6k-2-sfr-str-e2-3-sdv-plurimedia.customers-sfr-str.ielo.net      	212.85.149.172      	0.894 ms
    4	frpar-th2-c6k1.as29075.net      	185.96.186.74      	6.655 ms
    5	te0-1-0-7.frpar-th2-a9k1.as29075.net      	185.96.186.239      	6.915 ms
    6	be4.frpar-th2-n55h1.as29075.net      	185.18.172.147      	6.945 ms
    7	hu0-0-1-0.frpar-eqx3-n55h1.as29075.net      	185.96.186.118      	7.084 ms
    10	4.14.33.54      	4.14.33.54      	153.228 ms
    11	138.197.244.228      	138.197.244.228      	152.676 ms
    12	138.197.248.207      	138.197.248.207      	173.624 ms
    13	159.203.251.185      	159.203.251.185      	153.57 ms
    https://www.as30781.net/nettools/traceroute/
    #1	JAGUAR-AS (AS30781)	85.31.192.253	be3-200.hr01-corp.mar02.jaguar-network.net	0.851 ms	
    #2	JAGUAR-AS (AS30781)	78.153.231.39	be1.er02.mar02.jaguar-network.net	0.779 ms	
    #3	*	*	*	*	*
    #4	*	*	*	*	*
    #5	AS3356	4.14.33.54	4.14.33.54	162.868 ms	
    #6	*	*	*	*	*
    #7	*	*	*	*	*
    #8	DOSFO (AS14061)	159.203.251.185	159.203.251.185	169.888 ms	
    one in common: 4.14.33.54, a Level 3 Communications switcher in Fremont, US
    it should be the transatlantic link, AS29075 preceding it is in France
b.  http://www.han.de/cgi-bin/nph-trace.cgi
    1  * * *
    2  ae3-u100.cr-nunki.sxb1.bb.godaddy.com (87.230.112.2)  0.369 ms  0.264 ms  0.311 ms
    3  ae4.cr-vega.sxb1.bb.godaddy.com (87.230.114.66)  0.361 ms  0.342 ms  0.317 ms
    4  lag-125.ear2.Paris1.Level3.net (213.242.120.245)  6.538 ms  6.814 ms  7.003 ms
    5  * * *
    6  4.14.33.54 (4.14.33.54)  164.563 ms  164.506 ms 4.14.33.70 (4.14.33.70)  162.352 ms
    7  138.197.244.226 (138.197.244.226)  159.937 ms 138.197.244.230 (138.197.244.230)  159.463 ms  165.193 ms
    8  * * *
    9  159.203.251.185 (159.203.251.185)  157.534 ms  162.840 ms  162.609 ms
    the same transatlantic link 4.14.33.54 appeared
c.  #traceroute www.linkwan.com
    traceroute to www.linkwan.com (218.16.120.36), 30 hops max, 60 byte packets
    1  104.236.128.253 (104.236.128.253)  0.369 ms  0.314 ms  0.272 ms
    2  138.197.248.222 (138.197.248.222)  0.643 ms  11.188 ms  0.520 ms
    3  138.197.244.225 (138.197.244.225)  1.192 ms 138.197.244.229 (138.197.244.229)  1.161 ms 138.197.244.231 (138.197.244.231)  1.171 ms
    4  lag-112.ear2.SanJose1.Level3.net (4.14.33.69)  1.705 ms lag-111.ear2.SanJose1.Level3.net (4.14.33.53)  1.724 ms  1.893 ms
    5  ae-1-9.edge2.SanJose3.Level3.net (4.69.209.181)  1.819 ms ae-3-19.edge2.SanJose3.Level3.net (4.69.209.189)  2.103 ms  1.964 ms
    6  CHINA-TELEC.edge2.SanJose3.Level3.net (4.53.210.118)  5.784 ms CHINA-TELEC.edge2.SanJose3.Level3.net (4.53.210.210)  5.039 ms  4.991 ms
    7  202.97.50.77 (202.97.50.77)  8.361 ms  8.284 ms  8.205 ms
    8  202.97.89.137 (202.97.89.137)  180.948 ms  180.921 ms  180.882 ms
    9  202.97.94.97 (202.97.94.97)  178.113 ms  178.151 ms  178.428 ms
    10  202.97.94.145 (202.97.94.145)  178.605 ms  178.601 ms  178.553 ms
    11  113.96.254.17 (113.96.254.17)  176.119 ms 113.96.254.37 (113.96.254.37)  190.280 ms  190.465 ms
    12  218.16.126.205 (218.16.126.205)  178.072 ms  178.474 ms  178.818 ms
    13  121.14.130.134 (121.14.130.134)  177.900 ms  184.418 ms  184.616 ms
    14  218.16.120.36 (218.16.120.36)  177.238 ms  177.315 ms  177.094 ms
    #traceroute v-www.ihep.ac.cn
    traceroute to v-www.ihep.ac.cn (202.38.128.8), 30 hops max, 60 byte packets
    1  104.236.128.253 (104.236.128.253)  12.702 ms  12.722 ms  12.711 ms
    2  138.197.248.206 (138.197.248.206)  0.719 ms  0.866 ms 138.197.248.222 (138.197.248.222)  0.737 ms
    3  64.86.208.18 (64.86.208.18)  0.486 ms 64.86.208.16 (64.86.208.16)  0.488 ms  0.473 ms
    4  if-ae-22-2.tcore2.sqn-san-jose.as6453.net (64.86.21.101)  2.298 ms  2.240 ms  2.263 ms
    5  if-ae-1-2.tcore1.sqn-san-jose.as6453.net (63.243.205.1)  2.300 ms  2.277 ms  2.325 ms
    6  be6453.ccr41.sjc03.atlas.cogentco.com (154.54.12.141)  2.175 ms  2.184 ms  2.307 ms
    7  be3669.ccr21.sfo01.atlas.cogentco.com (154.54.43.9)  3.485 ms  3.477 ms be3670.ccr22.sfo01.atlas.cogentco.com (154.54.43.13)  3.454 ms
    8  be3694.ccr21.pdx01.atlas.cogentco.com (154.54.84.30)  21.975 ms  22.066 ms be3693.ccr21.pdx01.atlas.cogentco.com (154.54.81.66)  22.323 ms
    9  be3701.ccr21.hkg02.atlas.cogentco.com (154.54.87.122)  155.931 ms  155.930 ms  155.908 ms
    10  154.18.4.2 (154.18.4.2)  157.582 ms  157.347 ms  157.375 ms
    11  8.201 (159.226.254.5)  190.629 ms  190.336 ms  190.597 ms
    12  8.200 (159.226.254.49)  196.974 ms 8.201 (159.226.254.41)  191.384 ms  191.588 ms
    13  8.198 (159.226.254.158)  191.225 ms 8.209 (159.226.254.162)  199.614 ms  199.600 ms
    14  * * *
    15  sslvpn1.ihep.ac.cn (202.122.36.2)  202.456 ms  202.438 ms  202.276 ms
    16  * * *
    17  * * *
    18  * * *
    19  * * *
    20  * * *
    21  * * *
    22  * * *
    23  * * *
    24  * * *
    25  * * *
    26  * * *
    27  * * *
    28  * * *
    29  * * *
    30  * * *
    only the first two
    they do diverge before reaching China

1.20
min(Rs, Rc, R/M)

1.21
one path:
    max(k){min(i){Rki}}
all paths:
    Σk min(i){Rki}

1.22
p(loss) = 1 - (1-p)^N
X ~ Geometric((1-p)^N), E[X] = 1 / (1-p)^N

1.23
a.  trace of last bit of package 1 
        L/Rs:   leaves A
        +d_prop: reaches switch
        +L/Rc:  leaves switch
        +d_prop: reaches B
    trace of last bit of package 2
        // no queueing in between: Rc >= Rs
        2L/Rs: leaves A
        +d_prop: reaches switch
        +L/Rc:  leaves switch
        +d_prop: reaches B
    inter-arrival time is L/Rs
b.  possible:
        last bit of the first packet leaves the switch at L/Rs + d_prop + L/Rc
        last bit of the second packet reaches the switch at 2L/Rs + d_prop
        L/Rc > L/Rs
    T >= L/Rc - L/Rs

1.24
40 * 8 * 1024^2 / 100 / 3600 / 24 = 38.8361days
FedEx overnight is much better

1.25
a.  d_prop = 20000 / 2.5e8 = 0.08s
    R * d_prop = 2Mb/s * 0.08s = 0.16Mb
b.  min(800_000b, 0.16Mb) = 0.16Mb
c.  the maximum number of bits in the link
d.  20000 / 0.16 / 1024^2 = 119.209m, slightly longer than a football field
e.  R * d_prop / m = Rm/s / m = R/s

1.26
R = s

1.27
a.  1Gb/s * 0.08s = 0.08Gb
b.  min(800_000b, 0.08Gb) = 800_000b
c.  1Gb/s / 2.5e8m/s = 4.295m

1.28
a.  d = L/R + d_prop = 800_000 / 2 * 1024^2 + 0.08s = 0.381s + 0.08s = 0.461s
b.  one package:
        L/R:    last bit sent
        +d_prop: last bit received, acknowledge sent
        +d_prop: acknowledge received 
    20(2 * d_prop + L/R) = 3.2s + 0.381s = 3.581s
c.  a is quicker but less reliable, the whole message has to be resent on failure

1.29
a.  36000km / 2.4e8m/s = 0.15s
b.  10Mb/s * 0.15s = 1.5Mb
c.  x / 10Mb/s >= 60s
    x >= 600Mb

1.30
these stickers they attach to your baggage (what's the name of it?)
seats and seat numbers of passengers

1.31
a.  8e6 / 2Mbps = 3.815s each link
    11.444s in total
b.  1e4 / 2Mbps = 0.005s
    2nd packet received at 0.010s
c.  last packet sent from source at 0.005 * 800 = 4s
    last packet received by the destination at 4s + 2 * 0.005 = 4.010s
    almost three times better than no segmentation
d.  failure recovery: destination can require the source to only resend failed segments instead of the whole file
e.  more work for both switches and hosts
    may be complications if the segments are received out-of-order

1.32
propagation delays hit harder with message switching

1.33
N = F/S
last packet is received by the first switch at NL/R, +2L/R it reaches the destination
d(F(80 + S)/SR + 2(80 + S)/R)/dL
= d(80F/SR + F/R + 160/R + 2S/R)/dL
= -80F/RS^2 + 2/R = 0
-40F + S^2 = 0
S = (40F)^(1/2)

1.34
they are both a ISP and a telephone service provider
they somehow can transmit packets between the two networks

2.1
a.  false, the client will send four requests
b.  true, with persistent connections
c.  false, each request is sent as a single TCP segment with nonpersistent connections
d.  false, Date: is the time the object is fetched from the server, the text is describing Last-Modified:
e.  false, GET is sent with empty message body

2.2
USER <SP> <username> <CRLF>
PASS <SP> <password> <CRLF>
ACCT <SP> <account-information> <CRLF>
CWD  <SP> <pathname> <CRLF>
CDUP <CRLF>
SMNT <SP> <pathname> <CRLF>
QUIT <CRLF>
REIN <CRLF>
PORT <SP> <host-port> <CRLF>
PASV <CRLF>
TYPE <SP> <type-code> <CRLF>
STRU <SP> <structure-code> <CRLF>
MODE <SP> <mode-code> <CRLF>
RETR <SP> <pathname> <CRLF>
STOR <SP> <pathname> <CRLF>
STOU <CRLF>
APPE <SP> <pathname> <CRLF>
ALLO <SP> <decimal-integer>
    [<SP> R <SP> <decimal-integer>] <CRLF>
REST <SP> <marker> <CRLF>
RNFR <SP> <pathname> <CRLF>
RNTO <SP> <pathname> <CRLF>
ABOR <CRLF>
DELE <SP> <pathname> <CRLF>
RMD  <SP> <pathname> <CRLF>
MKD  <SP> <pathname> <CRLF>
PWD  <CRLF>
LIST [<SP> <pathname>] <CRLF>
NLST [<SP> <pathname>] <CRLF>
SITE <SP> <string> <CRLF>
SYST <CRLF>
STAT [<SP> <pathname>] <CRLF>
HELP [<SP> <string>] <CRLF>
NOOP <CRLF>
functionality of these commands are specified in section 4.1 of RFC 959

2.3
DNS: resolve host to IP
UDP: for DNS
TCP: for HTTP

2.4
a.  gaia.cs.umass.edu/cs453/index.html
    from Host: and path after GET method
b.  1.1, from HTTP/1.1
c.  persistent, from Connection: keep-alive
d.  unknown, not part of HTTP protocol
e.  Netscape Navigator 7.2, from User-Agent: header
    different browser supports different subset of HTML, CSS and javascript
    it's mainly resolved by client-side shim scripts and css vendor prefixes now
    back in the days server sent different version of pages to client with different browsers

2.5
a.  yes, status code is 200
    reply provided at Tue, 07 Mar 2018 12:39:45 GMT
b.  Sat, 10 Dec2005 18:27:46 GMT, from Last-Modified: header
c.  3874, from Content-Length: header
d.  <!doc, the first five bytes following two <cr><lf>
    yes, from Connection: Keep-Alive header

2.6
a.  by header Connection: close, from section 8.1.2,
        " Persistent connections provide a mechanism by which a client and a
        server can signal the close of a TCP connection. This signaling takes
        place using the Connection header field (section 14.10). Once a close
        has been signaled, the client MUST NOT send any more requests on that
        connection."
    both client and server can signal the close of a connection
b.  apparently none
c.  no. from section 8.1.4, 
        "A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy."
d.  it's possible, from section 8.1.4:
        " A client, server, or proxy MAY close the transport connection at any
        time. For example, a client might have started to send a new request
        at the same time that the server has decided to close the "idle"
        connection. From the server's point of view, the connection is being
        closed while it was idle, but from the client's point of view, a
        request is in progress."

2.7
2RTT0 + Σ(i>0)RTTi
TCP 3-way handshake + transmission + RTTs for DNS

2.8
a.  8 * 2RTT0 = 16RTT0, 2RTT0 for each object
b.  [8/5] * 2RTT0 = 4RTT0
c.  assume all objects are requested in turn, tcp connection already established for the HTML file
    8RTT0, one for each object

2.9
a.  Δ = 0.0540
    β = 16
    d   = Δ / (1 - Δβ)
        = 0.0540 / (1 - 0.0540 * 16)
        = 0.3971
    d_total = d + 2 = 2.3971
b.  0.6 * 850000 / 100Mbps +
    0.4 * d_total
    = 0.9637

2.10
propagation delay can be ignored
parallel and persistent connection can at most skip all the 3 * 11 = 33 control packets
which is a gain of 33 * 200 / 150 = 44 secs
the objects has to be sent through the link with no less than 11 * 100K / 150 = 7509.333 secs
no significant gain from parallel nor persistent connections

2.11
a.  yes: assume Bob uses N parallel connections, each connection get 1/(N + 4) of the total throughput
    Bob gets N / (N + 4) of the total throughput instead of 1 / (N + 4) of other users
b.  no as reasoned above: every user gets 1/5 of the total throughput

2.12
./network/application/printout
most sites today are HTTPS only, to which connection starts with HTTP CONNECT method:
    CONNECT www.icann.org:443 HTTP/1.1
    Host: www.icann.org:443
    Proxy-Connection: keep-alive
    User-Agent: // omitted
all GET requests to non-HTTPS sites do not have If-Modified-Since: header
some explicitly have header disabling caches:
    GET http://milk.com/ HTTP/1.1
    Host: milk.com
    Proxy-Connection: keep-alive
    Pragma: no-cache
    Cache-Control: no-cache
    Upgrade-Insecure-Requests: 1
maybe for security reasons

2.13
FROM: in SMTP is required, only left null on notification of errors
From: in mail data is optional
only the From: in mail data is shown to the users as they and their mail server are not communicating on SMTP

2.14
SMTP mark the end with a period on a single line
HTTP uses Content-Length: header to indicate the length of the message body
HTTP cannot use the same method as SMTP, period on its own line is valid HTTP message content

2.15
Mail Transfer Agents
"Jonny" <tennis5@pp33head.com>, others on the chain are MTAs

2.16
it's meant to provide unique ids of mails consistent across sessions:
    "The unique-id of a message is an arbitrary server-determined
    string, consisting of one to 70 characters in the range 0x21
    to 0x7E, which uniquely identifies a message within a
    maildrop and which persists across sessions.  This
    persistence is required even if a session ends without
    entering the UPDATE state.  The server should never reuse an
    unique-id in a given maildrop, for as long as the entity
    using the unique-id exists."

2.17
a.  C: delete 1
    C: quit
    S: +OK POP3 server signing off
b.  C: quit
    S: +OK POP3 server signing off
c.  C: list
    S: 1 <random number>
    S: 2 <random number>
    // user saw no new mails
    C: quit
    S: +OK POP3 server signing off

2.18
a.  quoting from wikipedia:
        "WHOIS (pronounced as the phrase "who is") is a query and response protocol that is widely used for querying
        databases that store the registered users or assignees of an Internet resource, such as a domain name, an IP
        address block or an autonomous system, but is also used for a wider range of other information."
b.  1.1.1.1
    APNIC and Cloudflare DNS Resolver project
    9.9.9.9
    Global Public Recursive DNS Resolver Service
c.  > set type=NS
    > ietf.org
    Server:         8.8.8.8
    Address:        8.8.8.8#53

    Non-authoritative answer:
    ietf.org        nameserver = ns1.hkg1.afilias-nst.info.
    ietf.org        nameserver = ns1.yyz1.afilias-nst.info.
    ietf.org        nameserver = ns1.mia1.afilias-nst.info.
    ietf.org        nameserver = ns1.ams1.afilias-nst.info.
    ietf.org        nameserver = ns0.amsl.com.
    ietf.org        nameserver = ns1.sea1.afilias-nst.info.

    Authoritative answers can be found from:
    > set type=A
    > ietf.org
    Server:         8.8.8.8
    Address:        8.8.8.8#53

    Non-authoritative answer:
    Name:   ietf.org
    Address: 4.31.198.44
    > set type=MX
    > ietf.org
    Server:         8.8.8.8
    Address:        8.8.8.8#53

    Non-authoritative answer:
    ietf.org        mail exchanger = 0 mail.ietf.org.

    Authoritative answers can be found from:
    and exactly the same results from 1.1.1.1
d.  > bing.com
    Server:         1.1.1.1
    Address:        1.1.1.1#53

    Non-authoritative answer:
    Name:   bing.com
    Address: 13.107.21.200
    Name:   bing.com
    Address: 204.79.197.200
    Yes, it has three
e.  It's not an US entity so not registered on ARIN I guess
f.  they can get physical location of the institution with whois database
    they can do all tropes from spy movies instead of hacking the server remotely behind a computer
    nslookup resolves domain to IP, and IP (especially IPv6) indicates physical address
g.  mostly because of oversight: https://whois.icann.org/en/whats-horizon

2.19
a.  // skipped
b.  // will show one entry from each query, there can be 20+ of them in a single query
    $ dig @a.root-servers.net google.com
    com.                    172800  IN      NS      e.gtld-servers.net.
    google.com.             172800  IN      NS      ns2.google.com.
    google.com.             300     IN      A       172.217.160.11
    $ dig @a.root-servers.net ietf.org
    org.                    172800  IN      NS      d0.org.afilias-nst.org.
    ietf.org.               86400   IN      NS      ns1.mia1.afilias-nst.info.
    ietf.org.               300     IN      A       4.31.198.44

2.20
It depends on the strategy of the cache
a well-designed cache usually keeps most used data in it more frequently to reduce miss rate of the most accessed site
sample the cache at different time and the most frequently seen server in the cache probably is the most accessed site 

2.21
by measuring RTT of nslookup from local dns
if a site is accessed recently, its IP should be in cache of the local DNS
nslookup would take no more than a few milliseconds

2.22
./network/application/problems
N = 10, u = 307200 bps, dcs = 7680.000 secs, dp2p = 7680.000 secs
N = 10, u = 716800 bps, dcs = 7680.000 secs, dp2p = 7680.000 secs
N = 10, u = 2097152 bps, dcs = 7680.000 secs, dp2p = 7680.000 secs
N = 100, u = 307200 bps, dcs = 51200.000 secs, dp2p = 25903.557 secs
N = 100, u = 716800 bps, dcs = 51200.000 secs, dp2p = 15616.203 secs
N = 100, u = 2097152 bps, dcs = 51200.000 secs, dp2p = 7680.000 secs
N = 1000, u = 307200 bps, dcs = 512000.000 secs, dp2p = 47558.781 secs
N = 1000, u = 716800 bps, dcs = 512000.000 secs, dp2p = 21524.852 secs
N = 1000, u = 2097152 bps, dcs = 512000.000 secs, dp2p = 7680.000 secs

2.23
a.  transmit to each client with rate us/N
    it's possible as us/N <= d_min <= di for all i, us/N * N = us <= us
    each client will receive the file in time F / (us/N) = NF / us 
b.  transmit to each client with rate d_min
    it's possible as d_min <= di for all i, N * d_min <= us
    each client will receive the file in time F / d_min
c.  immediately follows part a and b

2.24
// thanks Kumar 2006: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.5807&rep=rep1&type=pdf
a.  let si be the transmit rate from server to peer i
    let ul = Σ(i > 0)ui, us <= (ul + us)/N, Nus <= ul + us, ul/(N - 1) >= us
    si = (1 - δ)ui / (N - 1)
    δ = (ul / (N - 1) - us) / (ul / (N - 1))
    0 <= δ <= 1, (N-1)si <= ui, peer i can redistribute the bits it's receiving to all other peers
    Σsi = Σ(i>0)(1 - δ)ui / (N - 1)
        = (1 - δ) / (N - 1) * Σ(i>0)ui
        = (1 - δ) / (N - 1) * ul
        = us
    the rates can be supported by the server
    the file can be distributed in time F/us
b.  let si = ui / (N - 1) + δ for i >= 1
    δ = (us - ul/(N - 1)) / N >= 0
    Σsi = Σ(i>0)ui/(N - 1) + Nδ
        = ul/(N-1) + us - ul(N-1)
        = us
    each peer redistributes ui/(N-1) fresh bits it's receiving from server to other peers
    peer i receives
        ui/(N-1) + δ + Σ(k != i)uk/(N - 1)
        = Σ(i>0)ui/(N-1) + δ
        = ul/(N-1) + (us - ul/(N-1)) / N
        = (us + ul)/N
    and the file can be distributed in time F / ((us + ul)/N) = NF / (us + ul)
c.  immediately follows part a and b

2.25
N nodes and N(N-1)/2 edges
overlay networks is abstracted over routers and such

2.26
a.  possible, if a peer for which Bob is a neighbor, either 
        1.  there's no more than 3 peers supplying data to the peer
        2.  Bob is optimistically unchoked
    Bob will receive data from the peer even if he doesn't upload
b.  the same as part a, but also share data among these computers and these computers only, with a customized client
    some bittorrent clients have this functionality built in

2.27
peer 3 asks its first second successor (peer 4) for its successor (peer 8)
peer 3 replaces its second successor (peer 5) with the answer 

2.28
15 asks 1
1 asks 3
3 asks 4
4 asks 5
5 realizes it's the predecessor of 6, inform 8 and pass the info back to 6

2.29
if all the known peers are stored in a trie, closest peer can be find in a single O(n) traverse of the trie
difference at nth most significant position suppresses all n-1 less significant bits

2.30
possible, two geographically distant peers may be assigned neighboring identifiers
if the DHT passes messages from neighbor to neighbor, the RTT would be huge 

2.31
a.  before taking any input:
    Error: Os { code: 10061, kind: ConnectionRefused, message: "No connection could be made because the target machine actively refused it." }
    error: process didn't exit successfully: `target\debug\tcp_client.exe 4444 5555` (exit code: 1)
    there's no server to accept the TCP handshakes
b.  aaaa // input
    Error: Os { code: 10054, kind: ConnectionReset, message: "An existing connection was forcibly closed by the remote host." }
    error: process didn't exit successfully: `target\debug\udp_client.exe 4444 5555` (exit code: 1)
    UDP socket only found there's no server on trying to send the packet
c.  the same errors

2.32
not necessary, client port is attached to the datagram
before UDPClient has any port number system allocated for it, later it has port number 5432

2.33
for Chrome it's fixed at 6
it reduces the time wasted on RTTs, but may exhaust the socket resource on the server

2.34
the bytes are received in exact the order been sent, no need to reorder them
additional paddings (including length / format info) would be necessary if the message has variable length

2.35
"free and open-source cross-platform web server software"
it's open-source hence free of charge
provides standard HTTP server features (it is the standard btw)

2.36
key: the SHA-1 hash of a torrent
value: address of peers

Socket Assignment 1
./network/application/web-server

Socket Assignment 2
./network/application/udp-ping
packet structure resembles ICMP echo request/reply

Socket Assignment 3
./network/application/mail
successfully sent to local MailSlurper server and ProtonMail
failed on Gmail due to reputation issue

Socket Assignment 4
./network/application/web-proxy
again most accesses to HTTPS sites start with CONNECT method, which this program does not handle

3.1
a.  (A > 1023, 23)
b.  (B > 1023, 23)
c.  (23, A)
d.  (23, B)
e.  possible
f.  possible: they may be different packets in the same connection

3.2
reverse of the source / dest. ports flowing from client to server
reverse of the IPs in the packets from client to server

3.3
./network/transport/problems
00000000 + 01010011 = 01010011
01010011 + 01100110 = 10111001
10111001 + 01110100 = 00101110
complement of the sum is 11010001
CPUs back then and now can detect if the result of the last operation is all zero in bits
without additional bit operations (by status flags)
the same checksum procedure can be reused at sender and receiver
with 1's complement, the receiver computes checksum of the received packet (including the sender checksum)
if the checksum is correct, the result should be all zero in bits
1-bit error will not go undetected:
    change 1 bit in any byte, the new sum is 2^n bigger or smaller than the old sum
    if the new sum didn't overflow, the sum is changed
    if the new sum did overflow, the LSB will change
    if the changed bit is the LSB and it causes overflow, all bits above it in the sum is changed
2-bit error may go undetected:
    e.g. two bytes switch their LSB, sum will not change

3.4
a.  00111110
b.  10111111
c.  01011101, 01100100

3.5
no, refer 3.3

3.6
the receiver do not double ACK an already received packet
assume the following events occurred:
    sender send packet 0
    receiver received packet 0 correctly, send ACK
    sender received corrupted ACK, retransmit packet 0
receiver will be in state "Wait for 1 from below", but all it will receive is retransmission of packet 0
sender will be in state "Wait for ACK or NAK 0", receive only NAK from receiver and stuck

3.7
because it's a stop-and-wait protocol and the link cannot reorder segments
sender will not move to the next sequence number unless the current packet is ACKed
only two packets (and their retransmissions) may be in the link from sender to receiver at any time
which packet is ACKed can be inferred from the ACK field in the packet

3.8
// the same to rdt2.2 receiver
Wait for 0:
    rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && has_seq0(rcvpkt) => {
        extract_data(rcvpkt, data);
        deliver_data(data);
        sndpkt = make_pkt(ACK, 0, checksum);
        udt_send(sndpkt);
        state_transfer();
    },
    rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || has_seq1(rcvpkt) => {
        sndpkt = make_pkt(ACK, 1, checksum);
        udp_send(sndpkt);
    }
Wait for 1:
    // symmetric

3.9
=>  send pkt 0
<=  rcv pkt 0 (corrupted)
    send ACK 1
=>  rcv ACK 1 (corrupted)
    timeout
    send pkt 0

3.10
Wait for call 0 from above:
    rdt_send(data) => {
        sndpkt = make_pkt(0, data, checksum);
        udt_send(sndpkt);
        timer_start();
        state_transfer();
    }
Wait for ACK or NAK 0:
    rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && isACK(rcvpkt) => {
        timer_stop();
        state_transfer();
    },
    rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isNAK(rcvpkt)) => (),
    timeout => {
        udt_send(sndpkt);
        timer_start();
    }
Wait for call 0 from above:
    // symmetric
Wait for ACK or NAK 0:
    // symmetric
if packet is lost, no ACK from receiver, sender timeout in RTT and retransmit
on receiving an ACK or NAK:
    NAK means the packet is corrupted, wait for timeout and retransmit
    ACK means one of the two:
        the receiver is sync with the sender, ACK for the current sequential number
        the receiver is waiting for the next sequential number, ACK for the current sequential number was sent but lost
    both case the sender should move to the next sequential number await for call from above
    by waiting at least RTT before retransmission, sender will never receive an ACK to the last sequential number
    in no situation the sender may move to the next sequential number faster than the receiver
if ACK is lost:
    timeout in RTT and retransmit

3.11
assume the following events occurred:
    =>  send pkt 0
    <=  rcv pkt 0 (move to Wait for 1 from below)
        send ACK 0 (corrupted)
    =>  rcv ACK 0 (corrupted)
        send pkt 0
    =>  (waiting for ACK)
    <=  (waiting for pkg)
if the action is removed, both receiver and sender will deadlock
if the event is removed from Wait for 0 from below, when the first pkg 0 is corrupted
receiver has no action corresponding to the event and deadlock

3.12
for each ACK with wrong sequential number the sender will retransmit the packet
assume the following events occurred:
    =>  send pkt 0
    <=  rcv pkt 0 (corrupted)
        send ACK 1 (delayed)
    =>  (timeout) send pkt 0
        rcv ACK 1
        send pkt 0
if the link is congested, number of retransmission may grow linearly, packet n may be transmitted n times

3.13
assume the following events occurred:
    =>  send pkt 0
    <=  rcv pkt 0
        send ACK 0 (delayed), move to state 1
    =>  (timeout) send pkt 0
    =>  rcv ACK 0, move to state 1
        send pkt 1
    <=  rcv pkt 1
        send ACK 1, move to state 0
    =>  rcv ACK 1, move to state 0
        send pkt 0 (lost)
    <=  rcv pkt 0 (delayed)
        send ACK 0, move to state 1
    =>  rcv ACK 0, move to state 1
second pkt 0 is lost, but sender receives an old ACK 0 and moves to the next sequential number
second pkt 0 will never be retransmitted

3.14
without ACK, there's no way to implement a pipelined sender: all packets sent so far has to be cached
sender by no means can confirm if a packet is correctly sent or an NAK is awfully delayed
in stop-and-wait protocol, when data is sent infrequently,
    when there's no response from receiver, sender will send packets anyway
    receiver may only detect packet loss when there's gaps in the packets received
    may be minutes later to when the packet is sent
when data is sent frequently with few bit errors:
    receiver will detect packet loss relatively fast, an NAK will arrive at sender almost immediately
    it's similar to GBN protocol, even though required cache size is still unbounded

3.15
ignore propagation delay, RTT = 30msec
let window size be w packets
    0.98 * 1Gbps * 30msec <= w * 1500byte
    w >= 2631

3.16
sender upon receiving ACK corresponding to its state will advance and send the next packet immediately
it defeats all design principles of rdt3.0, nothing holds anymore
e.g. lost packets are not retranmitted

3.17
Host A
Await:
    rdt_send(data) => {
        rdt_unable_to_send(data); 
    }
    rdt_rcv(packet) => {
        extract(packet, data);
        deliver_data(data);
        move_to_state(Ready);
    }
Ready (Init):
    rdt_send(data) => {
        packet = make_pkt(data);
        udt_send(packet);
        move_to_state(Await);
    }
    rdt_rcv(packet) => {
        // should be impossible
    }
Host B
// symmetric, init state is Await

3.18
// assume initial sequential number is established during handshaking 
Sender
    Data0
        rdt_send(data) => {
            packet0 = make_pkt(data, sn + 1);
            udt_send(packet0);
            move_to_state(Data1);
        }
    Data1
        rdt_send(data) => {
            packet1 = make_pkt(data, sn + 2);
            udt_send(packet1);
            timer_start();
            move_to_state(Await);
        }
    Await
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 1 => {
            move_to_state(Await1);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 2 => {
            move_to_state(Await0);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn <= sn => {
            // ignore duplicated ACK
        }
        timeout => {
            udt_send(packet0);
            udt_send(packet1);
            timer_start();
        }
    Await0
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 1 => {
            timer_stop();
            sn += 2;
            move_to_state(Data0);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn != sn + 1 => {
            // ignore other ACK
        }
        timeout => {
            udt_send(packet0);
            timer_start();
        }
    Await1
    // symmetric to Await0
Receiver
    Await
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 1 => {
            extract_data(rcvpkt, data0);
            packet = make_pkt(ACK, sn + 1);
            udt_send(packet);
            move_to_state(Await1);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 2 => {
            extract_data(rcvpkt, data1);
            packet = make_pkt(ACK, sn + 2);
            udt_send(packet);
            move_to_state(Await0);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn <= sn => {
            // duplicated ACK
            packet = make_pkt(ACK, rcvpkt.sn);
            udt_send(packet);
        }
    Await0
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn + 1 => {
            extract_data(rcvpkt, data1);
            deliver_data(data0);
            deliver_data(data1);
            packet = make_pkt(ACK, sn + 1);
            udt_send(packet);
            sn += 2;
            move_to_state(Await);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn != sn + 1 => {
            // duplicated ACK
            packet = make_pkt(ACK, rcvpkt.sn);
            udt_send(packet);
        }
    Await1
    // symmetric to Await0
if first packet is lost:
    =>  send pkt sn + 1 (lost), => Data1
        send pkt sn + 2, => Await
    <=  rcv pkt sn + 1
        send ACK sn + 1, => Await1
    =>  rcv ACK sn + 1, => Await1
    =>  (timeout) send pkt sn + 2
    <=  rcv pkt sn + 2
        send ACK sn + 2, => Await
    =>  rcv ACK sn + 2, => Data0
if second ACK is lost:
    =>  send pkt sn + 1, => Data1
        send pkt sn + 2, => Await
    <=  rcv pkt sn + 1
        send ACK sn + 1, => Await1
    <=  rcv pkt sn + 2
        send ACK sn + 2 (lost), Await
    =>  rcv ACK sn + 1, => Await1
    =>  (timeout) send pkt sn + 2
    <=  rcv pkt sn + 2 (current sn' = sn + 2, duplicated ACK)
        send ACK sn + 2
    =>  rcv ACK sn + 2, => Data0

3.19
Host A
// should be almost the same to 3.18
// instead of two different packets from the same host, it's two identical packets from different hosts
// initial sequential bit is established in protocol or during handshake
    Data
        rdt_send(data) => {
            packet = make_pkt(data);
            udt_send(packet, sn);
            timer_start();
            move_to_state(Await);
        }
    Await
        rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && rcvpkt.sn == sn && rcvpkt.sender = B => {
            move_to_state(AwaitC);
        }
        rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && rcvpkt.sn == sn && rcvpkt.sender = C => {
            move_to_state(AwaitB);
        }
        rdt_rcv(rcvpkt) && (corrupted(rcvpkt) || rcvpkt.sn != sn) => {
            // ignore corrupted or delayed ACK
        }
        timeout => {
            udt_send(packet);
            timer_start();
        }
    AwaitB
        rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && rcvpkt.sn == sn && rcvpkt.sender = B => {
            // flip sequential bit
            sn = !sn;
            move_to_state(Data);
        }
        rdt_rcv(rcvpkt) && (corrupted(rcvpkt) || rcvpkt.sn != sn || revpkt.sender != B) => {
            // ignore corrupted, delayed or duplicated ACK
        }
        timeout => {
            udt_send(packet);
            timer_start();
        }
    AwaitC
    // symmetric
Host B
    Await
        rdt_rcv(rcvpkt) && not_corrupt(rcvpkt) && rcvpkt.sn == sn => {
            extract_data(rcvpkt, data);
            deliver_data(data);
            packet = make_pkt(ACK, sn, B);
            udt_send(packet);
            sn = !sn;
        }
        rdt_rcv(rcvpkt) && (corrupted(rcvpkt) || rcvpkt.sn != sn) => {
            // for both corrupted and delayed data
            // channel cannot reorder packets, different sn must be last packet
            packet = make_pkt(ACK, !sn, B);
            udt_send(packet);
        }
Host C
// symmetric
sender packet format:
    source port
    target port
    data length
    checksum
    sequential number
    data
receiver ACK packet format:
    source port
    target port
    checksum
    sequential number
    machine number (B or C)

3.20
separate rdt3.0 for both A -> C and B -> C with application layer protocol reading data from them alternatively
in a single FSM: rdt3.0 receiver with duplicated states for each sender

3.21
Host A
    Request
        rdt_request => {
            packet = make_pkt(R, sn);
            udt_send(packet);
            timer_start();
            move_to_state(Await);
        }
    Await
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn => {
            extract_data(rcvpkt, data);
            deliver_data(data);
            sn += 1;
            move_to_state(Request);
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn != sn => {
            // cannot happen: B => A channel is reliable, data with each sequential number is sent once
        }
        timeout => {
            udt_send(packet);
            timer_start();
        }
Host B
    Await
        rdt_rcv(rcvpkt) && rcvpkt.sn == sn => {
            udt_send(D);
            sn += 1;
        }
        rdt_rcv(rcvpkt) && rcvpkt.sn < sn => {
            // duplicated request
        }
request packet format:
    source port
    target port
    sequential number
    request R
data packet format:
    source port
    target port
    sequential number
    data D

3.22
a.  min:
        sender has sent packet with sn k - 1, it may not be ACKed (the ACK packet may be lost or delayed)
        if the packet in sender's window with minimum sn is earlier than k - 1, packet k - 1 is in the window too
        k - 1 - (4 - 1) = k - 4 is the minimum possible sn in the window
    max:
        receiver didn't send ACK for sn = k
        if sender received ACK for all packets up to k - 1, its window starts with k
        k + 3 is the maximum possible sn in the window
b.  sender sent packet k - 1, it must has received ACK for sn = k - 5, otherwise k - 1 is not in the window
    ACKs sent by receiver have non-decreasing sn:
        when receiver is expecting sn = k, all ACK from it has sn <= k
    ACK with sn = k - 5 arrived, currently expecting sn = k, channel cannot reorder packets
    [k - 5, k - 1] are the possible sn in ACK field of packets in the channel
    k - 5 is possible in response to a delayed retransmission of packet k - 5

3.23
let w be window size, receiver is expecting sn = n
GBN:
    as arguments in 3.22, sn - w - 1 cannot wrap to sn + w - 1 or a wrong packet will be ACKed
    sn + w - 1 - (sn - w - 1) < k, 2w < k, w < k/2
SR:
    assume the next in-order packet the receiver is expecting is n
    min and max: same to GBN
    ACKs in the channel:
        earliest ACK is same to GBN
        SR protocol may also send ACK for out-of-order packets up to n + w - 1
    w < k/2 again

3.24
a.  true; with window size = 1, SR is equivalent to stop-and-wait rdt3.0
    rdt3.0 sender may receive delayed ACK for earlier sn
b.  true; same to part a
c.  true; with window size 1 there's no cumulative acknowledgement
d.  true; with window size 1 there's no out-of-order acknowledgement

3.25
a.  UDP packet sizes are decided by the application layer caller on each call
    TCP packet sizes are decided by MSS and the data may be segmented arbitrarily by the TCP implementation
b.  UDP has no congestion control, a packet is sent immediately when called from above
    TCP may buffer the data if it's not in the sender's window or outright deny it

3.26
a.  2^32 = 4GB
b.  4GB * ((536 + 66) / 536) / 155Mbps = 237.438s

3.27
a.  sn = 207
    source port = 302
    dest port = 80
b.  ack = 207
    source port = 80
    dest port = 302
c.  ack = 127
    source port = 80
    dest port = 302
d.  =>  send pkt { sn = 127, length = 80 }
    =>  send pkt { sn = 207, length = 40 }
    <=  rcv pkt { sn = 127, length = 80 }
        send ACK { sn = 207 } (lost)
    <=  rcv pkt { sn = 207, length = 40 }
        send ACK { sn = 247 }
    =>  (timeout) send pkt { sn = 127, length = 80 }
    =>  rcv ACK { sn = 247 }
    <=  rcv pkt { sn = 127, length = 80 }
        send ACK { sn = 247 }
    =>  rcv ACK { sn = 247 }

3.28
flow control happens at two places:
1.  the application on Host A will eventually fill the buffer of TCP sender, blocking the thread or get IO error
2.  ACKs from Host B to Host A will have smaller and smaller rwnd field
    once rwnd <= current un-ACKed bytes in sender's window sender will stop sending new packets

3.29
a.  to protect itself from SYN flood attack
    with SYN cookies, to create an open / half open TCP connection on the server
    the attacker must maintain one TCP connection with the server for at least one RTT
    which significantly reduces the intensity of possible attacks
b.  no, it must maintain TCP connection for one RTT
    hash function is computationally impractical to reverse
    the attacker cannot forge the cookie without actually knowing the secret number
c.  no, the cookie contains information of both the source and target IP
    cookies collected from other hosts with different IP would be found invalid when server received the ACK
    in practice SYN cookies also contain temporal information
    even cookies collected on the same host won't be valid most of the time

3.30
a.  assume the link from router to target host has small transmission rate compared to source to router links
    naturally packets will pile up at the router
    if the router has small buffer they are lost and after timeout sender will retransmit them
    if the router has big buffer they still will be retransmitted
    however this time the buffered packets will be transmitted too, wasting more channel capacity
b.  the maximum achievable throughput won't be improved (limited by links)
    if the senders can eliminate retransmission of buffered packets entirely
    from sender's view the receiver are having bigger buffer, hence bigger rwnd and it might help increasing throughput

3.31
./network/transport/problems
after observed sample rtt = 106ms, EstimatedRTT = 100ms, DevRTT = 5ms, TimeoutInterval = 120ms
after observed sample rtt = 120ms, EstimatedRTT = 102ms, DevRTT = 8ms, TimeoutInterval = 134ms
after observed sample rtt = 140ms, EstimatedRTT = 106ms, DevRTT = 14ms, TimeoutInterval = 162ms
after observed sample rtt = 90ms, EstimatedRTT = 104ms, DevRTT = 14ms, TimeoutInterval = 160ms
after observed sample rtt = 115ms, EstimatedRTT = 105ms, DevRTT = 13ms, TimeoutInterval = 157ms

3.32
a.  αΣ(1 <= i <= 5)RTTi(1-α)^(i-1), where RTT5 is the estimated RTT before observing RTT4
b.  αΣ(1 <= i <= n+1)RTTi(1-α)^(i-1), where RTTn+1 is the estimated RTT before observing RTTn
c.  earlier observations has exponentially diminishing weights in the sum

3.33
the sender cannot be sure whether the ACK is in response to the original packet or the retransmission

3.34
LastByteRcvd is the last byte received in order, receiver has sent ACK for the packet containing the byte
also LastByteRcvd is the maximum sn the receiver has sent in ACK field so far
if the ACK is received by the sender, SendBase = LastByteRcvd + 1 (all following packets are not ACKed)
otherwise SendBase <= LastByteRcvd

3.35
there is an ACK packet from receiver with y = LastByteRcvd + 1, while it may be lost 

3.36
referring https://tools.ietf.org/html/rfc2001#section-3
    "Since TCP does not know whether a duplicate ACK is caused by a lost
    segment or just a reordering of segments, it waits for a small number
    of duplicate ACKs to be received.  It is assumed that if there is
    just a reordering of the segments, there will be only one or two
    duplicate ACKs before the reordered segment is processed, which will
    then generate a new ACK.  If three or more duplicate ACKs are
    received in a row, it is a strong indication that a segment has been
    lost.  TCP then performs a retransmission of what appears to be the
    missing segment, without waiting for a retransmission timer to
    expire."

3.37
a.  GBN:
        =>  5 packets first, 4 more packets after timeout
        <=  4 ACKs for the first group, 4 more for the retransmission
    SR:
        =>  5 packets first, 1 more packets after timeout
        <=  4 ACKs for the first group, 1 more for the retransmission
    TCP:
        =>  5 packets
            (timeout if no fast retransmit)
            1 packet
            1 packet
            1 packet
            1 packet
        <=  4 ACKs (all with same sn)
            1 ACK
            1 ACK
            1 ACK
            1 ACK
b.  TCP with fast retransmit

3.38
sending rate is approximately cwnd / RTT since sender can only send cwnd bytes before stopping and waiting for ACK
when RTT is not the limiting factor (e.g. transmit rate is low), cwnd may not reflect the true rate

3.39
no premature timeout:
    link capacity is exhausted, increase λin anymore and the new packets will all lost
    higher proportion of packets will lost, causing more retransmission
    fewer packets among R/2 would be original packets, λ_out would be lower
premature timeout:
    maximum rate from sender to route is R/2
    maximum rate from router to receiver is (R/2)/2 = R/4
    increasing λ'_in cannot increase λ_out

3.40
a.  [0, 6] and [23, 26], cwnd is increasing exponentially
b.  [6, 16] and [17, 22], cwnd is increasing linearly
c.  by triple duplicated ACK, cwnd is roughly halved
d.  by timeout, cwnd is set to 1
e.  32, shown by transfer from slow start to congestion avoidance at 6
f.  21, 42 / 2 on triple duplicated ACK
g.  14, 29 / 2 on timeout
h.  7
i.  ssthresh = 8 / 2 = 4
    cwnd = ssthresh + 3 = 7
j.  ssthresh = 42 / 2 = 21
    cwnd = 1 + (18 - 17) = 2
k.  (1 + 6) * 6 / 2 = 21

3.41
no, the throughput of 1 and 2 will go back and forth on the same line
increase the same amount in congestion avoidance, cause timeout, then decrease the same constant amount

3.42
TCP is a pipelined protocol
without cwnd, long timeout would not stop sender from sending packets into the channel

3.43
not flow control: rwnd is too big to be a limitation
not congestion control: no loss or duplicated ACK
when send buffer is full, TCP socket will block the application thread or return IO error

3.44
a.  6RTT
b.  (1 + 6) * 6 / 2 MSS / 6RTT
    = 3.5MSS / RTT

3.45
a.  during a period, total number of packets sent is 
        Σ(W/2 <= i <= W)i
        = (W/2 + W) * (W/2 + 1) / 2
        = 3W^2/8 + 3W/4
    among which a single packet is lost, lost rate is 1/(3W^2/8 + 3W/4)
b.  L = 1/(3W^2/8 + 3W/4)
    3W^2/8 + 3W/4 - 1/L = 0
    W^2 + 2W - 8/3L = 0
    W = ((3L + 8) / 3L)^(1/2) - 1
    asymptotically W^2 = 8L/3, W = (8/3L)^(1/2) = 1.633L^(1/2)
    average rate = 0.75W MSS / RTT = 1.225 / L^(1/2) MSS/RTT

3.46
a.  W * MSS / RTT = 10Mbps
    W * 1500byte / 0.15sec = 10Mbps
    W = 10 * 1024^2 * 0.15 / (1500 * 8) = 131.072 segments
b.  average window size = 0.75W = 98.304 segments
    average throughput = 0.75W / RTT = 7.5Mbps
c.  W / 2 = 65.536 secs

3.47
let wb be window size in bytes
wb = 1500byte * W = 10Mbps * 0.15sec = C * RTT
with any smaller window size the TCP sender won't be able to send packets quick enough

3.48
a.  W = 10 * 1024^3 * 0.15 / (1500 * 8) = 134217.728 segments
b.  average window size = 0.75W = 100663.296 segments
    average throughput = 0.75W MSS / RTT = 7.5Gbps
c.  W / 2 = 67108.864 secs
    possible solution: switch to TCP CUBIC

3.49
average throughput = W' = 0.75W / RTT
T = W/2 = W' * RTT / 0.75

3.50
./network/transport/problems
a.  at the end of t =   50ms, C1.cwnd = 5,C2.cwnd = 10,
    at the end of t =  100ms, C1.cwnd = 3,C2.cwnd = 5,
    at the end of t =  150ms, C1.cwnd = 2,C2.cwnd = 5,
    at the end of t =  200ms, C1.cwnd = 1,C2.cwnd = 3,
    at the end of t =  250ms, C1.cwnd = 1,C2.cwnd = 3,
    at the end of t =  300ms, C1.cwnd = 1,C2.cwnd = 2,
    at the end of t =  350ms, C1.cwnd = 1,C2.cwnd = 2,
    at the end of t =  400ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  450ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  500ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  550ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  600ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  650ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  700ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  750ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  800ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  850ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t =  900ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  950ms, C1.cwnd = 2,C2.cwnd = 1,
    at the end of t = 1000ms, C1.cwnd = 1,C2.cwnd = 1,
b.  no, C1 with shorter rtt will receive ack more frequently, has more chance to increase its cwnd

3.51
./network/transport/problems
a.  at the end of t =  100ms, C1.cwnd = 8,C2.cwnd = 5,
    at the end of t =  200ms, C1.cwnd = 4,C2.cwnd = 3,
    at the end of t =  300ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t =  400ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  500ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t =  600ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  700ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t =  800ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t =  900ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1000ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1100ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1200ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1300ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1400ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1500ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1600ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1700ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 1800ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 1900ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 2000ms, C1.cwnd = 1,C2.cwnd = 1,
    at the end of t = 2100ms, C1.cwnd = 2,C2.cwnd = 2,
    at the end of t = 2200ms, C1.cwnd = 1,C2.cwnd = 1,
b.  yes
c.  yes, they have the same rtt
    when the link capacity is exceeded all cwnd will be penalized at the same time
    when the link capacity is not exceeded all cwnd will increase at the same time
    maximum cwnd is 2 for both of them
d.  no, synchronized hosts will increase / decrease cwnd at the same time
    either waste link capacity or experience lost at the same time, amplitude of total sending rate will be bigger
    this phenomenon is called "TCP global synchronization"
    and is addressed by a mechanism called "random early detection (RED)"
    by which packets are dropped with different probability for different hosts

3.52
total number of packets send before a loss is
    Σ(0 <= i <= k)(W/2) * (1 + a)^i, where (1 + a)^k = 2, k = log(1 + a, 2)
    = (W/2)(1 - (1 + a)^(k + 1)) / (1 - (1 + a))
    = (W/2)(1 - 2(1 + a)) / -a
    = (W/2)(-2a - 1) / -a
    = (W/2)(1 + 2a) / a
    = W(1 + 2a)/2a
lost rate is
    L = 2a / W(1 + 2a)
this algorithm spends log(1 + a, 2) to increase its congestion window size from W/2 to W, independent to W

3.53
L   = (1.22 * MSS / (RTT * B))^2
    = 1.859e-12

3.54
pro:    TCP will resume at speed in the range [W/2, W], utilizing more link capacity than slow start
con:    W estimation through cwnd and ssthresh may not be accurate anymore due to congestion or other connections
        TCP may experience or cause packet loss
alternative: start with cwnd = 1 and do slow start

3.55
a.  response will go to address Y
b.  the server can be certain, it sent SYNACK to the address Y and got a valid response

3.56
after sending a packet, ACK will come back in time RTT
let cwnd = k * pkt, if (k - 1)S/R < RTT, kS/R < S/R + RTT, the server have to wait for another ACK
otherwise the server can send packets at full speed
a.  4S/R > S/R + RTT > 2S/R
    0:      =>  send ACK    
    0.5RTT: <=  rcv ACK, send SYNACK
    1RTT:   =>  rcv SYNACK, send request
    1.5RTT: <=  rcv request, start sending pkt 0
    S/R + 1.5RTT    <=  send pkt  
    S/R + 2.0RTT    =>  rcv pkt 0, send ACK 0
    S/R + 2.5RTT    <=  rcv ACK 0, cwnd = 2, start sending pkt 1 and 2
    2S/R + 2.5RTT   <=  send pkt 1
    3S/R + 2.5RTT   <=  send pkt 2
    2S/R + 3.0RTT   =>  rcv pkt 1, send ACK 1
    3S/R + 3.0RTT   =>  rcv pkt 2, send ACK 2
    2S/R + 3.5RTT   <=  rcv ACK 1, cwnd = 3, start sending pkt 3, 4 and 5
    3S/R + 3.5RTT   <=  rcv ACK 2, cwnd = 4, send pkt 3, start sending pkt 6, wait no more
    pkt 14 will be sent at time 3S/R + 3.5RTT + 11S/R = 14S/R + 3.5RTT
    will be received at time 14S/R + 4RTT
a pair of lists [a, b], [c, d] indicates the congestion window where a, b were sent, c, d can be sent but not yet
sum of length of the two lists should be cwnd / MSS
b.  RTT > 4S/R
    0:      =>  send ACK    
    0.5RTT: <=  rcv ACK, send SYNACK
    1RTT:   =>  rcv SYNACK, send request
    1.5RTT: <=  rcv request, cwnd = 1, [], [0]
    S/R + 1.5RTT    <=  [0], []
    S/R + 2.0RTT    =>  rcv pkt 0, send ACK 0
    S/R + 2.5RTT    <=  rcv ACK 0, cwnd = 2, [], [1, 2]
    2S/R + 2.5RTT   <=  [1], [2]
    3S/R + 2.5RTT   <=  [1, 2], []
    2S/R + 3.0RTT   =>  rcv pkt 1, send ACK 1
    3S/R + 3.0RTT   =>  rcv pkt 2, send ACK 2
    2S/R + 3.5RTT   <=  rcv ACK 1, cwnd = 3, [2], [3, 4]
    3S/R + 3.5RTT   <=  rcv ACK 2, cwnd = 4, [3], [4, 5, 6]
    4S/R + 3.5RTT   <=  [3, 4], [5, 6]
    5S/R + 3.5RTT   <=  [3, 4, 5], [6]
    6S/R + 3.5RTT   <=  [3, 4, 5, 6], []
    3S/R + 4RTT     =>  rcv pkt 3, send ACK 3
    4S/R + 4RTT     =>  rcv pkt 4, send ACK 4
    5S/R + 4RTT     =>  rcv pkt 5, send ACK 5
    6S/R + 4RTT     =>  rcv pkt 6, send ACK 6
    3S/R + 4.5RTT   =>  rcv ACK 3, cwnd = 5, [4, 5, 6], [7, 8]
    cwnd will grow to 8 with 8 packets remaining, all will be sent in a row
    7 will be sent at 4S/R + 4.5RTT, 14 will be sent at 11S/R + 4.5RTT and received at 11S/R + 5RTT
c.  S/R > RTT
    0:      =>  send ACK    
    0.5RTT: <=  rcv ACK, send SYNACK
    1RTT:   =>  rcv SYNACK, send request
    1.5RTT: <=  rcv request, cwnd = 1, [], [0]
    S/R + 1.5RTT    <=  [0], []
    S/R + 2.0RTT    =>  rcv pkt 0, send ACK 0
    S/R + 2.5RTT    <=  rcv ACK 0, cwnd = 2, [], [1, 2]
    2S/R + 2.5RTT   <=  [1], [2]
    server at full speed from now on
    pkt 1 is sent at 2S/R + 2.5RTT, pkt 14 will be sent at 15S/R + 2.5RTT and received at 15S/R + 3RTT

Assignment
./network/transport/gbn
log of a test run, sending u32 numbers from 0 to 19
rtt: 100ms, loss rate: 10%, corrupt rate: 10%, sending window: 4, sending timeout: 1000ms
[2019-09-30T14:05:43Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 0]
[2019-09-30T14:05:43Z INFO  gbn::protocol] Send packet: Packet { sn = 0, data = [0, 0, 0, 0] }
[2019-09-30T14:05:43Z INFO  gbn::channel] Channel lost packet: Packet { sn = 0, data = [0, 0, 0, 0] }
[2019-09-30T14:05:43Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 1]
[2019-09-30T14:05:43Z INFO  gbn::protocol] Send packet: Packet { sn = 1, data = [0, 0, 0, 1] }
[2019-09-30T14:05:43Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 2]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Send packet: Packet { sn = 2, data = [0, 0, 0, 2] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 3]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Send packet: Packet { sn = 3, data = [0, 0, 0, 3] }
[2019-09-30T14:05:44Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 3, data = [0, 0, 0, 3] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 4]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 5]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 6]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 1, data = [0, 0, 0, 1] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 7]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver send ACK 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 8]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 9]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 10]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 11]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 12]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 13]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 14]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 15]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 16]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 17]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 18]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Received data from upper layer: [0, 0, 0, 19]
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 2, data = [0, 0, 0, 2] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver send ACK 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver send ACK 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Sender received packet: ACK { sn = 4294967295 }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Duplicated ACK to packet 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Sender received packet: ACK { sn = 4294967295 }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Duplicated ACK to packet 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Sender received packet: ACK { sn = 4294967295 }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Duplicated ACK to packet 4294967295
[2019-09-30T14:05:44Z INFO  gbn::protocol] Sender timed out, retransmitting unacknowledged packets
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmitting packet 0
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmitting packet 1
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 0, data = [0, 0, 0, 0] }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmitting packet 2
[2019-09-30T14:05:44Z INFO  gbn::protocol] Receiver send ACK 0
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmitting packet 3
[2019-09-30T14:05:44Z INFO  gbn::channel] Channel lost packet: ACK { sn = 0 }
[2019-09-30T14:05:44Z INFO  gbn::protocol] Retransmission done, restart sender timer
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 1, data = [0, 0, 0, 1] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 1
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 2, data = [0, 0, 0, 2] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 2
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 3, data = [0, 0, 0, 3] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 3
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 1 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 0
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 1
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 4, data = [0, 0, 0, 4] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 5, data = [0, 0, 0, 5] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 2 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 2
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 6, data = [0, 0, 0, 6] }
[2019-09-30T14:05:45Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 6, data = [0, 0, 0, 6] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 3 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 3
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 7, data = [0, 0, 0, 7] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 4, data = [0, 0, 0, 4] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 4
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 5, data = [0, 0, 0, 5] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::channel] Channel lost packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 7, data = [0, 0, 0, 7] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 4 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 4
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 8, data = [0, 0, 0, 8] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] ACKed packet 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Send packet: Packet { sn = 9, data = [0, 0, 0, 9] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 8, data = [0, 0, 0, 8] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 9, data = [0, 0, 0, 9] }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:45Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:45Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Sender timed out, retransmitting unacknowledged packets
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmitting packet 6
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmitting packet 7
[2019-09-30T14:05:46Z INFO  gbn::channel] Channel lost packet: Packet { sn = 6, data = [0, 0, 0, 6] }
[2019-09-30T14:05:46Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 7, data = [0, 0, 0, 7] }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmitting packet 8
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmitting packet 9
[2019-09-30T14:05:46Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 8, data = [0, 0, 0, 8] }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Retransmission done, restart sender timer
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 9, data = [0, 0, 0, 9] }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Receiver send ACK 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:46Z INFO  gbn::protocol] Sender received packet: ACK { sn = 5 }
[2019-09-30T14:05:46Z INFO  gbn::protocol] Duplicated ACK to packet 5
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender timed out, retransmitting unacknowledged packets
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmitting packet 6
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmitting packet 7
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmitting packet 8
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmitting packet 9
[2019-09-30T14:05:47Z INFO  gbn::protocol] Retransmission done, restart sender timer
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 6, data = [0, 0, 0, 6] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 6
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 7, data = [0, 0, 0, 7] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 7
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 8, data = [0, 0, 0, 8] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 8
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 9, data = [0, 0, 0, 9] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 9
[2019-09-30T14:05:47Z INFO  gbn::channel] Channel lost packet: ACK { sn = 9 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 6 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 6
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 10, data = [0, 0, 0, 10] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 7 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 7
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 11, data = [0, 0, 0, 11] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 8 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 8
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 12, data = [0, 0, 0, 12] }
[2019-09-30T14:05:47Z INFO  gbn::channel] Channel corrupted packet: Packet { sn = 12, data = [0, 0, 0, 12] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 10, data = [0, 0, 0, 10] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 10
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 11, data = [0, 0, 0, 11] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: CORRUPTED
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 10 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 9
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 10
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 13, data = [0, 0, 0, 13] }
[2019-09-30T14:05:47Z INFO  gbn::channel] Channel lost packet: Packet { sn = 13, data = [0, 0, 0, 13] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 14, data = [0, 0, 0, 14] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 11 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] ACKed packet 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Send packet: Packet { sn = 15, data = [0, 0, 0, 15] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 11 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Duplicated ACK to packet 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 14, data = [0, 0, 0, 14] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 15, data = [0, 0, 0, 15] }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Receiver send ACK 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 11 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Duplicated ACK to packet 11
[2019-09-30T14:05:47Z INFO  gbn::protocol] Sender received packet: ACK { sn = 11 }
[2019-09-30T14:05:47Z INFO  gbn::protocol] Duplicated ACK to packet 11
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender timed out, retransmitting unacknowledged packets
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmitting packet 12
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmitting packet 13
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmitting packet 14
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmitting packet 15
[2019-09-30T14:05:48Z INFO  gbn::protocol] Retransmission done, restart sender timer
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 12, data = [0, 0, 0, 12] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 12
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 13, data = [0, 0, 0, 13] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 13
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 14, data = [0, 0, 0, 14] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 14
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 15, data = [0, 0, 0, 15] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 15
[2019-09-30T14:05:48Z INFO  gbn::channel] Channel lost packet: ACK { sn = 15 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 12 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 12
[2019-09-30T14:05:48Z INFO  gbn::protocol] Send packet: Packet { sn = 16, data = [0, 0, 0, 16] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 13 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 13
[2019-09-30T14:05:48Z INFO  gbn::protocol] Send packet: Packet { sn = 17, data = [0, 0, 0, 17] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 14 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 14
[2019-09-30T14:05:48Z INFO  gbn::protocol] Send packet: Packet { sn = 18, data = [0, 0, 0, 18] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 16, data = [0, 0, 0, 16] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 16
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 17, data = [0, 0, 0, 17] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 17
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 18, data = [0, 0, 0, 18] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 18
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 16 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 15
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 16
[2019-09-30T14:05:48Z INFO  gbn::protocol] Send packet: Packet { sn = 19, data = [0, 0, 0, 19] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 17 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 17
[2019-09-30T14:05:48Z INFO  gbn::protocol] Sender received packet: ACK { sn = 18 }
[2019-09-30T14:05:48Z INFO  gbn::protocol] ACKed packet 18
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver received packet: Packet { sn = 19, data = [0, 0, 0, 19] }
[2019-09-30T14:05:48Z INFO  gbn::protocol] Receiver send ACK 19
[2019-09-30T14:05:48Z INFO  gbn::protocol] Channel disconnected / terminate signal received, tear down sender
[2019-09-30T14:05:48Z INFO  gbn::channel] Channel disconnected
[2019-09-30T14:05:48Z INFO  gbn::protocol] Terminate signal received, tear down receiver
[2019-09-30T14:05:48Z INFO  gbn::channel] Channel disconnected
[2019-09-30T14:05:48Z WARN  gbn::channel] Send terminate but the receiver was already dropped

4.1
a.  in favor of datagram. a single point of failure usually will break a whole VC which must then be reestablished
    according to lengthy and complicated protocol, while datagram architecture may detect the point of failure and 
    route packets through an other router
b.  in favor of VC, one may even argue that any protocol that reserves resource on router for a particular connection
    is indeed VC
c.  VC will have more overhead, a VC have to be established somehow before transmitting packets, on the other hand
    datagram protocol can send packets from the start

4.2
a.  2^8 = 256
b.  impossible, all link along the path is assigned the same VC number, if < 256 VCs are in progress there must be free
    VC numbers
c.  for a router B on the path, let A be the previous router on the path and be C the succeeding router on the path 
    B is informed about the VC number x along A -> B link of this particular VC 
    B chooses an arbitrary unused VC number y on the link B -> C, informs C about this number
    B adds an entry that sends packets from (the corresponding interface of) A with VC number x to C with VC number y

4.3
VC:
    incoming interface, incoming VC number, outgoing interface, outgoing VC number
datagram:
    destination IP, outgoing interface

4.4
a.  H3 -> 3
b.  no, datagram forwarding table is independent to source IP
c.  1, <VC number H1A>, 3, <VC number AB>
    2, <VC number H2A>, 4, <VC number AC>
d.  B:
        1, <VC number AB>, 2, <VC number BD>
    C:
        1, <VC number AC>, 2, <VC number CD>
    D:
        1, <VC number BD>, 3, <VC number DH3-1>
        2, <VC number CD>, 3, <VC number DH3-2>

4.5
a.  no VC number can be assigned, all VC number is occupied in at least one of the links
b.  2^4 = 16

4.6
in a connection-oriented service, there may not be an actual underlying connection in network-layer, e.g. TCP can be
built on IP protocol and datagram, while in a connection service like VC there is a connection in network-layer

4.7
a.  no, only one packet may enter a shared bus at a time
b.  yes as described in section 4.3.2 
c.  no as described in section 4.3.2, only one packet can be sent through a bus, the second has to wait

4.8
a.  (n-1)D, where D = t_read + t_process + t_write for a single packet
    all n - 1 packets before the last one must be read, processed and written to the output bus until the final packet 
    may be forwarded
b.  (n-1)D, where D = t_prepend_tag + t_bus_read + t_output
    almost the same to memory switch, t_bus_read and t_prepend_tag may be significantly faster than t_read and t_process
c.  0 in most optimistic case, all packets can be sent to their destination concurrently

4.9
minimal:
    ([x], [xy], [zy])
    ([], [x], [z])
    ([], [], [])
worst:
    ([x], [xy], [zy])
    ([], [xy], [y])     // input 2 blocking on x
    ([], [y], [])
    ([], [], [])

4.10
a.  224.0.0.0/10    0
    224.64.0.0/16   1
    224.65.0.0/16   2
    224.32.0.0/10   2
    otherwise       3
b.  11001000 10010001 01010001 01010101
    no prefix matches, otherwise -> interface 3
    11100001 01000000 11000011 00111100
    matches 224.32.0.0/10, interface 2
    11100001 10000000 00010001 01110111
    no prefix matches, otherwise -> interface 3

4.11
00000000 - 00111111     0
01000000 - 01011111     1
01100000 - 10111111     2
11000000 - 11111111     3

4.12
10000000 - 10111111     1
11000000 - 11011111     0
11100000 - 11111111     2
otherwise               3

4.13
223.1.17.0/28   Subnet 3    // 16 IPs
223.1.17.0/25   Subnet 1    // 128 - 16 = 112 IPs
223.1.17.128/25 Subnet 2    // 128 IPs

4.14
200.23.16.0/21  0
200.23.24.0/24  1
200.23.24.0/21  2
otherwise       3

4.15
already in decimal notation

4.16
128.119.40.128 is itself an IP can be assigned to this network
128.119.40.64/28
128.119.40.80/28
128.119.40.96/28
128.119.40.112/28

4.17
214.97.254.0/31     Subnet D    // 2 IPs
214.97.254.2/31     Subnet E    // 2 IPs
214.97.254.4/31     Subnet F    // 2 IPs
214.97.254.0/25     Subnet B    // 128 - 2 * 3 = 122 IPs
214.97.254.128/25   Subnet C    // 128 IPs
214.97.255.0/24     Subnet A    // 256 IPs

4.18
Wellesley College (https://www.wellesley.edu/)
    107.20.0.0/14 (AWS)
    Ashburn,
    Virginia,
    United States,
    North America
Williams College (https://www.williams.edu/)
    104.16.0.0/12 (Cloudflare cloud)
    United States,
    North America	
Vassar College (https://www.vassar.edu/)
    143.229.0.0/16 (the only one not hosted on cloud services)
    Poughkeepsie,
    New York,
    United States,
    North America	
Both services seems cannot provide precise location of an IP address, only for a range (CIDR) of IPs

4.19
4 fragments are generated
assuming no option fields
ID      Length      Offset      Flag
422     680         0           0
422     680         85          0
422     680         170         0
422     360         255         1

4.20
if the file is transferred by UDP and link is reliable:
    ceil(5e6 / (1500 - IP_HEADER - UDP_HEADER)) = 3397
if the file is transferred by TCP:
    no idea, ACK packets may be nondeterministic

4.21
a.  192.168.0.0     router
    192.168.0.1-3   3 hosts
b.  24.34.112.235, <PORT_MAPPED_A1>    192.168.1, <PORT_A1>
    24.34.112.235, <PORT_MAPPED_A2>    192.168.1, <PORT_A2>
    24.34.112.235, <PORT_MAPPED_B1>    192.168.2, <PORT_B1>
    24.34.112.235, <PORT_MAPPED_B2>    192.168.2, <PORT_B2>
    24.34.112.235, <PORT_MAPPED_C1>    192.168.3, <PORT_C1>
    24.34.112.235, <PORT_MAPPED_C2>    192.168.3, <PORT_C2>
    PORT_MAPPED_* must be distinct but PORT_A1 may be equal to PORT_B1

4.22
a.  assume packet is frequently sent that all hosts send at least one packet 
    meantime packets are sparse enough that there's duplicated IDs 
    record each ID, group into consecutive ranges, count the number of ranges
b.  it's now indistinguishable between a single host generating a huge number of packets
    and many hosts generating a few packets each

4.23
it may be possible with reverse connection and a server in the middle
both hosts connect to the server's open ports, and the server tunnels packets between them

4.24
./network/network/problems
yzwxvu
yzwxu
yzwvxu
yzwvu
yzwu
yxwvu
yxwu
yxvwu
yxvu
yxu
ywxvu
ywxu
ywvxu
ywvu
ywu

4.25
./network/network/problems
x ~> z
    xyz
    xywz
    xwz
    xwyz
    xvwz
    xvwyz
    xvuwz
    xvuwyz
    xuwz
    xuwyz
    xuvwz
    xuvwyz
z ~> u
    zyxwvu
    zyxwu
    zyxvwu
    zyxvu
    zyxu
    zywxvu
    zywxu
    zywvxu
    zywvu
    zywu
    zwyxvu
    zwyxu
    zwxvu
    zwxu
    zwvxu
    zwvu
    zwu
z ~> w
    zyxw
    zyxvw
    zyxvuw
    zyxuw
    zyxuvw
    zyw
    zw

4.26
./network/network/problems
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
           ∞           ∞         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x

4.27
./network/network/problems
Shortest paths from t
   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(x),p(x)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
         2,t         4,t           ∞           ∞         7,t           ∞
         2,t         4,t         5,u           ∞         7,t           ∞
         2,t         4,t         5,u         7,v         7,t           ∞
         2,t         4,t         5,u         7,v         7,t           ∞
         2,t         4,t         5,u         7,v         7,t        15,x
         2,t         4,t         5,u         7,v         7,t        15,x
         2,t         4,t         5,u         7,v         7,t        15,x
Shortest paths from u
   D(t),p(t)   D(v),p(v)   D(w),p(w)   D(x),p(x)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
         2,u         3,u         3,u           ∞           ∞           ∞
         2,u         3,u         3,u           ∞         9,t           ∞
         2,u         3,u         3,u         6,v         9,t           ∞
         2,u         3,u         3,u         6,v         9,t           ∞
         2,u         3,u         3,u         6,v         9,t        14,x
         2,u         3,u         3,u         6,v         9,t        14,x
         2,u         3,u         3,u         6,v         9,t        14,x
Shortest paths from v
   D(t),p(t)   D(u),p(u)   D(w),p(w)   D(x),p(x)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
         4,v         3,v         4,v         3,v         8,v           ∞
         4,v         3,v         4,v         3,v         8,v           ∞
         4,v         3,v         4,v         3,v         8,v        11,x
         4,v         3,v         4,v         3,v         8,v        11,x
         4,v         3,v         4,v         3,v         8,v        11,x
         4,v         3,v         4,v         3,v         8,v        11,x
         4,v         3,v         4,v         3,v         8,v        11,x
Shortest paths from w
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(x),p(x)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
           ∞         3,w         4,w         6,w           ∞           ∞
         5,u         3,w         4,w         6,w           ∞           ∞
         5,u         3,w         4,w         6,w        12,v           ∞
         5,u         3,w         4,w         6,w        12,v           ∞
         5,u         3,w         4,w         6,w        12,v        14,x
         5,u         3,w         4,w         6,w        12,v        14,x
         5,u         3,w         4,w         6,w        12,v        14,x
Shortest paths from x
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(y),p(y)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
           ∞           ∞         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
         7,v         6,v         3,x         6,x         6,x         8,x
Shortest paths from y
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(x),p(x)   D(z),p(z)
           ∞           ∞           ∞           ∞           ∞           ∞
         7,y           ∞         8,y           ∞         6,y        12,y
         7,y           ∞         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
         7,y         9,t         8,y        12,x         6,y        12,y
Shortest paths from z
   D(t),p(t)   D(u),p(u)   D(v),p(v)   D(w),p(w)   D(x),p(x)   D(y),p(y)
           ∞           ∞           ∞           ∞           ∞           ∞
           ∞           ∞           ∞           ∞         8,z        12,z
           ∞           ∞        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z
        15,v        14,v        11,x        14,x         8,z        12,z

4.28
// assume sync update
./network/network/problems
init:
       u   v   x   y   z
   u   0   1   ∞   2   ∞
   v   1   0   3   ∞   6
   x   ∞   3   0   3   2
   y   2   ∞   3   0   ∞
   z   ∞   6   2   ∞   0
first iter:
       u   v   x   y   z
   u   0   1   4   2   7
   v   1   0   3   3   5
   x   4   3   0   3   2
   y   2   3   3   0   5
   z   7   5   2   5   0
second iter:
       u   v   x   y   z
   u   0   1   4   2   6
   v   1   0   3   3   5
   x   4   3   0   3   2
   y   2   3   3   0   5
   z   6   5   2   5   0

4.29
// thanks solutions manual
invariant: 
    after k iteration, DV of a node contains shortest path cost to other nodes consist of at most k + 1 links
initialization:
    k = 0, all nodes know the link cost to (path cost of length 1) their neighbors
    as link cost is non-negative, that's the shortest path to these neighbors
maintenance:
    at the start of iteration k, all nodes know the shortest path cost to nodes with length <= k
    for a specific node A, a path of length <= k + 1 must first traverse one of one of A's neighbor then 
    take the shortest path of length <= k from its neighbor to the destination
    in iteration k, all of A's neighbors pass message of shortest path of length <= k to A
    A hence calculates shortest paths with length <= k + 1 with Bellman-Ford equation
the DVs will converge after at most d - 1 iterations, where d is the longest simple path in the graph

4.30
a.  w   y   u
    2   4   7
b.  c(x, w): 2 -> 3
c.  c(x, y): 5 -> 6

4.31
./network/network/problems
init:
       x   y   z
   x   0   3   4
   y   3   0   6
   z   4   6   0
no update

4.32
unlike increasing link cost, decreasing link cost will not cause routing loop
let the link be (u, v), the DV of u and v will be updated immediately to the correct result since
any simple path from u that traverses (u, v) must visit v first, otherwise the path is not simple
the remaining path from v cannot traverse (u, v) again in any direction
the old DV of v (which u is already informed about) will suffice
the information of the updated c(u, v) will then be propagated to other nodes
in turn of their number of hops from u or v
connecting two nodes is equivalent to decreasing the link cost from infinity to a finite number

4.33
can be derived from proof in 4.29
non-increasing: minimum path cost of length <= k + 1 cannot exceed minimum path cost of length <= k by subset relation
stable: no simple path can have length greater than d, after d iterations the costs will no longer change

4.34
a.  w to z: c(w, x) = 5, w to y: c(w, x) = None
    y to z: c(y, x) = 4, y to w: c(y, x) = 4
    z to w: c(z, x) = None, z to y: c(z, x) = 6
b.  count-to-infinity will still happen between y and z
    z is unaware of the next hop of w being y so will inform y the already out-of-date information of path costs 
    in a 3-step loop:
        y update c(y, x) = c(z, x) + c(y, z) = 9, to w: c(y, x) = 9, to z: c(y, x) = None
        w update c(w, x) = c(y, x) + c(w, y) = 10, to y: c(w, x) = None, to z: c(w, x) = 10
        z update c(z, x) = c(w, x) + c(z, w) = 11, to w: c(z, x) = None, to y: c(z, x) = 11
    at iteration 33, c(z, y) + c(y, x) = 51, z will route via (z, x) instead, DV will stabilize next iteration
c.  set c(y, z) >= 60 - 6 = 54
    y will choose to route via (y, x) in the first iteration, no routing loop will be formed

4.35
by AS-PATH attributes
if ASN of a router is included in AS-PATH of an advertisement it will drop it

4.36
no, it's affected by the import policy of the AS

4.37
a.  eBGP from 4c
b.  iBGP from 3b
c.  eBGP from 3a
d.  iBGP

4.38
// assume no local preference
a.  I1, AS-PATH is the same, NEXT-HOP distance to 3a -> 1c interface in RIP is measured by number of hops, 
    and I1 points to the path of minimum length
b.  I2, AS-PATHs have the same length, NEXT-HOP distance via I2 to 2a is shorter than via I1 to 3a
c.  I1, AS-PATH via AS4 -> AS3 is shorter than via AS4 -> AS5 -> AS2

4.39
in B:   
    the administrator of B may adjust the LOCAL_PREF attribute of routers in B to send packets with destination D
    via its west coast exit
in C:
    the administrator of C may adjust the MULTI_EXIT_DISC attribute of BGP messages from D, thus the routers in B may
    prefer sending through the east coast entry of C all other factors being equal

4.40
// assume providers do not advertise unnecessary paths
view of W:
    no link between B and C, otherwise B or C provides free rides to another
view of Y:
    no link between B and C, B will not shoulder traffic from C to X, the same below
    no link between B and X
    no link between A and B

4.41
bittorrent, X receives segments of a data from W via B, then send it through another TCP link via C to Y
effectively routes the segment on the path W -> A -> B -> X -> C -> Y

4.42
A to B: A-W and A-V 
A to C: A-V
C receives: B-A-W, B-A-V, A-V

4.43
Y and Z are in a peering agreement, Z will advertise all its paths to Y
Y and X are in a peering agreement, Y will advertise all its paths, including paths via Z, to X
there's nothing Z can do to prevent X routes its traffic to Z

4.44
./network/network/problems
graph {
    0 [label="t"]
    1 [label="u"]
    2 [label="v"]
    3 [label="w"]
    4 [label="x"]
    5 [label="y"]
    6 [label="z"]
    0 -- 1 [label="2"]
    2 -- 4 [label="3"]
    1 -- 2 [label="3"]
    1 -- 3 [label="3"]
    4 -- 5 [label="6"]
    4 -- 6 [label="8"]
}
by documentation (https://docs.rs/petgraph/0.4.13/petgraph/algo/fn.min_spanning_tree.html) 
it's calculated by Kruskal's algorithm

4.45
unicast:
    each packet traverses 5 links, 32 * 5 = 160 cost
broadcast:
    each link is traversed once
    2 + 4 + 8 + 16 + 32 = 64 - 2 = 62 cost
a long simple path of routers with all receivers attached to the last router 
if there are n receivers, each packet will be sent n times through the path with unicast
but only once with broadcast

4.46
B: // B will always receive package from A
C: A -> C
D: A -> C -> E -> D

4.47
path not in shortest-path tree:
    (E, F), (E, D), (E, C), (C, A), {(D, B) or (C, B)}, (D, G)

4.48
./network/network/problems
shortest path tree:
    (z, x), (z, y), (x, v), (x, w), (v, t), (v, u)

4.49
./network/network/problems
p(A) = Some('C')
p(B) = Some('C')
p(C) = None
p(D) = Some('E')
p(E) = Some('C')
p(F) = Some('C')
p(G) = Some('D')
it's a shortest path tree, in general may not be the minimum spanning tree

4.50
./network/network/problems
p(t) = Some('v')
p(u) = Some('v')
p(v) = None
p(w) = Some('v')
p(x) = Some('v')
p(y) = Some('v')
p(z) = Some('x')

4.51
a 4-node graph:
    c(A, B) = 2, c(A, C) = 2, c(A, D) = 2, c(B, C) = 1, c(C, D) = 1
{(A, B), (A, C), (A, D)} is a shortest path tree with total link cost 6
a minimum spanning tree {(A, C), (B, C), (C, D)} has total link cost 4

4.52
each time step a node receiving a packet will duplicate and send the packet to two neighbors
in time step t, 2^(t - 1) packets are transmitted

4.53
with transport or application layer information embedded in the data section of network layer packets

4.54
the description of multicast in this chapter is too vague to design anything on it
if the multicast protocol permits any participant to be a sender
each host may broadcast it's identity to the multicast group 
otherwise the only sender may broadcast its IP in the multicast group and receivers can send back their identity 
through out-of-band unicast channel

4.55
according to RFC5771, IPv4 multicast addresses ranges from 224.0.0.0 to 239.255.255.255, 265302000 in total
2 group collision probability is 1/265302000
1000 group collision probability is, by approximation,
    1 - e^(-k(k - 1) / 2N)
    = 0.00188098874

Assignment 5