// rereading, lost all the notes / codes of the previous reading
Chapter 2
2.1-1
[ 31, 41, 59, 59, 41, 58 ]
[ 31, 41, 41, 59, 41, 58 ]
[ 31, 31, 41, 59, 41, 58 ]
[ 26, 31, 41, 59, 59, 58 ]
[ 26, 31, 41, 41, 59, 59 ]
[ 26, 31, 41, 41, 58, 59 ]

2.1-2
change line 5 to
    while i > 0 and A[i] < key

2.1-3
./CLRS/start/index.ts#linearSearch
loop invariant: 
    none of the first i items in the array equals to v
initialization:
    i == 0, loop invariant holds trivially
maintainance:
    every iteration, A[i] == v is checked
    the loop continues only when A[i] == v is false
termination:
    if the loop terminated early, then A[i] == v and the first i elements in the array are not equal to v
    therefore arr[i] is the first element equals to v
    if the loop terminated on loop condition, i = arr.length, the first i elements are the whole array
    none of the items in the array equals to v, so function returns NIL
    
2.1-4
Input: Two n-element sequence of 0 and 1s, representing two numbers a and b in binary form
Output: a (n+1)-element sequence of 0 and 1s, representing a number c == a + b in binary form
assumes little-endian
./CLRS/start/index.ts#addBinary

2.2-1
Θ(n^3)

2.2-2
invariant: 
    each of the the first i elements of the array are the ith smallest elements
the last element is greater or equal to all the previous items, thereby must be the greatest element
best-case and worst-case both Θ(n^2)

2.2-3
Σip(i) = (Σi) / n = (1 + n) * n / 2n = (1 + n) / 2 on average, Θ(n)
n on worst case, Θ(n)
assuming comparsion of integers takes constant time

2.2-4
hard-code the solution of a specific input in the program 
if input equals to the specific input, returns that solution immediately
base-case runtime reduced to time required to check the input

2.3-1
[ 3, 41, 52, 26, 38, 57, 9, 49 ]
[ 3, 41, 26, 52, 38, 57, 9, 49 ]
[ 3, 26, 41, 52, 38, 57, 9, 49 ]
[ 3, 26, 41, 52, 38, 57, 9, 49 ]
[ 3, 26, 41, 52, 38, 57, 9, 49 ]
[ 3, 26, 41, 52, 9, 38, 49, 57 ]
[ 3, 9, 26, 38, 41, 49, 52, 57 ]
[ 3, 9, 26, 38, 41, 49, 52, 57 ]

2.3-2
./CLRS/start/mergesort.ts#mergeNoSentinel

2.3-3
when n = 2,
    T(n) = 2 = 2lg2
assume for n = 2^k, T(n) = nlgn = 2^klg(2^k) = k * 2^k
    T(2n)   = T(2^(k+1))
            = 2T(2^k) + 2^(k+1)
            = 2 * 2^k * k + 2^(k+1)
            = k * 2^(k+1) + 2^(k+1)
            = (k+1) * 2^(k+1)
            = (2n)lg(2n)
therefore for n = 2^k, k > 1,
    T(n) = nlgn

2.3-4
T(n)    = Θ(1)          when n = 1
        = T(n-1) + Θ(n) when n > 1

2.3-5
./CLRS/start/index.ts#binarySearch
T(n)    = Θ(1)          when n = 1
        = Θ(n/2) + Θ(1) when n > 1
by master theorem T(n) = Θ(lgn)

2.3-6
cannot improve
each iteration in insertion sort has to shift Θ(n) elements one place to the right
even if the right position to insert the element can be find in time Θ(lgn), shifting still takes Θ(n)
overall time still Θ(n^2)

2.3-7
first sort the array by mergesort
then for every element g in the sorted array, binary search x - g
(if the index of x - g equals the index of g, x = 2g, and such a pair doesn't exist)
./CLRS/index.ts#pairSum
mergesort: Θ(nlgn)
binary search: n * Θ(lgn) = Θ(nlgn)
overall: Θ(nlgn) + Θ(nlgn) = Θ(nlgn)

2-1
a.  insertion sort on an array of length k takes time Θ(k^2)
    there are n/k such arrays, overall runtime Θ(k^2) * n / k = Θ(nk)
b.  the same with figure 2.5
    the height of the tree is reduced to lg(n/k)
    base level performs n/2k merges with arrays of length k, n/2k * Θ(k) = Θ(n) in total
    overall runtime Θ(nlg(n/k))
c.  T(n) = Θ(nk + nlg(n/k))
    if k = ω(lgn), Θ(nk) = ω(nlgn), the runtime of the modified algorithm then is asymptotically greater
d.  k = O(lgn), the precise value of k depends on cache size, hidden constant factors in algorithms, etc.

2-2
a.  it terminates in finite time on all inputs
b.  invariant:
        at the end of each iteration, the smallest element in slice A[j-1 .. A.length] is in A[j-1]
    initialization:
        j = A.length, the first iteration compares A[A.length] to A[A.length - 1], put the smaller in A[A.length - 1]
        which is the smallest in A[A.length - 1 .. A.length]
    maintainance:
        the smallest number is compared with A[j-1], the smaller of the two is swapped to A[j-1]
        inductively A[j-1] now holds the smallest number in A[j-1 .. A.length]
    termination:
        j = i+1, A[i] holds the smallest number in A[i .. A.length]
c.  invariant:
        at the end of each iteration, A[1..i] consists of ith smallest elements and is sorted in non-decreasing order
    initialization:
        at the end of the first iteration, the smallest element in A[1 .. A.length] is placed in A[1]
        it is the smallest element, A[1 .. 1] is trivially sorted
    maintainance:
        the inner loop finds the smallest number in A[i .. A.length] and puts it in A[i]
        A[1 .. i-1] consists of the i-1 smallest elements in A, therefore A[i] is the ith smallest number
        by definition A[i] >= A[i-1], A[1..i] is sorted 
    termination:
        A[1..A.length - 1] consists of A.length - 1 smallest numbers and is sorted
        thereby A[A.length] must be the greatest element in A
        A is sorted in non-decreasing order
d.  inner loop Θ(n)
    outer loop run n - 1 times
    overall runtime (n-1) * Θ(n) = Θ(n^2)
    both the best and worst case of bubble sort performs Θ(n^2) comparsions
    while insertion sort in best case has runtime Θ(n)

2-3
a.  the algorithm performs n additions and n multiplications
    assuming both are contant time, T(n) = Θ(n)
b.  ./CLRS/start/index.ts#naivePolynomial
    k = Θ(n), Math.pow(x, k) = x^k if implemented naively takes time Θ(k), if not takes time Θ(lgk)
    overall runtime Θ(n^2) or Θ(nlgn)
c.  initialization:
        initially y = 0, the sum of an empty sequence
    maintainance:
        y = Σ(k ∈ {0..n-(i+1)})a(k+i+1)x^k = a(i+1) + a(i+2)x + .. + an * x^(n-(i+1)) at the start
        y = ai + xy = ai + a(i+1)x + .. + an * x^(n-i) = Σ(k ∈ {0..n-i})a(k+i)x^k
    termination:
        the end of the last iteration ends with i = 0, the next iteration (not executed) starts with i = -1
        y = Σ(k ∈ {0..n})ak * x^k
d.  as above

2-4
a.  (0, 4), (1, 4), (2, 3), (2, 4), (3, 4)  // zero-based index
b.  [n, n-1 .. 1], every pair is an inversion
    there are C(n, 2) = n(n-1)/2 pairs
c.  every assignment in the insertion sort reduces the total number of inversions by 1
    the sorted array has no inversions
    therefore the number of inversions in an array is a lower bound of the runtime of insertion sort
d.  assume an array A[p..r] and some q that p < q < r, then the total number of inversions in A[p..r] is the sum of
    1.  the number of inersions in A[p..q]
    2.  the number of inversions in A[q+1..r]
    3.  the number of inversions as pairs (i, j) such that
            i in {p..q}, j in {q+1..r}
    for every index i in {p..q}, the number of type 3 inversions is exactly the number of indexes j in {q+1..r} that
        A[i] > A[j]
    which can be calculated in a slightly modified merge function
    ./CLRS/start/mergesort.ts#inversionCount

Chapter 3
3.1-1
max(f(n), g(n)) <= f(n) + g(n) for all n
assume f(n) >= g(n), max(f(n), g(n)) = f(n) = (f(n) + f(n)) / 2 >= (f(n) + g(n)) / 2
symmetrically when g(n) >= f(n), max(f(n), g(n)) >= (f(n) + g(n)) / 2
therefore let c1 = 1, c2 = 1/2,
    1/2(f(n) + g(n)) <= max(f(n), g(n)) <= f(n) + g(n)
    max(f(n), g(n)) = Θ(f(n) + g(n))

3.1-2
(n + a)^b = Σ(k ∈ {0..b})(C(b, k) * n^k * a^(b-k))
the term with highest order is n^b, therefore (n + a)^b = Θ(n^b)

3.1-3
O(n^2) is an upper bound, the set O(n^2) contains all functions from constant to quadratic
denote the running time of algorithm A by T(n)
the statement can then be translated to "T(n) is at least any constant (including 0) for large enough n"
which is meaningless for a asymptotically non-negative function

3.1-4
2^(n+1) = 2 * 2^n = Θ(2^n)
2^2n / 2^n = 2^n, no constant can be asymptotically larger than 2^n

3.1-5
=>: f(n) = Θ(g(n)), c1g(n) <= f(n) <= c2g(n) for n >= n0, then trivally f(n) = O(g(n)) and f(n) = Ω(g(n))
<=: f(n) = O(g(n)) implies f(n) <= c1g(n) for n >= n1
    f(n) = Ω(g(n)) implies f(n) >= c2g(n) for n >= n2
    take n3 = max(n1, n2), c1g(n) <= f(n) <= c2g(n) for n >= n3, f(n) = Θ(g(n))
therefore f(n) = Θ(n) <=> f(n) = O(g(n)) and f(n) = Ω(g(n))

3.1-6
f(n) = Θ(g(n)) => f(n) = O(g(n)), for all inputs g(n) is an upper bound of f(n)
so even in the worst case f(n) = O(g(n))
similarly in the best case f(n) = Ω(g(n))

3.1-7
assume f(n) = o(g(n)) and f(n) = ω(g(n)), then
lim(f(n) / g(n)) = ∞ and lim(f(n) / g(n)) = 0, contradiction
so no such f(n) exist, o(g(n)) ∩ ω(g(n)) = ∅

3.1-8
Ω(g(n, m)) = {f(n, m):  there exist positive constants c, n0, m0 such that
                        cg(n, m) <= f(n, m) for all n >= n0 or m >= m0 }
Θ(g(n, m)) = O(g(n, m)) ∩ Ω(g(n, m))

3.2-1
for n1 >= n2, f(n1) >= f(n2), g(n1) >= g(n2), f(n1) + g(n1) >= f(n2) + g(n2)
thereby f(n) + g(n) is monotonically increasing
for n1 >= n2, g(n1) >= g(n2), f(g(n1)) >= f(g(n2))
thereby f(g(n)) is monotonically increasing

3.2-2
a^log(b, c) = (b^log(b, a))^log(b, c)
            = (b^log(b, c))^log(b, a)
            = c^log(b, a)

3.2-3
n! = (2πn)^(1/2) * (n/e)^n * (1 + Θ(1/n))
lg(n!)  = lg((2πn)^(1/2)) + lg((n/e)^n) + lg(1 + Θ(1/n))
        = 1/2lg(2πn) + nlg(n/e) + lg(1 + Θ(1/n))
        = Θ(lgn) + Θ(nlgn) + O(lgn)
        = Θ(nlgn)
n! = Πn, n! / 2^n = Π(k/2), lim(Π(k/2)) -> ∞, n! = ω(2^n)
n! / n^n = Π(k/n) <= 1/n, lim(1/n) -> 0, n! = o(n^n)

3.2-4
lg((lgn)!) = Θ(lgn * lglgn)
for large enough n,
c1(lgn * lglgn) <= lg((lgn)!) <= c2(lgn * lglgn)
e^c1(lgn * lglgn) <= (lgn)!
n^(c1 * lglgn) <= (lgn)!
as c1 * lglgn is not a constant, (lgn)! cannot be polynomially bounded
thanks https://ita.skanev.com/03/02/04.html
lg((lglgn)!)    = Θ(lglgn * lglglgn)
                = o(lglgn * lglgn)
                = o((lglgn)^2)
                = o(lgn)
asymptotically,
lg((lglgn)!) < lgn
(lglgn)! < e^lgn = n
therefore (lglgn)! is polynomially bounded

3.2-5
by definition, 
lg*lgn = lg*n - 1 = Θ(lg*n)
lg(lg*n) = Θ(lg(lg*n))
therefore lg*lgn is asymptotically larger

3.2-6
((1 + 5^(1/2)) / 2)^2 = (1 + 2 * 5^(1/2) + 5) / 4 = (3 + 5^(1/2)) / 2 = (1 + 5^(1/2)) / 2 + 1
((1 - 5^(1/2)) / 2)^2 = (1 - 2 * 5^(1/2) + 5) / 4 = (3 - 5^(1/2)) / 2 = (1 - 5^(1/2)) / 2 + 1

3.2-7
let g and g' denote golden ratio and its conjugate, r5 denotes square root of 5
g - g' = r5
g^2 = g + 1, g'^2 = g' + 1
F1 = 1 = (g - g') / r5
F2 = 1 = (g^2 - g'^2) / r5
assume Fi = (g^i - g'^i) / r5, Fi+1 = (g^(i+1) - g'^(i+1)) / r5
    (g^(i+2) - g'^(i+2)) / r5   = (g^i * g^2 - g'^i * g'^2) / r5
                                = (g^i * (g + 1) - g'^i * (g' + 1)) / r5
                                = (g^i - g'^i) / r5 + (g^(i+1) - g'^(i+1)) / r5
                                = Fi + Fi+1
                                = Fi+2

3.2-8
by symmetry law
    n = Θ(klnk)
as ln(n) is monotonically increasing
    c1klnk <= n <= c2klnk
    ln(c1klnk) <= ln(n) <= ln(c2klnk)
    lnk + lnlnk + c1' <= ln(n) <= lnk + lnlnk + c2'
    ln(n) = Θ(lnk)
    lnk = Θ(ln(n))
    k = Θ(n) / lnk = Θ(n) / Θ(ln(n)) = Θ(n / ln(n))

3-1
a.  k >= d, p(n) / n^k = Σ(ai * n^(i - k))
    each i - k <= 0, therefore lim(p(n) / n^k) <= ad
    take c = ad + ε, where ε is an arbitrary positive number
    there must exist n0 such that for n >= n0, lim(p(n) / cn^k) < 1, p(n) = O(n^k)
b.  k <= d, p(n) / n^k = Σ(ai * n^(i - k))
    lim(p(n) / n^k) >= ad
    take c = ad/2, with large enough n, cn^k <= p(n), p(n) = Ω(n^k)
c.  k == d <=> k <= d && k >= d
    combine a and b, p(n) = O(n^k) && p(n) = Ω(n^k) => p(n) = Θ(n^k)
d.  if k > d, lim(p(n) / n^k) = 0, p(n) = o(n^k)
e.  if k < d, lim(p(n) / n^k) = ∞, p(n) = ω(n^k)

3-2
a.  y   y   n   n   n
b.  y   y   n   n   n
c.  n   n   n   n   n
    n^sin(n) swings between 1/n and n
d.  n   n   y   y   n
    lim(2^n / 2^(n/2)) = lim(2^(n/2)) = ∞
e.  y   n   y   n   y 
    by 3.16, n^lgc = c^lgn
f.  y   n   y   n   y
    lg(n!) = Θ(nlgn)
    lg(n^n) = nlgn = Θ(nlgn)

3-3
a.  1
    lg(lg*n)
    lg*(lgn) = lg*n - 1
    lg*n
    lnln(n)
    // polylogarithmics:
    2^lg*n // unsure
    (lgn)^(1/2)
    ln(n)
    (lgn)! = Θ(lgn * lglgn)
    (lgn)^2
    2^((2lgn)^(1/2)) // unsure
    // polynomials:
    n^(1/lgn)
    (2^(1/2))^lgn = n^(1/2)
    n 
    2^lgn = n
    nlgn
    lg(n!) = Θ(nlgn)
    n^2
    4^lgn = n^2
    n^3
    // exponentials:
    (lgn)^lgn = n^lglgn
    n^lglgn
    (3/2)^n
    2^n
    n * 2^n
    e^n
    // super-exponentials:
    n!
    (n+1)!
    2^(2^n)
    2^(2^(n+1))
b.  the fastest growing function here is 2^(2^(n+1))
    2^(2^(n+2)) * |sin(n)|

3-4
a.  false, n = O(n^2), n^2 != O(n)
b.  false, let f(n) = n^2, g(n) = n, min(f(n), g(n)) = n, f(n) + g(n) = Θ(n^2) != Θ(n)
c.  f(n) = O(g(n))
    f(n) <= c1g(n)
    lg(f(n)) <= lg(c1(g(n))) = lg(g(n)) + c2 = O(lg(g(n)))
d.  false
    f(n) = O(g(n))
    f(n) <= c1g(n)
    2^f(n) <= 2^c1g(n) = (2^c1)^g(n)
    let f(n) = 2n, g(n) = n
    2^f(n) = 2^2n, 2^g(n) = 2^n, 2^2n != O(2^n)
e.  false, let f(n) = 1/n, f^2(n) = (1/n)^2 = 1/n^2
    lim(f(n) / f^2(n)) = ∞, f(n) = ω(f^2(n))
f.  f(n) = O(g(n))
    f(n) <= c1g(n)
    (1/c1)f(n) <= g(n)
    g(n) = Ω(f(n))
g.  false, let f(n) = 2^n, f(n/2) = 2^(n/2), lim(f(n) / f(n/2)) = ∞, f(n) = ω(f(n/2))
h.  for any g(n) ∈ o(f(n)), lim(g(n) / f(n)) = 0
    for large enough n, lim((f(n) + g(n)) / f(n)) = 1
    let c1 = 1, c2 = 1 + ε, there must exist n0 such that for n >= n0,
        c1f(n) <= f(n) + g(n) <= c2f(n)
    and f(n) + g(n) = Θ(f(n))

3-5
a.  if f(n) != O(g(n)), there's no n0 and c that cg(n) >= f(n) for all n >= n0
    let c be an arbitrary constant, if only for finitely many n, f(n) >= cg(n)
    then take n0 be the greatest of such n, then for n >= n0+1, f(n) < cg(n), f(n) = O(g(n))
    thereby there must be infinitely many n such that f(n) >= cg(n) >= 0, f(n) = ∞Ω(g(n))
    so f(n) != O(g(n)) => f(n) = ∞Ω(g(n)) and f(n) != ∞Ω(g(n)) => f(n) = O(g(n))
    if f(n) = n and g(n) = n * |sin(n)|, then neither f(n) = O(g(n)) or f(n) = Ω(g(n))
b.  it is the complement of set O(g(n)), may work smoother in certain proofs
    it's harder to reason and less intuitive, f(n) = ∞Ω(g(n)) no longer gives an lower bound of f(n)
c.  =>: f(n) = Θ(g(n))  => c1g(n) <= f(n) <= c2g(n)
                        => f(n) = Ω(g(n)) and f(n) <= c2g(n)
        let f(n) = -n, g(n) = -n, take c1 = c2 = 1, f(n) = Θ(g(n))
        but |f(n)| = n > cg(n) for all positive constant c, f(n) != O'(g(n))
    <=: |f(n)| <= cg(n) => f(n) <= cg(n), so f(n) = O'(g(n)) implies f(n) = O(g(n))
        therefore f(n) = O'(g(n)) && f(n) = Ω(g(n)) => f(n) = Θ(g(n))
d.  ~Ωg(n) = {f(n): there exist positive constants c, k and n0 that
                    0 <= cg(n)lg^k(n) <= f(n) for all n >= n0 }
    ~Θg(n) = {f(n): there exist positive constants c1, c2, k1, k2 and n0 that
                    c1g(n)lg^k1(n) <= f(n) <= c2g(n)lg^k2(n) for all n >= n0 }
    =>: f(n) = ~Θ(g(n)) => c1g(n)lg^k1(n) <= f(n) <= c2g(n)lg^k2(n) for all n >= n0
        instantly f(n) = ~O(g(n)) and f(n) = ~Ω(g(n))
    <=: similar, take n0 be the maximum of the two

3-6
a.  n - c
b.  lg*(n)
c.  lg(n)
d.  lg(n) - 1
e.  lglg(n)
f.  ∞
g.  lglg(n)
h.  iter 0: n
    iter 1: n / lgn = (iter 0) / lgn
    iter 2: (n / lgn) / lg(n / lgn) = (iter 1) / (lgn - lglgn)
    iter 3: ((n / lgn) / (lgn - lglgn)) / lg((n / lgn) / (lgn - lglgn))
            = (iter 2) / ((lgn - lglgn) - lg(lgn - lglgn))
    the divisor is never greater than lgn
    therefore lower bound is Ω(log(lgn, n)) = Ω(lgn / lglgn)
    upper bound unknown

Chapter 4
4.1-1
still the maximum subarray, the left and right sum is initialized to -Infinity

4.1-2
./CLRS/start/max-subarray.ts#findMaximumSubarrayBrute

4.1-3
crossover happens between 1024 <= n0 <= 2048
mixing recursive and brute-force algorithms then the crossover is no longer noticeable

4.1-4
return tuple of (Option<Idx>, Option<Idx>, Sum)
initialize left-sum and right-sum to 0, left-max and right-max to None
if all array elements between low and high are non-positive, left-max and right-max will not be reassigned
return value will be (None, None, 0)

4.1-5
if tail_max is the maximum subarray of the form A[i .. j] in an array A[0 .. j]
then all subarrays of the form A[k .. i-1] where k <= i-1 sum to non-positive value
all subarrays of the form A[i .. k] where k < j sum to non-negative value
considering A[k .. j+1],
    if k < i
        the slice can be divided to A[k .. i-1] and A[i .. j+1], where A[k .. i-1] sums to non-positive
        sum of this slice is not greater than A[i .. j+1]
    if i < k <= j
        the sum of the slice can be expressed as sum(A[i .. j+1]) - sum(A[i .. k-1])
        where k - 1 < j and sum(A[i .. k-1]) >= 0
        sum of this slice is not greater than A[i .. j+1]
    if k = j+1
        the sum equals to A[j+1], and A[j+1] > sum(A[i .. j+1]) only if sum(A[i .. j]) < 0
therefore the new tail_max is either A[i .. j+1] or A[j+1], depends on whether sum(A[i .. j]) < 0
./CLRS/start/max-subarray.ts#findMaximumSubarrayLinear

4.2-1
((1, 3), (7, 5)) * ((6, 8), (4, 2))
S1 = B12 - B22 = 6;
S2 = A11 + A12 = 4;
S3 = A21 + A22 = 12;
S4 = B21 - B11 = -2;
S5 = A11 + A22 = 6;
S6 = B11 + B22 = 8;
S7 = A12 - A22 = -2;
S8 = B21 + B22 = 6;
S9 = A11 - A21 = -6;
S10 = B11 + B12 = 14;
P1 = A11 . S1 = 6;
P2 = S2 . B22 = 8;
P3 = S3 . B11 = 72;
P4 = A22 . S4 = -10;
P5 = S5 . S6 = 48;
P6 = S7 . S8 = -12;
P7 = S9 . S10 = -84;
C11 = P5 + P4 - P2 + P6 = 18;
C12 = P1 + P2 = 14;
C21 = P3 + P4 = 62;
C22 = P5 + P1 - P3 - P7 = 66;

4.2-2
./CLRS/start/matrix-mul.ts#strassen

4.2-3
-

4.2-4
-

4.2-5
-

4.2-6
let A = transpose([A1, A2 .. Ak]), B = [B1, B2 .. Bk], each of Ai, Bj is a n x n matrix
then A . B will be kn x kn
A . B = (Ai . Bj), k^2 multiplications of n x n matrixes in total
assume matrix multiplication is O(g(n)), then T(n) = O(k^2 * g(n))
using strassen's algorithm g(n) = n^ln7, T(n) = O(k^2 * n^ln7)

4.2-7
let p1 = (a+b)(c+d) = ac + ad + bc + bd
    p2 = ac
    p3 = bd
then 
    real component = p2 - p3
    complex component = p1 - p2 - p3

4.3-1
assume T(n-1) <= (n-1)^2
T(n)    <= (n-1)^2 + n
        = n^2 - 2n + 1 + n 
        <= n^2
implicitly c = 1, T(n) = O(n^2)

4.3-2
assume T([n/2]) <= lg(n/2)
T(n)    <= lg(n/2) + 1
        = lgn - 1 + 1
        <= lgn
implicitly c = 1, T(n) = O(lgn)

4.3-3
assume T([n/2]) >= c(n/2)lg(n/2)
T(n)    >= 2 * c(n/2)lg(n/2) + n
        = cnlg(n/2) + n
        = cnlgn - cn + n
take 0 < c < 1, then T(n) >= cnlgn, T(n) = Ω(nlgn)

4.3-4
assume T([n/2]) <= c(n/2)lg(n/2) + 1
T(n)    <= 2 * c(n/2)lg(n/2) + 1 + n
        = cnlgn - cn + n + 1
        <= cnlgn when c > 2
T(1)    <= clg1 + 1 = 1

4.3-5
assume T([n/2]) <= c(n/2)lg(n/2) + 1
for any c1n = Θ(n)
T(n)    <= 2 * c(n/2)lg(n/2) + 1 + c1n
        = cnlgn - cn + 1 + c1n
        <= cnlgn + 1 when c <= c1
thus T(n) = O(nlgn)
assume T([n/2]) >= c(n/2)lg(n/2) + 1
for any c1n = Θ(n)
T(n)    >= 2 * c(n/2)lg(n/2) + 1 + c1n
        = cnlgn - cn + 1 + c1n
        >= cnlgn + 1 when c <= c1
thus T(n) = Ω(nlgn)
T(1)    = clg1 + 1 = 1 = Θ(1)
therefore T(n) = Θ(nlgn)

4.3-6
assume T(n) <= nlgn
T(n)    <= 2 * (n/2 + 17)lg(n/2 + 17) + n
        <= 2 * (n/2)lg(n/2) + n
        = nlgn - n + n = nlgn
T(n) = O(nlgn)

4.3-7
assume T(n) <= cn^log(3, 4)
T(n)    <= 4 * c(n/3)^log(3,4) + n
        = 4 * n^log(3,4)/4 + n
        = n^log(3,4) + n
        stuck
assume T(n) <= c1n^log(3,4) - c2n
T(n)    <= 4 * c1(n/3)^log(3,4) - 4 * c2(n/3) + n
        = c1n^log(3,4) - (4/3) * c2n + n
        <= c1n^log(3,4) - c2n when 4/3 * c2 - 1 >= c2
T(n) = O(n^log(3,4))
assume T(n) >= c1n^log(3,4) + c2n
T(n)    >= 4 * (c1(n/3)^log(3,4) - c2(n/3)) + n
        = c1n^log(3,4) - (4/3)*c2n + n
        >= c1n^log(3,4) - c2n when (4/3) * c2 - 1 <= c2
T(n) = Ω(n^log(3,4))
therefore T(n) = Θ(n^log(3,4))

4.3-8
the conclusion is incorrect, the recurrence
    T(n) = 4T(n/2) + n^2
is case 2 of master theorem, which means T(n) = Θ(n^2lgn)

4.3-9
T(n) = 3T(n^(1/2)) + lgn
let m = lgn, then
T(2^m)  = 3T((2^m)^(1/2)) + m
        = 3T(2^(m/2)) + m
let S(m) = T(2^m)
S(m) = 3S(m/2) + m
assume S(m) <= c1m^lg3 - c2m
S(m)    <= 3c1(m/2)^lg3  - (3/2)c2m + m
        = c1m^lg3 - (3/2)c2m + m
        <= c1m^lg3 - c2m when (3/2)c1 - 1 < c2
S(m) = O(m^lg3)
similarly, S(m) = Ω(m^lg3), S(m) = Θ(m^lg3)
T(n) = T(2^m) = S(m) = Θ(m^lg3) = Θ(lgn^lg3)

4.4-1
T(n) = 3T(n/2) + n
n/2 every level, lgn levels in total
for i = 0, 1 .. lgn, ith level has 3^i nodes, each node is n/2^i
the base level has 3^lgn = n^lg3 nodes, each is Θ(1)
Σ(3/2)^i will not converge
T(n)    = Σ(i = {0..lgn})(3/2)^i * n + Θ(n^lg3)
        = ((3/2)^lgn - 1) / (3/2 - 1) * n + Θ(n^lg3)
        = 2(n^(lg3 - 1) - 1) * n + Θ(n^lg3)
        = 2(n^lg3) - n + Θ(n^lg3)
        = O(n^lg3)
assume T(n) <= c1n^lg3 - c2n
T(n)    <= 3c1(n/2)^lg3 - 3c2(n/2) + n
        = cn^lg3 - (3/2)c2n + n
        <= c1n^lg3 - c2n when (3/2)c2 - 1 >= c2

4.4-2
T(n) = T(n/2) + n^2
n/2 every level, lgn levels in total 
for i = 0, 1 .. lgn, ith level has a single node, each node is (n/2^i)^2 = n^2/4^i
the base level has 1 node, Θ(1) in total
T(n)    = Σ(i = {0 .. lgn})(1/4)^i * n^2 + Θ(1)
        <= 1/(1 - 1/4) * n^2 + Θ(1)
        = O(n^2)
without induction, this must be a tight bound, as T(n) >= n^2

4.4-3
T(n) = 4T(n/2 + 2) + n, assume it's asymptotically equivalent to T(n) = 4T(n/2) + n
n/2 every level, lgn levels in total
for i = 0, 1 .. lgn, ith level has 4^i nodes, each node is n/2^i
the base level has 4^lgn nodes, Θ(n^2) in total
T(n)    = Σ(i = {0 .. lgn})2^i * n + Θ(n^2)
        = (2^lgn - 1) / (2 - 1) * n + Θ(n^2)
        = (n - 1) * n + Θ(n^2)
        = O(n^2)
assume T(n) <= c1n^2 - c2n
T(n)    <= 4 * (c1(n/2 + 2)^2 - c2(n/2 + 2)) + n
        = c1n^2 + 4c1n + 4c1 - 2c2n + 8 + n
        = c1n^2 + (4c1 - 2c2 + 1)n + 8
        <= c1n^2 - c2n when 2c2 - 4c1 >= c2 and n is big enough
therefore T(n) = O(n^2)

4.4-4
n - 1 every level, n levels in total
for i = 0, 1, .. n, ith level has 2^i nodes, each node is 1
the base level has 2^n nodes, Θ(2^n) in total
T(n)    = Σ(i = {0 .. n})2^i + Θ(2^n)
        = O(2^n)
assume T(n) <= c2^n - 1
T(n)    <= 2 * c2^(n-1) - 2 + 1
        = c2^n - 1
therefore T(n) = O(2^n)

4.4-5
T(n) = T(n-1) + T(n/2) + n
the longest simple path is of length n
as n - 1 + n/2 < (3/2)n, the sum of ith level is smaller than (3/2)^i * n
the base level have at most 2^n nodes, Θ(2^n) in total
T(n)    <= Σ(i = {0 .. n})(3/2)^i * n + Θ(2^n)
        = Θ((3/2)^n * n) + Θ(2^n)
        = O(2^n)
assume T(n) <= c2^n
T(n)    <= c2^(n-1) + c2^(n/2) + n
        <= c2^n for large enough n

4.4-6
thanks https://ita.skanev.com/04/04/06.html
the shortest simple path from top to root is log(3, n)
each level still cn, this time the binary tree up to level log(3, n) is guarenteed to be complete
therefore T(n) >= log(3, n) * cn = Θ(nlgn), T(n) = Ω(nlgn)

4.4-7
cn
4c(n/2)
16c(n/4)
...
lgn levels in total, ith level has 4^i nodes, each is cn/2^i
the base level has 4^lgn = n^2 nodes, Θ(n^2) in total
T(n)    = Σ(i = {0 .. lgn})2^i * cn + Θ(n^2)
        = Θ(2^lgn * cn) + Θ(n^2)
        = Θ(n^2)
assume T(n) <= c1n^2 - c2n
T(n)    <= 4 * (c1(n/2)^2 - c2(n/2)) + cn
        = c1n^2 - 2c2n + cn
        <= c1n^2 - c2n when c2 >= c
T(n) = O(n^2), similarly T(n) = Ω(n^2)

4.4-8
as a is a constant, T(a) = Θ(1)
T(n) = T(n-a) + Θ(1) + cn
n/a levels in total, ith level has 1 node, each node c(n - ia) + Θ(1)
base level a single node of Θ(1)
T(n)    = Σ(i = {0 .. n/a})(c(n - ia) + Θ(1)) + Θ(1)
        = Θ(n/a) + cn^2/a - Θ((n/a)^2) * a
        = Θ(n^2)

4.4-9
reuse the solution to T(n) = T(n/3) + T(2n/3) + O(n)
T(n) = Ω(nlgn) and T(n) = O(n^log(max(1/α, 1/(1-α)), 2))

4.5-1
a.  a = 2, b = 4, log(b, a) = 1/2, f(n) = 1 = n^0, 1/2 > 0
    T(n) = Θ(n^(1/2))
b.  a = 2, b = 4, log(b, a) = 1/2, f(n) = n^(1/2) = n^log(b, a)
    T(n) = Θ(n^(1/2)lgn)
c.  a = 2, b = 4, log(b, a) = 1/2, f(n) = n, 1/2 < 1
    T(n) = Θ(n)
d.  a = 2, b = 4, log(b, a) = 1/2, f(n) = n^2, 1/2 < 2
    T(n) = Θ(n^2)

4.5-2
log(4, a) < log(2, 7) = log(4, 49)
a < 49

4.5-3
a = 1, b = 2, log(b, a) = 0, f(n) = 1 = n^0 = n^log(b, a)
T(n) = Θ(lgn)

4.5-4
a = 4, b = 2, log(b, a) = 2, f(n) = n^2lgn
f(n) = Ω(n^log(b, a)) but not polynomially larger, master method doesn't apply

4.5-5
f(n) = n^(ε + |sin(n)|), a = 1, b = 2 for some small positive constant very close to 0
log(b, a) = 0, ε + |sin(n)| >= ε > 0
for any n/2 = 2kπ + π/2, sin(n/2) = 1, sin(n) = 0
af(n/b) = (n/2)^(ε + |sin(n/2)|) >= n/2
when n is large
cf(n) <= n^ε < n/2 for infinitely many k and n