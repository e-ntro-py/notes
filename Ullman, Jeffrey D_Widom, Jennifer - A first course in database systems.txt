Despite being about database, exercises in this book do not have unique indexes.
To compensate chapter number is prepended to exercise indexes in notes, e.g.
    2.3.4
is exercise 3.4 in chapter 2.

There is a heated debate whether relation names should be singular or plural.
This book cannot decide between the two conventions.

renaming in linear notation is implicit in notes, e.g.
    // A(a, b, c)
    B := A
should be interpreted as B := ρ{B(a, b, c)}(A)

A quick method to find some keys of a relation:
    any attribute that cannot be produced by completely non-trivial FDs must be prime

2.2.1
a - f.  Accounts(accNo: integer key, type: string, balance: integer)
        Customers(firstName: string, lastName: string, idNo: integer key, account: integer)
g.  any permutation will do

2.2.2
ISBN, airplane seat number, TCP cookie

2.2.3
c.  n!m!

2.3.1
//  the difference between VARCHAR and CHAR is implementation-dependent. In SQLite them are synonyms.
//  no trailing comma allowed, all spaces insignificant.
a.  CREATE TABLE Product (
        maker   VARCHAR(32),
        model   INT,
        type    CHAR(16),
        PRIMARY KEY (model)
    );
b.  CREATE TABLE PC (
        model   INT,
        speed   DECIMAL(3, 1),
        ram     INT,
        hd      INT,
        price   DECIMAL(10, 2),
        PRIMARY KEY (model)
    );
c.  CREATE TABLE Laptop (
        model   INT,
        speed   DECIMAL(3, 1),
        ram     INT,
        hd      INT,
        screen  DECIMAL(4, 1),
        price   DECIMAL(10, 2),
        PRIMARY KEY (model)
    );
d.  CREATE TABLE Printer (
        model   INT,
        color   BOOLEAN,
        type    CHAR(16),
        price   DECIMAL(10, 2),
        PRIMARY KEY (model)
    );
e.  ALTER TABLE Printer DROP color;
f.  ALTER TABLE Laptop ADD od CHAR(16) DEFAULT 'none'

2.3.2
a.  CREATE TABLE Classes (
        class   VARCHAR(255),
        type    CHAR(2),
        country VARCHAR(255),
        numGuns INT,
        bore    FLOAT,
        displacement    INT,
        PRIMARY KEY (class)
    );
b.  CREATE TABLE Ships (
        name    VARCHAR(255),
        class   VARCHAR(255),
        launched    DATE,
        // if ship names are not distinct, the relation `Outcomes` makes no sense
        PRIMARY KEY (name)
    );
c.  CREATE TABLE Battles (
        name    VARCHAR(255),
        date    Date,
        PRIMARY KEY (name)
    );
d.  CREATE TABLE Outcomes (
        ship    VARCHAR(255),
        battle  VARCHAR(255),
        result  CHAR(16),
        PRIMARY KEY (ship, battle)
    );
e.  ALTER TABLE Classes DROP bore;
f.  ALTER TABLE Ship ADD yard VAR(255);

2.4.1
// expressions only
a.  π_{model}(σ_{speed >= 300}(PC))
b.  A(m) := π_{model}(σ_{hd >= 100}(Laptop))
    π_{maker}(Product ⨝ A)
c.  A := π_{model, price}(PC)
    B := π_{model, price}(Laptop)
    C := π_{model, price}(Printer)
    π_{model, price}(σ_{maker = 'B'}(Product ⨝ (A ∪ B ∪ C)))
d.  π_{model}(σ_{color = 'color'}(Printer))
e.  A := π_{maker}(Product ⨝ Laptop)
    B := π_{maker}(Product ⨝ PC)
    A - B
f.  A := π_{model, hd}(PC)
    B := π_{model, hd}(PC)
    π_{hd}(A ⨝_{A.model != B.model & A.hd = B.hd} B)
g.  A := PC
    B := PC
    π_{A.model, B.model}(A ⨝_{A.speed = B.speed & A.ram = B.ram & A.model < B.model} B)
h.  A := π_{model, speed}(PC)
    B := π_{model, speed}(Laptop)
    C := π_{model}(σ_{speed >= 2.8}(A ∪ B))
    D := π_{maker, model}(Product ⨝ C)
    E := D
    π_{maker}(D ⨝_{D.maker = E.maker & D.model != E.model} E)
i.  let R(a) be a single column relation where a is well ordered, define operator max(R) as:
        S := R
        // L := (R ⨝_{R.a > S.a} S) selects all component `a` smaller than some other `a` in the same relation
        // R - L is the component not smaller than any other components in the same relation 
        // i.e. the maximum 
        R - π_{S.a}(R ⨝_{R.a > S.a} S)
    A := π_{model, speed}(PC)
    B := π_{model, speed}(Laptop)
    C := A ∪ B
    M := max(π_{speed}(C))
    π_{maker}(Product ⨝ (C ⨝ M))
j.  A, B, C := Product ⨝ PC
    D := σ_{A.speed != B.speed & B.speed != C.speed & A.speed != C.speed}(A x B x C)
    π_{maker}(σ_{A.maker = B.maker, B.maker = C.maker}(D))
k.  // remove >= 4 models maker from >= 3 models maker
    // would be unnecessarily long, skipped

2.4.2
//  skipped

2.4.3
// expressions only
// let year(date) be a function from date to year
// assume date ordered
a.  π_{class, country}(σ_{bore >= 16}(Classes))
b.  A := π_{name}(σ_{launched < 1921}(Ships))
    // dangling ships in Outcomes
    B := Battles ⨝ ρ_{Outcomes(ship, name, result)}(Outcomes)
    C := π_{ship}(σ_{year(date) < 1921}(B))
    A ∪ ρ_{C(name)}(C)
c.  A := Battles ⨝ ρ_{Outcomes(ship, name, result)}(Outcomes)
    π_{ship}(σ_{battle = 'Denmark Strait' & result = 'sunk'}(A))
d.  A := Classes ⨝ Ships
    π_{name}(σ_{displacement > 35000 & launched >= 1921}(A))
e.  A := Ships ⨝ ρ_{Outcomes(name, battle, result)}(Outcomes) ⨝ Classes
    π_{name, displacement, numGuns}(σ_{battle = 'battle of Guadalcanal'}(A))
f.  π_{name}(Ships) ∪ ρ_{A(name)}(π_{ship}(Outcomes))
g.  A := π_{class, name}(Classes ⨝ Ships)
    B := π{class}(A)
    C := A
    D := π_{class}(A ⨝_{A.class = C.class & A.name != C.name} C)
    C - D
h.  A := π_{country, type}(Classes)
    B := A
    π_{country}(A ⨝_{A.country = B.country & A.type = 'bb' & B.type = 'bc'} B)
i.  A := π_{ship, date}(Outcomes ⨝ ρ_{Battles(battle, date)}(Battles))
    B := A
    π_{ship}(A ⨝_{A.ship = B.ship & A.date < B.date} B)

2.4.4
//  skipped

2.4.5
the duplicating attributes are not removed

2.4.6
union is monotone:
    A ∪ B ⊆ A ∪ (B ∪ {a}) for any a
intersection is monotone:
    A ∩ B ⊆ A ∩ (B ∪ {a}) = (A ∩ B) ∪ (A ∩ {a}) by distribution rule
difference is not monotone:
    {a, b} - {a} = {b}
    {a, b} - {a, b} = ∅
Cartesian product is monotone:
    A x (B ∪ {a})
    = (A x B) ∪ (A x {a})
selection is monotone (trivial)
projection is monotone (trivial)
natural join is monotone:
    composition of monotone operators is monotone
    natural join is composition of Cartesian product, selection and projection
theta join is monotone:
    similar to above
renaming is monotone (trivial)

2.4.7
a.  min: max(m, n), R ⊆ S or vice versa
    max: m + n, R and S are disjoint
b.  min: 0, R and S have common attribute but no common components
    max: m * n, R and S have no common attribute
c.  min: 0, σ_C(R) is empty
    max: m * n, σ_C(R) = R
d.  min: 0, π_L(R) ⊆ S
    max: m, π_L(R) and S are disjoint

2.4.8
let s and r be all attributes of S and R
π_r(σ_{R.(s ∩ r) = S.(s ∩ r)}(R x S))
π_r(R ⨝_{R.(s ∩ r) = S.(s ∩ r)} S)
π_r(R ⨝ S)

2.4.9
R - π_r(R ⨝ S)

2.4.10
let A = (A1, .., An), B = (B1, .., Bm)
P := π_A(R) x S // all necessary tuples if R / S = π_A(R)
M := π_A(P - R) // if (t, s) ∈ P - R, (t, s) is required for t ∈ R / S but missing from R, t ∉ R / S
π_A(R) - M

2.5.1
//  found an online relational algebra interpreter **with relations in this book pre-inputted** 
//  thanks https://dbis-uibk.github.io/relax/calc/local/uibk/local/3
a.  σ_{speed < 2.00 & price > 500}(PC) = ∅
    model 1011
b.  σ_{screen < 15.4 & hd < 100 & price > 1000}(Laptop) = ∅
    model 2004
c.  π_{maker}(σ_{type = 'pc'}(Product)) ∩ π_{maker}(σ_{type = 'laptop'}(Product)) = ∅
    maker A, B, E
d.  A := π_{model, speed}(PC) ∪ π_{model, speed}(Laptop)
    // all product with speed 
    B := Product ⨝ A
    C := B
    // models with speed slower than some other model with the same maker
    D(maker, model, type) := π_{C.maker, C.model, C.type}(B ⨝_{B.maker = C.maker & B.speed > C.speed} C)
    // maker whose most speedy model is a laptop 
    E := π_maker(σ_{type = 'laptop'}(Product - C))
    π_maker(σ_{type = 'pc'}(Product)) ⊆ E
    maker A, B
e.  A := π_{ram, price}(PC)
    B := π_{ram, price}(Laptop)
    C := A x B
    σ_{A.ram < B.ram & A.price > B.price}(C) = ∅
    model 2002, 2006, 2008

2.5.2
//  thanks https://dbis-uibk.github.io/relax/calc/local/uibk/local/3
a.  σ{bore > 16}(Classes) = ∅
    class Yamato
b.  σ{numGuns > 9 & bore > 14}(Classes) = ∅
    no violation
c.  // would be easy with grouping operator
    // σ_{ships > 2}(γ_{class; count(name) -> ships}(Classes ⨝ Ships)) = ∅
    S1, S2, S3 := Ships
    A := π_class(σ_{S1.class = S2.class & S2.class = S3.class}(S1 x S2 x S3))
    A = ∅
    class Kongo, Iowa, Revenge
d.  //  the constraint is ambiguous in the meaning of `have both`, there's a few possibilities:
    //  "simultaneously existing": hard, unclear if even possible to express in relational algebra
    //  "built / launched": easier, described by the expression below
    A1, A2 := π_{country, type}(Classes ⨝ Ships)
    A1 ⨝_{A1.country = A2.country & A1.type = 'bb' & A2.type = 'bc'} A2 = ∅
    country Gt. Britain, Japan
e.  A := ρ_{A(ship, numGuns)}(π_{name, numGuns}(Classes ⨝ Ships))
    B := π_{battle, ship, numGuns, result}(Outcomes ⨝ A)
    C := π_battle(σ{numGuns > 9}(B))
    D := π_battle(σ{numGuns < 9 & result = 'sunk'}(B))
    C ∩ D = ∅
    battle 'Denmark Strait', 'Guadalcanal', 'North Cape', 'Pearl Harbor', 'Surigao Strait', all of them

2.5.3
let A = (A1, .., An)
let B = (B1, .., Bn)
π_A(R) ⊆ π_B(S)

2.5.4
E1 = E2 <=> (E1 ⊆ E2 & E2 ⊆ E1) so no

3.1.1
SS# -> name, street address, city, state, ZIP code, area code
street address, city, state -> ZIP code, area code
PRIMARY KEY (SS#, phone#)
people can share name, street address, city, state, ZIP code, area code and phone number
a person can have multiple phone number

3.1.2
ID -> x, y, z, vx, vy, vz
PRIMARY KEY (ID)

3.1.3
a.  |2^{A2, .., An}| = 2^|{A2, .., An}| = 2^(n - 1)
b.  2 * 2^(n - 1) - 2^(n - 2), every superset of {A1, A2} is counted twice
c.  2 * 2^(n - 2) - 2^(n - 4), every superset of {A1, A2, A3, A4} is counted twice
d.  2 * 2^(n - 2) - 2^(n - 3), every superset of {A1, A2, A3} is counted twice

3.2.1
./database/functional_dependency
C -> A, D
D -> A
A, B -> C, D
A, C -> D
B, C -> A, D
B, D -> A, C
C, D -> A
A, B, C -> D
A, B, D -> C
B, C, D -> A
{ A }: Nonkey
{ B }: Nonkey
{ C }: Nonkey
{ D }: Nonkey
{ A, B }: Key
{ A, C }: Nonkey
{ A, D }: Nonkey
{ B, C }: Key
{ B, D }: Key
{ C, D }: Nonkey
{ A, B, C }: Superkey
{ A, B, D }: Superkey
{ A, C, D }: Nonkey
{ B, C, D }: Superkey
{ A, B, C, D }: Superkey

3.2.2
./database/functional_dependency
i.  A -> B, C, D
    B -> C, D
    A, B -> C, D
    A, C -> B, D
    A, D -> B, C
    B, C -> D
    B, D -> C
    A, B, C -> D
    A, B, D -> C
    A, C, D -> B
    { A }: Key
    { B }: Nonkey
    { C }: Nonkey
    { D }: Nonkey
    { A, B }: Superkey
    { A, C }: Superkey
    { A, D }: Superkey
    { B, C }: Nonkey
    { B, D }: Nonkey
    { C, D }: Nonkey
    { A, B, C }: Superkey
    { A, B, D }: Superkey
    { A, C, D }: Superkey
    { B, C, D }: Nonkey
    { A, B, C, D }: Superkey
ii. A, B -> C, D
    A, D -> B, C
    B, C -> A, D
    C, D -> A, B
    A, B, C -> D
    A, B, D -> C
    A, C, D -> B
    B, C, D -> A
    { A }: Nonkey
    { B }: Nonkey
    { C }: Nonkey
    { D }: Nonkey
    { A, B }: Key
    { A, C }: Nonkey
    { A, D }: Key
    { B, C }: Key
    { B, D }: Nonkey
    { C, D }: Key
    { A, B, C }: Superkey
    { A, B, D }: Superkey
    { A, C, D }: Superkey
    { B, C, D }: Superkey
    { A, B, C, D }: Superkey
iii.A -> B, C, D
    B -> A, C, D
    C -> A, B, D
    D -> A, B, C
    A, B -> C, D
    A, C -> B, D
    A, D -> B, C
    B, C -> A, D
    B, D -> A, C
    C, D -> A, B
    A, B, C -> D
    A, B, D -> C
    A, C, D -> B
    B, C, D -> A
    { A }: Key
    { B }: Key
    { C }: Key
    { D }: Key
    { A, B }: Superkey
    { A, C }: Superkey
    { A, D }: Superkey
    { B, C }: Superkey
    { B, D }: Superkey
    { C, D }: Superkey
    { A, B, C }: Superkey
    { A, B, D }: Superkey
    { A, C, D }: Superkey
    { B, C, D }: Superkey
    { A, B, C, D }: Superkey

3.2.3
let A = (A1, .., An), similarly define B, C and E according to the context
a.  add C to the initial value of set X, each FD considered in step 3 still applies, inductively {A}+ ⊆ {A, C}+
    B ∈ {A, C}+, A, C -> B
b.  B ∈ {A}+ ⊆ {A, C}+, C ∈ {A, C}+ // trivial FD 
    => {B, C} ⊆ {A, C}+
    => A, C -> B, C
c.  if A -> B, {B}+ ⊆ {A}+:
        choose A -> B as the first FD in step 3, apply argument in part a
    A -> B
    => {B}+ ⊆ {A}+
    => {B, E}+ ⊆ {A, E}+ // part b
    => {C}+ ⊆ {A, E}+ // C = B, E by definition
    => D ∈ {A, E}+
    => A, E -> D
d.  A -> B
    => A, C -> B // part a
    => A, C -> D // part a again
    => A, C -> B, D

3.2.4
a.  A   B
    1   0
    0   0
b.  A   B   C
    0   0   0
    1   0   1
c.  A   B   C
    0   0   0
    0   1   1
    1   0   1
    1   1   0
    // XOR table

3.2.5
let A -> B be a non-trivial FD, A ∩ B = ∅, B != ∅
let c(B) be the compliment of B,
A ∪ c(B) -> B, A ∪ c(B) = c(B), c(B) -> B, contradiction

3.2.6
Y -> X by trivial FD, then part c of 3.2.3

3.2.7
X ⊆ (X+)+ by 3.2.6
if there's A ∈ (X+)+ - X+, X -> X+, X+ -> A but not X -> A, contradicting transitivity

3.2.8
a.  only trivial FDs
    otherwise for some non-trivial A -> B, c(B) -> B, c(B)+ = {A, B, C, D}, c(B) is not closed
b.  A -> B, C, D
    B -> A, C, D
    C -> A, B, D
    D -> A, B, C
    {A}+ is closed by 3.2.7, A ∈ {A}+, {A}+ can only be {A, B, C, D}
    for any non-empty set P, P -> {A, B, C, D}
c.  C -> A, B, D
    D -> A, B, C
    as proved by part b
    {A}+ ⊆ {A, B}+ = {A, B}, so
    A -> B
    B -> A
    A, B -> A, B

3.2.9
{A -> B, B -> C, C -> A} and the reverse, 2 variants
{A -> B, B -> A, B -> C, C -> B}, 3 variants
{(A, B -> C), A -> B, B -> A, C -> A, C -> B}, 3 variants

3.2.10
./database/functional_dependency
// manually minified
a.  C -> A
    A, B -> C
b.  A, C -> B
c.  A, C -> B
    B, C -> A
d.  A -> B
    B -> C 
    C -> A

3.2.11
for any FD A -> B, B ∈ A+
step 1, splitting of FDs, can be derived from transitivity and reflexivity:
    A -> B, C 
    with B, C -> B & B, C -> C // reflexivity
    => A -> B & A -> C // transitivity
step 2, let X = A
step 3, at each iteration, a FD C -> D applies to Xn where C ⊆ Xn
    construct an FD Xn -> Xn ∪ D:
        C -> D
        => C ∪ Xn -> Xn ∪ D // augmentation
        => Xn -> Xn ∪ D // splitting
    and let Xn ∪ D be the set Xn+1 in the next iteration, it will be a chain of FDs like
    A = X0 -> X1 -> .. -> Xn = A+
    by transitivity, 
        A -> A+
        => A -> B // B ⊆ A+ and splitting

3.3.1
./database/functional_dependency
a.  C -> D
    D -> A
    { B, C }
    { C, D }
    { A, D }
b.  B -> C
    B -> D
    { A, B }
    { B, C, D }
c.  no violations
    { A, B, C, D }
d.  no violations
    { A, B, C, D }
e.  A, B -> C
    D, E -> C
    B -> D
    { A, B, E }
    { A, B, C }
    { B, D }
f.  C -> D
    D -> B
    D -> E
    { A, C }
    { C, D }
    { B, D, E }

3.3.2
A -> B first:
    { A, B }
    { A, C }
    { A, D }
A -> B, C first:
    { A, B, C }
    { A, D }
A is not a super key of { A, C, D }

3.3.3
A -> B first:
    { A, B } 
    { A, C }
    { A, D }
A -> B, C first 
    { A, B, C }
    { A, D }
again A is not a super key of { A, C, D }

3.3.4
define R as:
    A   B   C
    0   0   0
    1   0   1
π_{A, B}(R) ⨝ π_{B, C}(R) =
    A   B   C
    0   0   0
    0   0   1
    1   0   0   
    1   0   1

3.4.1
./database/functional_dependency
a.  a   |b   |c   |d1  |e1
    a   |b   |c   |d   |e1
    a   |b3  |c   |d3  |e
b.  Lossless
c.  Lossless
d.  a   |b   |c   |d1  |e
    a2  |b   |c   |d   |e2
    a   |b3  |c   |d1  |e

3.4.2
./database/functional_dependency
a.  B -> E is not preserved
b.  Lossless
c.  A -> D is not preserved
d.  A -> D is not preserved

3.5.1
a.  { A, B }
    { B, C }
    { B, D }
    no violations
b.  { A, B }
    violations:
        B -> C
        B -> D
    {{ B, C }, { B, D }, { A, B }}
c.  { A, B }
    { A, D }
    { B, C }
    { C, D }
    no violations
d.  { A }
    { B }
    { C }
    { D }
    no violations
e.  { A, B, E }
    violations:
        A, B -> C
        D, E -> C 
        B -> D
    {{ A, B, C }, { D, E, C }, { B, D }, { A, B, E }}
f.  { A, B }
    { A, C }
    { A, D }
    violations:
        D -> E
    {{ A, B, C }, { C, D }, { D, B }, { D, E }}

3.5.2
./database/functional_dependency
a.  { H, S }: Key
b.  // see code
c.  { C, T }: BCNF abiding
    { C, H, R }: BCNF abiding
    { T, H, R }: BCNF abiding
    { H, R, S }: BCNF abiding
    { C, S, G }: BCNF abiding

3.5.3
a.  { I, S }: Key
b.  // see code 
c.  { S, D }: BCNF abiding
    { B, I }: BCNF abiding
    { I, S, Q }: BCNF abiding
    { B, O }: BCNF abiding

3.5.4
./database/functional_dependency
// see code

3.5.5
./database/functional_dependency
{ A, B, C }
A -> C 
B -> C
the only key is { A, B }, both FDs are violating 3NF
a possible decomposition is {{ A, C }, { A, B }}
the FD B -> C is not preserved

description of MVD A ->> B in relational algebra, where C = c(A ∪ B):
    R1 := R
    R2 := R
    π_{A, R1.B, R2.C}(R1 ⨝_{R1.A = R2.A} R2) = R

3.6.1
(a, b1, c2)
(a, b1, c3)
(a, b2, c1)
(a, b2, c3)
(a, b3, c1)
(a, b3, c2)

3.6.2
a.  s -> n, b
    cs -> cn, cb
    as -> am
    n, s, b ->> cn, cs, cb
b.  { s, n, b }
    { cs, cn, cb }
    { as, am }
    { s, as }
    { s, cs }

3.6.3
a.  if A ->> B in R(A, B, C, D), then A ->> B in π_{A, B, C}(R):
        ∀t,u ∈ π_{A, B, C}(R), π_A(t) = π_A(u)
        => ∃v,w π_{A, B, C}(v) = t, π_{A, B, C}(w) = u // definition of projection
        => (π_A(v), π_B(v), π_{C, D}(w)) ∈ R // A ->> B in R
        => π_{A, B, C}(π_A(v), π_B(v), π_{C, D}(w)) ∈ π_{A, B, C}(R) // definition of projection
        => (π_A(v), π_B(v), π_{C}(w)) ∈ π_{A, B, C}(R) // distribution of projection 
        => (π_A(t), π_B(t), π_{C}(u)) ∈ π_{A, B, C}(R) // as how v, w are defined
    keys: 
        { A, B, C, D }
    violations:
        A ->> B
        A ->> C
    decomposition:
        { A, B }
        { A, C }
        { A, D }
b.  keys:
        { A, B, C, D }
    violations:
        A ->> B 
        B ->> C, D
    decomposition:
        { A, B }
        // A ->> C, D is trivial
        { A, C, D }
c.  keys:
        { A, B, C }
    violations:
        A, B ->> C
        B -> D
    decomposition:
        { B, D }
        { A, B, C }
d.  keys:
        { A, B, C }
    violations:
        A ->> B
        A, B ->> C
        A -> D 
        A, B -> E
    decomposition:
        // apply A, B -> E on R
        { A, B, E }
        // apply A -> D on { A, C, D }
        { A, D }
        { A, C }

3.6.4
name:   there may be multiple people living on the same street & city and starred the same movie
street: the same star may have different addresses throughout their career
city:   same as above
title:  the same star may appear in multiple movies in the same year
year:   the same star may appear in both the original and the remake of a movie several years after

3.7.1
a.  A -> D: true
b.  A ->> D: true
c.  A -> E: false
d.  A ->> E: true

3.7.2
A ->> E
C ->> E
A, C ->> E

3.7.3
1.  if X ->> Y, Z ⊆ X, then X ->> Y ∪ Z:
        ∀u,t π_X(u) = π_X(t)
        // X ->> Y
        => ∃v π_X(v) = π_X(u) & π_Y(v) = π_Y(u) & π_{~(X ∪ Y)}(v) = π_{~(X ∪ Y)}(t)
        // Z ⊆ X
        => ∃v π_X(v) = π_X(u) & π_{Y ∪ Z}(v) = π_{Y ∪ Z}(u) & π_{~(X ∪ Y)}(v) = π_{~(X ∪ Y)}(t)
2.  if X ->> Y, then X ->> Y - X:
        ∀u,t π_X(u) = π_X(t)
        // X ->> Y
        => ∃v π_X(v) = π_X(u) & π_Y(v) = π_Y(u) & π_{~(X ∪ Y)}(v) = π_{~(X ∪ Y)}(t)
        // Y - X ⊆ Y, X ∪ (Y - X) = X ∪ Y
        => ∃v π_X(v) = π_X(u) & π_{Y - X}(v) = π_{Y - X}(u) & π_{~(X ∪ (Y - X))}(v) = π_{~(X ∪ (Y - X))}(t)
3.  transitive law of projection:
        Z(w) = Z(v), Y(v) = Y(u) => (Y ∩ Z)(w) = (Y ∩ Z)(u)
a.  assume X ∩ Y = ∅, X ∩ Z = ∅
    X ->> Y & X ->> Z
    // complement rule
    => X ->> ~(X ∪ Y) & X ->> ~(X ∪ Z)
    // part b
    => X ->> ~(X ∪ Y) ∩ ~(X ∪ Z)
    => X ->> (~X ∩ ~Y) ∩ (~X ∩ ~Z)
    => X ->> ~X ∩ (~Y ∩ ~Z)
    => X ->> ~X ∩ ~(Y ∪ Z)
    => X ->> ~(X ∪ Y ∪ Z)
    // complement rule
    => X ->> X ∪ Y ∪ Z
    // rule 1
    => X ->> Y ∪ Z
    similarly can be generated to Y, Z not disjoint to X
b.  assume X ∩ Y = ∅, X ∩ Z = ∅
    ∀u,t X(u) = X(t)
    // apply X ->> Y on u, t
    => ∃v X(v) = X(u) & Y(v) = Y(u) & ~(X ∪ Y)(v) = ~(X ∪ Y)(t)
    // apply X ->> Z on v, t
    => ∃w X(w) = X(v) & Z(w) = Z(v) & ~(X ∪ Z)(w) = ~(X ∪ Z)(t)
        ~(X ∪ Z) ∩ Y
        = (~X ∩ ~Z) ∩ Y
        = ~X ∩ (~Z ∩ Y)
        = ~X ∩ (Y - Z)
        // X and Y disjoint
        = Y - Z, and (Y - Z) ∪ (Y ∩ Z) = Y, ~Y(w) = ~Y(t), hence
    => ∃w X(w) = X(u) & (Y ∩ Z)(w) = (Y ∩ Z)(u) & ~(X ∪ (Y ∩ Z))(w) = ~(X ∪ (Y ∩ Z))(t)
    for X ∩ Y, X ∩ Z != ∅,
        X ->> Y & X ->> Z
        // rule 1
        => X ->> Y - X & x ->> Z - X
        => X ->> (Y ∪ Z) - X
        // rule 2
        => X ->> Y ∪ Z