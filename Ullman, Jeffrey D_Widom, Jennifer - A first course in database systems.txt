Despite being about database, exercises in this book do not have unique indexes.
To compensate chapter number is prepended to exercise indexes in notes, e.g.
    2.3.4
is exercise 3.4 in chapter 2.

There is a heated debate whether relation names should be singular or plural.
This book cannot decide between the two conventions.

renaming in linear notation is implicit in notes, e.g.
    // A(a, b, c)
    B := A
should be interpreted as B := ρ{B(a, b, c)}(A)

A quick method to find some keys of a relation:
    any attribute that cannot be produced by completely non-trivial FDs must be prime

2.2.1
a - f.  Accounts(accNo: integer key, type: string, balance: integer)
        Customers(firstName: string, lastName: string, idNo: integer key, account: integer)
g.  any permutation will do

2.2.2
ISBN, airplane seat number, TCP cookie

2.2.3
c.  n!m!

2.3.1
//  the difference between VARCHAR and CHAR is implementation-dependent. In SQLite them are synonyms.
//  no trailing comma allowed, all spaces insignificant.
a.  CREATE TABLE Product (
        maker   VARCHAR(32),
        model   INT,
        type    CHAR(16),
        PRIMARY KEY (model)
    );
b.  CREATE TABLE PC (
        model   INT,
        speed   DECIMAL(3, 1),
        ram     INT,
        hd      INT,
        price   DECIMAL(10, 2),
        PRIMARY KEY (model)
    );
c.  CREATE TABLE Laptop (
        model   INT,
        speed   DECIMAL(3, 1),
        ram     INT,
        hd      INT,
        screen  DECIMAL(4, 1),
        price   DECIMAL(10, 2),
        PRIMARY KEY (model)
    );
d.  CREATE TABLE Printer (
        model   INT,
        color   BOOLEAN,
        type    CHAR(16),
        price   DECIMAL(10, 2),
        PRIMARY KEY (model)
    );
e.  ALTER TABLE Printer DROP color;
f.  ALTER TABLE Laptop ADD od CHAR(16) DEFAULT 'none'

2.3.2
a.  CREATE TABLE Classes (
        class   VARCHAR(255),
        type    CHAR(2),
        country VARCHAR(255),
        numGuns INT,
        bore    FLOAT,
        displacement    INT,
        PRIMARY KEY (class)
    );
b.  CREATE TABLE Ships (
        name    VARCHAR(255),
        class   VARCHAR(255),
        launched    DATE,
        // if ship names are not distinct, the relation `Outcomes` makes no sense
        PRIMARY KEY (name)
    );
c.  CREATE TABLE Battles (
        name    VARCHAR(255),
        date    Date,
        PRIMARY KEY (name)
    );
d.  CREATE TABLE Outcomes (
        ship    VARCHAR(255),
        battle  VARCHAR(255),
        result  CHAR(16),
        PRIMARY KEY (ship, battle)
    );
e.  ALTER TABLE Classes DROP bore;
f.  ALTER TABLE Ship ADD yard VAR(255);

2.4.1
// expressions only
a.  π_{model}(σ_{speed >= 300}(PC))
b.  A(m) := π_{model}(σ_{hd >= 100}(Laptop))
    π_{maker}(Product ⨝ A)
c.  A := π_{model, price}(PC)
    B := π_{model, price}(Laptop)
    C := π_{model, price}(Printer)
    π_{model, price}(σ_{maker = 'B'}(Product ⨝ (A ∪ B ∪ C)))
d.  π_{model}(σ_{color = 'color'}(Printer))
e.  A := π_{maker}(Product ⨝ Laptop)
    B := π_{maker}(Product ⨝ PC)
    A - B
f.  A := π_{model, hd}(PC)
    B := π_{model, hd}(PC)
    π_{hd}(A ⨝_{A.model != B.model & A.hd = B.hd} B)
g.  A := PC
    B := PC
    π_{A.model, B.model}(A ⨝_{A.speed = B.speed & A.ram = B.ram & A.model < B.model} B)
h.  A := π_{model, speed}(PC)
    B := π_{model, speed}(Laptop)
    C := π_{model}(σ_{speed >= 2.8}(A ∪ B))
    D := π_{maker, model}(Product ⨝ C)
    E := D
    π_{maker}(D ⨝_{D.maker = E.maker & D.model != E.model} E)
i.  let R(a) be a single column relation where a is well ordered, define operator max(R) as:
        S := R
        // L := (R ⨝_{R.a > S.a} S) selects all component `a` smaller than some other `a` in the same relation
        // R - L is the component not smaller than any other components in the same relation 
        // i.e. the maximum 
        R - π_{S.a}(R ⨝_{R.a > S.a} S)
    A := π_{model, speed}(PC)
    B := π_{model, speed}(Laptop)
    C := A ∪ B
    M := max(π_{speed}(C))
    π_{maker}(Product ⨝ (C ⨝ M))
j.  A, B, C := Product ⨝ PC
    D := σ_{A.speed != B.speed & B.speed != C.speed & A.speed != C.speed}(A x B x C)
    π_{maker}(σ_{A.maker = B.maker, B.maker = C.maker}(D))
k.  // remove >= 4 models maker from >= 3 models maker
    // would be unnecessarily long, skipped

2.4.2
//  skipped

2.4.3
// expressions only
// let year(date) be a function from date to year
// assume date ordered
a.  π_{class, country}(σ_{bore >= 16}(Classes))
b.  A := π_{name}(σ_{launched < 1921}(Ships))
    // dangling ships in Outcomes
    B := Battles ⨝ ρ_{Outcomes(ship, name, result)}(Outcomes)
    C := π_{ship}(σ_{year(date) < 1921}(B))
    A ∪ ρ_{C(name)}(C)
c.  A := Battles ⨝ ρ_{Outcomes(ship, name, result)}(Outcomes)
    π_{ship}(σ_{battle = 'Denmark Strait' & result = 'sunk'}(A))
d.  A := Classes ⨝ Ships
    π_{name}(σ_{displacement > 35000 & launched >= 1921}(A))
e.  A := Ships ⨝ ρ_{Outcomes(name, battle, result)}(Outcomes) ⨝ Classes
    π_{name, displacement, numGuns}(σ_{battle = 'battle of Guadalcanal'}(A))
f.  π_{name}(Ships) ∪ ρ_{A(name)}(π_{ship}(Outcomes))
g.  A := π_{class, name}(Classes ⨝ Ships)
    B := π{class}(A)
    C := A
    D := π_{class}(A ⨝_{A.class = C.class & A.name != C.name} C)
    C - D
h.  A := π_{country, type}(Classes)
    B := A
    π_{country}(A ⨝_{A.country = B.country & A.type = 'bb' & B.type = 'bc'} B)
i.  A := π_{ship, date}(Outcomes ⨝ ρ_{Battles(battle, date)}(Battles))
    B := A
    π_{ship}(A ⨝_{A.ship = B.ship & A.date < B.date} B)

2.4.4
//  skipped

2.4.5
the duplicating attributes are not removed

2.4.6
union is monotone:
    A ∪ B ⊆ A ∪ (B ∪ {a}) for any a
intersection is monotone:
    A ∩ B ⊆ A ∩ (B ∪ {a}) = (A ∩ B) ∪ (A ∩ {a}) by distribution rule
difference is not monotone:
    {a, b} - {a} = {b}
    {a, b} - {a, b} = ∅
Cartesian product is monotone:
    A x (B ∪ {a})
    = (A x B) ∪ (A x {a})
selection is monotone (trivial)
projection is monotone (trivial)
natural join is monotone:
    composition of monotone operators is monotone
    natural join is composition of Cartesian product, selection and projection
theta join is monotone:
    similar to above
renaming is monotone (trivial)

2.4.7
a.  min: max(m, n), R ⊆ S or vice versa
    max: m + n, R and S are disjoint
b.  min: 0, R and S have common attribute but no common components
    max: m * n, R and S have no common attribute
c.  min: 0, σ_C(R) is empty
    max: m * n, σ_C(R) = R
d.  min: 0, π_L(R) ⊆ S
    max: m, π_L(R) and S are disjoint

2.4.8
let s and r be all attributes of S and R
π_r(σ_{R.(s ∩ r) = S.(s ∩ r)}(R x S))
π_r(R ⨝_{R.(s ∩ r) = S.(s ∩ r)} S)
π_r(R ⨝ S)

2.4.9
R - π_r(R ⨝ S)

2.4.10
let A = (A1, .., An), B = (B1, .., Bm)
P := π_A(R) x S // all necessary tuples if R / S = π_A(R)
M := π_A(P - R) // if (t, s) ∈ P - R, (t, s) is required for t ∈ R / S but missing from R, t ∉ R / S
π_A(R) - M

2.5.1
//  found an online relational algebra interpreter **with relations in this book pre-inputted** 
//  thanks https://dbis-uibk.github.io/relax/calc/local/uibk/local/3
a.  σ_{speed < 2.00 & price > 500}(PC) = ∅
    model 1011
b.  σ_{screen < 15.4 & hd < 100 & price > 1000}(Laptop) = ∅
    model 2004
c.  π_{maker}(σ_{type = 'pc'}(Product)) ∩ π_{maker}(σ_{type = 'laptop'}(Product)) = ∅
    maker A, B, E
d.  A := π_{model, speed}(PC) ∪ π_{model, speed}(Laptop)
    // all product with speed 
    B := Product ⨝ A
    C := B
    // models with speed slower than some other model with the same maker
    D(maker, model, type) := π_{C.maker, C.model, C.type}(B ⨝_{B.maker = C.maker & B.speed > C.speed} C)
    // maker whose most speedy model is a laptop 
    E := π_maker(σ_{type = 'laptop'}(Product - C))
    π_maker(σ_{type = 'pc'}(Product)) ⊆ E
    maker A, B
e.  A := π_{ram, price}(PC)
    B := π_{ram, price}(Laptop)
    C := A x B
    σ_{A.ram < B.ram & A.price > B.price}(C) = ∅
    model 2002, 2006, 2008

2.5.2
//  thanks https://dbis-uibk.github.io/relax/calc/local/uibk/local/3
a.  σ{bore > 16}(Classes) = ∅
    class Yamato
b.  σ{numGuns > 9 & bore > 14}(Classes) = ∅
    no violation
c.  // would be easy with grouping operator
    // σ_{ships > 2}(γ_{class; count(name) -> ships}(Classes ⨝ Ships)) = ∅
    S1, S2, S3 := Ships
    A := π_class(σ_{S1.class = S2.class & S2.class = S3.class}(S1 x S2 x S3))
    A = ∅
    class Kongo, Iowa, Revenge
d.  //  the constraint is ambiguous in the meaning of `have both`, there's a few possibilities:
    //  "simultaneously existing": hard, unclear if even possible to express in relational algebra
    //  "built / launched": easier, described by the expression below
    A1, A2 := π_{country, type}(Classes ⨝ Ships)
    A1 ⨝_{A1.country = A2.country & A1.type = 'bb' & A2.type = 'bc'} A2 = ∅
    country Gt. Britain, Japan
e.  A := ρ_{A(ship, numGuns)}(π_{name, numGuns}(Classes ⨝ Ships))
    B := π_{battle, ship, numGuns, result}(Outcomes ⨝ A)
    C := π_battle(σ{numGuns > 9}(B))
    D := π_battle(σ{numGuns < 9 & result = 'sunk'}(B))
    C ∩ D = ∅
    battle 'Denmark Strait', 'Guadalcanal', 'North Cape', 'Pearl Harbor', 'Surigao Strait', all of them

2.5.3
let A = (A1, .., An)
let B = (B1, .., Bn)
π_A(R) ⊆ π_B(S)

2.5.4
E1 = E2 <=> (E1 ⊆ E2 & E2 ⊆ E1) so no

3.1.1
SS# -> name, street address, city, state, ZIP code, area code
street address, city, state -> ZIP code, area code
PRIMARY KEY (SS#, phone#)
people can share name, street address, city, state, ZIP code, area code and phone number
a person can have multiple phone number

3.1.2
ID -> x, y, z, vx, vy, vz
PRIMARY KEY (ID)

3.1.3
a.  |2^{A2, .., An}| = 2^|{A2, .., An}| = 2^(n - 1)
b.  2 * 2^(n - 1) - 2^(n - 2), every superset of {A1, A2} is counted twice
c.  2 * 2^(n - 2) - 2^(n - 4), every superset of {A1, A2, A3, A4} is counted twice
d.  2 * 2^(n - 2) - 2^(n - 3), every superset of {A1, A2, A3} is counted twice

3.2.1
./database/functional_dependency
C -> A, D
D -> A
A, B -> C, D
A, C -> D
B, C -> A, D
B, D -> A, C
C, D -> A
A, B, C -> D
A, B, D -> C
B, C, D -> A
{ A }: Nonkey
{ B }: Nonkey
{ C }: Nonkey
{ D }: Nonkey
{ A, B }: Key
{ A, C }: Nonkey
{ A, D }: Nonkey
{ B, C }: Key
{ B, D }: Key
{ C, D }: Nonkey
{ A, B, C }: Superkey
{ A, B, D }: Superkey
{ A, C, D }: Nonkey
{ B, C, D }: Superkey
{ A, B, C, D }: Superkey

3.2.2
./database/functional_dependency
i.  A -> B, C, D
    B -> C, D
    A, B -> C, D
    A, C -> B, D
    A, D -> B, C
    B, C -> D
    B, D -> C
    A, B, C -> D
    A, B, D -> C
    A, C, D -> B
    { A }: Key
    { B }: Nonkey
    { C }: Nonkey
    { D }: Nonkey
    { A, B }: Superkey
    { A, C }: Superkey
    { A, D }: Superkey
    { B, C }: Nonkey
    { B, D }: Nonkey
    { C, D }: Nonkey
    { A, B, C }: Superkey
    { A, B, D }: Superkey
    { A, C, D }: Superkey
    { B, C, D }: Nonkey
    { A, B, C, D }: Superkey
ii. A, B -> C, D
    A, D -> B, C
    B, C -> A, D
    C, D -> A, B
    A, B, C -> D
    A, B, D -> C
    A, C, D -> B
    B, C, D -> A
    { A }: Nonkey
    { B }: Nonkey
    { C }: Nonkey
    { D }: Nonkey
    { A, B }: Key
    { A, C }: Nonkey
    { A, D }: Key
    { B, C }: Key
    { B, D }: Nonkey
    { C, D }: Key
    { A, B, C }: Superkey
    { A, B, D }: Superkey
    { A, C, D }: Superkey
    { B, C, D }: Superkey
    { A, B, C, D }: Superkey
iii.A -> B, C, D
    B -> A, C, D
    C -> A, B, D
    D -> A, B, C
    A, B -> C, D
    A, C -> B, D
    A, D -> B, C
    B, C -> A, D
    B, D -> A, C
    C, D -> A, B
    A, B, C -> D
    A, B, D -> C
    A, C, D -> B
    B, C, D -> A
    { A }: Key
    { B }: Key
    { C }: Key
    { D }: Key
    { A, B }: Superkey
    { A, C }: Superkey
    { A, D }: Superkey
    { B, C }: Superkey
    { B, D }: Superkey
    { C, D }: Superkey
    { A, B, C }: Superkey
    { A, B, D }: Superkey
    { A, C, D }: Superkey
    { B, C, D }: Superkey
    { A, B, C, D }: Superkey

3.2.3
let A = (A1, .., An), similarly define B, C and E according to the context
a.  add C to the initial value of set X, each FD considered in step 3 still applies, inductively {A}+ ⊆ {A, C}+
    B ∈ {A, C}+, A, C -> B
b.  B ∈ {A}+ ⊆ {A, C}+, C ∈ {A, C}+ // trivial FD 
    => {B, C} ⊆ {A, C}+
    => A, C -> B, C
c.  if A -> B, {B}+ ⊆ {A}+:
        choose A -> B as the first FD in step 3, apply argument in part a
    A -> B
    => {B}+ ⊆ {A}+
    => {B, E}+ ⊆ {A, E}+ // part b
    => {C}+ ⊆ {A, E}+ // C = B, E by definition
    => D ∈ {A, E}+
    => A, E -> D
d.  A -> B
    => A, C -> B // part a
    => A, C -> D // part a again
    => A, C -> B, D

3.2.4
a.  A   B
    1   0
    0   0
b.  A   B   C
    0   0   0
    1   0   1
c.  A   B   C
    0   0   0
    0   1   1
    1   0   1
    1   1   0
    // XOR table

3.2.5
let A -> B be a non-trivial FD, A ∩ B = ∅, B != ∅
let c(B) be the compliment of B,
A ∪ c(B) -> B, A ∪ c(B) = c(B), c(B) -> B, contradiction

3.2.6
Y -> X by trivial FD, then part c of 3.2.3

3.2.7
X ⊆ (X+)+ by 3.2.6
if there's A ∈ (X+)+ - X+, X -> X+, X+ -> A but not X -> A, contradicting transitivity

3.2.8
a.  only trivial FDs
    otherwise for some non-trivial A -> B, c(B) -> B, c(B)+ = {A, B, C, D}, c(B) is not closed
b.  A -> B, C, D
    B -> A, C, D
    C -> A, B, D
    D -> A, B, C
    {A}+ is closed by 3.2.7, A ∈ {A}+, {A}+ can only be {A, B, C, D}
    for any non-empty set P, P -> {A, B, C, D}
c.  C -> A, B, D
    D -> A, B, C
    as proved by part b
    {A}+ ⊆ {A, B}+ = {A, B}, so
    A -> B
    B -> A
    A, B -> A, B

3.2.9
{A -> B, B -> C, C -> A} and the reverse, 2 variants
{A -> B, B -> A, B -> C, C -> B}, 3 variants
{(A, B -> C), A -> B, B -> A, C -> A, C -> B}, 3 variants

3.2.10
./database/functional_dependency
// manually minified
a.  C -> A
    A, B -> C
b.  A, C -> B
c.  A, C -> B
    B, C -> A
d.  A -> B
    B -> C 
    C -> A

3.2.11
for any FD A -> B, B ∈ A+
step 1, splitting of FDs, can be derived from transitivity and reflexivity:
    A -> B, C 
    with B, C -> B & B, C -> C // reflexivity
    => A -> B & A -> C // transitivity
step 2, let X = A
step 3, at each iteration, a FD C -> D applies to Xn where C ⊆ Xn
    construct an FD Xn -> Xn ∪ D:
        C -> D
        => C ∪ Xn -> Xn ∪ D // augmentation
        => Xn -> Xn ∪ D // splitting
    and let Xn ∪ D be the set Xn+1 in the next iteration, it will be a chain of FDs like
    A = X0 -> X1 -> .. -> Xn = A+
    by transitivity, 
        A -> A+
        => A -> B // B ⊆ A+ and splitting

3.3.1
./database/functional_dependency
a.  C -> D
    D -> A
    { B, C }
    { C, D }
    { A, D }
b.  B -> C
    B -> D
    { A, B }
    { B, C, D }
c.  no violations
    { A, B, C, D }
d.  no violations
    { A, B, C, D }
e.  A, B -> C
    D, E -> C
    B -> D
    { A, B, E }
    { A, B, C }
    { B, D }
f.  C -> D
    D -> B
    D -> E
    { A, C }
    { C, D }
    { B, D, E }

3.3.2
A -> B first:
    { A, B }
    { A, C }
    { A, D }
A -> B, C first:
    { A, B, C }
    { A, D }
A is not a super key of { A, C, D }

3.3.3
A -> B first:
    { A, B } 
    { A, C }
    { A, D }
A -> B, C first 
    { A, B, C }
    { A, D }
again A is not a super key of { A, C, D }

3.3.4
define R as:
    A   B   C
    0   0   0
    1   0   1
π_{A, B}(R) ⨝ π_{B, C}(R) =
    A   B   C
    0   0   0
    0   0   1
    1   0   0   
    1   0   1

3.4.1
./database/functional_dependency
a.  a   |b   |c   |d1  |e1
    a   |b   |c   |d   |e1
    a   |b3  |c   |d3  |e
b.  Lossless
c.  Lossless
d.  a   |b   |c   |d1  |e
    a2  |b   |c   |d   |e2
    a   |b3  |c   |d1  |e

3.4.2
./database/functional_dependency
a.  B -> E is not preserved
b.  Lossless
c.  A -> D is not preserved
d.  A -> D is not preserved

3.5.1
a.  { A, B }
    { B, C }
    { B, D }
    no violations
b.  { A, B }
    violations:
        B -> C
        B -> D
    {{ B, C }, { B, D }, { A, B }}
c.  { A, B }
    { A, D }
    { B, C }
    { C, D }
    no violations
d.  { A }
    { B }
    { C }
    { D }
    no violations
e.  { A, B, E }
    violations:
        A, B -> C
        D, E -> C 
        B -> D
    {{ A, B, C }, { D, E, C }, { B, D }, { A, B, E }}
f.  { A, B }
    { A, C }
    { A, D }
    violations:
        D -> E
    {{ A, B, C }, { C, D }, { D, B }, { D, E }}

3.5.2
./database/functional_dependency
a.  { H, S }: Key
b.  // see code
c.  { C, T }: BCNF abiding
    { C, H, R }: BCNF abiding
    { T, H, R }: BCNF abiding
    { H, R, S }: BCNF abiding
    { C, S, G }: BCNF abiding

3.5.3
a.  { I, S }: Key
b.  // see code 
c.  { S, D }: BCNF abiding
    { B, I }: BCNF abiding
    { I, S, Q }: BCNF abiding
    { B, O }: BCNF abiding

3.5.4
./database/functional_dependency
// see code

3.5.5
./database/functional_dependency
{ A, B, C }
A -> C 
B -> C
the only key is { A, B }, both FDs are violating 3NF
a possible decomposition is {{ A, C }, { A, B }}
the FD B -> C is not preserved

description of MVD A ->> B in relational algebra, where C = c(A ∪ B):
    R1 := R
    R2 := R
    π_{A, R1.B, R2.C}(R1 ⨝_{R1.A = R2.A} R2) = R

3.6.1
(a, b1, c2)
(a, b1, c3)
(a, b2, c1)
(a, b2, c3)
(a, b3, c1)
(a, b3, c2)

3.6.2
a.  s -> n, b
    cs -> cn, cb
    as -> am
    n, s, b ->> cn, cs, cb
b.  { s, n, b }
    { cs, cn, cb }
    { as, am }
    { s, as }
    { s, cs }

3.6.3
a.  if A ->> B in R(A, B, C, D), then A ->> B in π_{A, B, C}(R):
        ∀t,u ∈ π_{A, B, C}(R), π_A(t) = π_A(u)
        => ∃v,w π_{A, B, C}(v) = t, π_{A, B, C}(w) = u // definition of projection
        => (π_A(v), π_B(v), π_{C, D}(w)) ∈ R // A ->> B in R
        => π_{A, B, C}(π_A(v), π_B(v), π_{C, D}(w)) ∈ π_{A, B, C}(R) // definition of projection
        => (π_A(v), π_B(v), π_{C}(w)) ∈ π_{A, B, C}(R) // distribution of projection 
        => (π_A(t), π_B(t), π_{C}(u)) ∈ π_{A, B, C}(R) // as how v, w are defined
    keys: 
        { A, B, C, D }
    violations:
        A ->> B
        A ->> C
    decomposition:
        { A, B }
        { A, C }
        { A, D }
b.  keys:
        { A, B, C, D }
    violations:
        A ->> B 
        B ->> C, D
    decomposition:
        { A, B }
        // A ->> C, D is trivial
        { A, C, D }
c.  keys:
        { A, B, C }
    violations:
        A, B ->> C
        B -> D
    decomposition:
        { B, D }
        { A, B, C }
d.  keys:
        { A, B, C }
    violations:
        A ->> B
        A, B ->> C
        A -> D 
        A, B -> E
    decomposition:
        // apply A, B -> E on R
        { A, B, E }
        // apply A -> D on { A, C, D }
        { A, D }
        { A, C }

3.6.4
name:   there may be multiple people living on the same street & city and starred the same movie
street: the same star may have different addresses throughout their career
city:   same as above
title:  the same star may appear in multiple movies in the same year
year:   the same star may appear in both the original and the remake of a movie several years after

3.7.1
a.  A -> D: true
b.  A ->> D: true
c.  A -> E: false
d.  A ->> E: true

3.7.2
A ->> E
C ->> E
A, C ->> E


3.7.3
for a relation R(X), t ∈ R, Y ⊆ X, define Y(t) as a function, Y(t) = π_{Y}(t)
1.  if X ->> Y, Z ⊆ X, then X ->> Y ∪ Z:
        ∀u,t π_X(u) = π_X(t)
        // X ->> Y
        => ∃v π_X(v) = π_X(u) & π_Y(v) = π_Y(u) & π_{~(X ∪ Y)}(v) = π_{~(X ∪ Y)}(t)
        // Z ⊆ X
        => ∃v π_X(v) = π_X(u) & π_{Y ∪ Z}(v) = π_{Y ∪ Z}(u) & π_{~(X ∪ Y)}(v) = π_{~(X ∪ Y)}(t)
2.  transitive law of projection:
        Z(w) = Z(v), Y(v) = Y(u) => (Y ∩ Z)(w) = (Y ∩ Z)(u)
a.  assume X ∩ Y = ∅, X ∩ Z = ∅
    X ->> Y & X ->> Z
    // complement rule
    => X ->> ~(X ∪ Y) & X ->> ~(X ∪ Z)
    // part b
    => X ->> ~(X ∪ Y) ∩ ~(X ∪ Z)
    => X ->> (~X ∩ ~Y) ∩ (~X ∩ ~Z)
    => X ->> ~X ∩ (~Y ∩ ~Z)
    => X ->> ~X ∩ ~(Y ∪ Z)
    => X ->> ~(X ∪ Y ∪ Z)
    // complement rule
    => X ->> Y ∪ Z
    can be similarly generated to Y, Z not disjoint to X
b.  assume X ∩ Y = ∅, X ∩ Z = ∅
    ∀u,t X(u) = X(t)
    // apply X ->> Y on u, t
    => ∃v X(v) = X(u) & Y(v) = Y(u) & ~(X ∪ Y)(v) = ~(X ∪ Y)(t)
    // apply X ->> Z on v, t
    => ∃w X(w) = X(v) & Z(w) = Z(v) & ~(X ∪ Z)(w) = ~(X ∪ Z)(t)
        ~(X ∪ Z) ∩ Y
        = (~X ∩ ~Z) ∩ Y
        = ~X ∩ (~Z ∩ Y)
        = ~X ∩ (Y - Z)
        // X and Y disjoint
        = Y - Z, and (Y - Z) ∪ (Y ∩ Z) = Y, ~Y(w) = ~Y(t), hence
    // rule 2
    => ∃w X(w) = X(u) & (Y ∩ Z)(w) = (Y ∩ Z)(u) & ~(X ∪ (Y ∩ Z))(w) = ~(X ∪ (Y ∩ Z))(t)
    for X ∩ Y, X ∩ Z != ∅,
        X ->> Y & X ->> Z
        // part d
        => X ->> Y - X & x ->> Z - X
        => X ->> (Y - X) ∩ (Z - X)
        => X ->> (Y ∩ Z) - X
        // rule 1
        => X ->> Y ∪ Z
c.  X ->> Y & X ->> Z
    // complement rule
    => X ->> Y & X ->> ~(X ∪ Z)
    // part a
    => X ->> Y ∩ ~(X ∪ Z)
    => X ->> Y ∩ ~X ∩ ~Z
    => X ->> (Y - Z) - X
    // rule 1
    => X ->> Y - Z
d.  ∀u,t π_X(u) = π_X(t)
    // X ->> Y
    => ∃v π_X(v) = π_X(u) & π_Y(v) = π_Y(u) & π_{~(X ∪ Y)}(v) = π_{~(X ∪ Y)}(t)
    // Y - X ⊆ Y, X ∪ (Y - X) = X ∪ Y
    => ∃v π_X(v) = π_X(u) & π_{Y - X}(v) = π_{Y - X}(u) & π_{~(X ∪ (Y - X))}(v) = π_{~(X ∪ (Y - X))}(t)

3.7.5
a.  R(A, B, C), A ->> B, C trivial, A ->> B may not be true
    A   B   C
    0   0   1
    0   1   0
b.  exercise 3.7.1, part c and d
c.  R(A, B, C), A, B ->> C trivial, A ->> C may not be true
    A   B   C
    0   0   1
    0   1   0

4.1.1
./database/model

4.1.2
./database/model
d.  assume FD address -> phone

4.1.3
./database/model

4.1.4
./database/model
b.  pseudo FDs:
        Captainship -> Team
        Captainship -> Player
c.  no

4.1.5
./database/model
a relation with attributes

4.1.6
./database/model

4.1.7
./database/model
ISA is a many-one relationship in tree model

4.1.8
./database/model

4.1.9
./database/model

4.1.10
./database/model

4.2.1
./database/model
redundancy
AcctSets and its attribute owner-address entity does not capture any new information
there can be a many-many relation between Customers and Accounts
owner-addresses can be derived from the new relation between Customers and Accounts and Lives-at

4.2.2
1.  there's no other relationship into President
2.  there's no *-many relationship out from President
3.  there's no FDs between attributes of Presidents

4.2.3
./database/model
studio_name becomes an attribute of Contracts

4.2.4
a.  name, birth date, gender, career length
b.  name, length, genre, is_sequel
c.  relation (Contracts, Studios) is many-many
    Studios cannot be replaced by an attribute without introducing abnormality

4.2.5
./database/model
the event / relation Birth is absorbed by the entity Babies
b.  implied by a
c.  from part a there's an FD from Babies to Mothers
    a binary many-one relation (Babies, Doctors) would suffice

4.2.6
./database/model

4.2.7
./database/model
4.2.5:  unchanged
4.2.6:  now (Births, Babies) is a one-many relation
        the unique mother can be inferred from the FD chain Babies -> Births -> Mothers 

4.3.1
./database/model
a.  Own is RI (Account -> Customer)
b.  no RI
    a fan may have no favorite color, player or team   
    a team may not have a captain
    a player can have no team
c.  key of People should be their entire family tree?
    Mother-of is RI
    Father-of is RI

4.3.2
assume K1, K2 are distinct, by nature or properly prefixed by the entity name
a.  K1 ∪ K2
b.  K1, for two tuples (e1, e2) and (f1, f2), e1 = f1 implies e2 = f2 by many-one relation
    hence (e1, e2) != (f1, f2) implies e1 != f1
c.  K2
d.  min{K1, K2}

4.3.3
let F be the set of entity sets where for all E ∈ F, R -- E has no arrow
F uniquely determines (E1, .., En), ∪ {Ki | Ei ∈ F} is a smallest possible key
if F is empty, any Ei determines (E1, .., En), min{K1, .., Kn} is a smallest possible key

4.4.1
./database/model
score is not a key, (Student.id, Course.id) uniquely identifies an enrollment entity

4.4.2
assignment has attributes { id, score } where id is unique among a single enrollment
key of assignment is { id, Student.id, Course.id }

4.4.3
./database/model
Births -> Babies is RI, two possible cases
1.  Babies is not weak entity set, key of Births is key of Babies
2.  Babies is weak entity set, key of Births and Babies contains keys from Mothers or Doctors
the graph in ./database/model is of case 1

4.4.4
./database/model

// the first tuple inside attributes list is the primary key
4.5.1
Customers((SSNo, name), addr, phone)
Flights((number, day), aircraft)
Bookings((customer_SSNo, flight_number, flight_day), row, seat)

4.5.2
a.  ./database/model
b.  a.  Customers((SSNo, name), addr, phone)
        Flights((number, day), aircraft)
        Bookings((flight_number, flight_day, row, seat))
        toCust((flight_number, flight_day, row, seat, customer_SSNo))
    b.  toCust is a superset of Bookings, if combined the two database schemas are the same 

4.5.3
Ships((name), yearLaunched)
Sister-of((the_ship_name, the_sister_name))

4.5.4
a.  Student((id))
    Course((id))
    Enrollment((student_id, course_id), score)
b.  Department((name))
    Course((number, department_name))
c.  Leagues((name))
    Teams((team_name, league_name))
    Players((player_number, team_name, league_name))

4.6.1
a.  Depts((name), chair)
    Courses((course_number, dept_name), room)
    LabCourses((course_number, dept_name), computer_allocation)
b.  Depts((name), chair)
    Courses((course_number, dept_name), room)
    LabCourses((course_number, dept_name), room, computer_allocation)
c.  Depts((name), chair)
    Courses((course_number, dept_name), room, computer_allocation)

4.6.2
a.  Person((name, address))
    Child((name, address))
    Father((name, address))
    Mother((name, address))
    MotherOf((mother_name, mother_address, child_name, child_address))
    FatherOf((father_name, father_address, child_name, child_address))
    ChildOf((child_name, child_address, parent_name, parent_address))
    Married((spouse_1_name, spouse_1_address, spouse_2_name, spouse_2_address))
b.  // the same as part a, subclasses has no additional attributes 
c.  Person((name, address)) 
    MotherOf((mother_name, mother_address, child_name, child_address))
    FatherOf((father_name, father_address, child_name, child_address))
    ChildOf((child_name, child_address, parent_name, parent_address))
    Married((spouse_1_name, spouse_1_address, spouse_2_name, spouse_2_address))

4.6.3
// skipped, basically the same to 4.6.2

4.6.4

a.  i.  both min and max = e
    ii. min: a, a base component
        max: ea, a component in every subclass
b.  i.  min: e, the hierarchy is a linked list 
        max: 2^e, all subclasses are directly a child of base class
    ii. min: a, a base component
        max: ea, a component in every subclass
c.  i.  both min and max = 1
    ii. both min and max = ea

4.7.1
./database/model

4.7.2
./database/model

4.7.3
./database/model

4.7.4
./database/model

4.7.5
./database/model
{ male, female } is not complete nor disjoint
{ father } { mother } is not complete among their base classes

4.7.6
./database/model

4.7.7
./database/model

4.7.8
a new class Contract, with
    (0..*, 1..1) multiplicity to Stars
    (0..*, 1..1) multiplicity to Movies
    (0..*, 1..1) multiplicity to Studios

4.7.9
./database/model

4.7.10
person -> biological parents, always 2..2 before clone technology
chess tornament -> players, 2..* 
audio output -> stereo speakers, 2..*

4.8.1
Customers((SSNo), name, addr, phone)
Flights((number, day), aircraft)
Bookings((customer_SSNo, flight_number), row, seat)

4.8.2
a.  Movies((title, year), length, genre)
    Studios((name), address)
    Presidents((cert#), name, address)
    Owns((title, studio_name))
    Runs((cert#, studio_name))
b.  Movies((title, year), length, genre)
    MoviesM((title, year), length, genre, weapon)
    MoviesC((title, year), length, genre)
    MoviesCM((title, year), length, genre, weapon)
c.  // same to ER model
d.  // same to ER model
e.  // same to ER model
f.  // same to ER model

4.8.3
a.  3^2 = 9
b.  3^0 + 3^1 + 3^2 = 13
c.  (2^3)^3 = 512
    // state at tree root = Π state at each subtree

4.9.1
class Customer (key (ssn)) {
    attribute integer ssn;
    attribute string name;
    attribute string address;
    attribute integer phone;
    relationship Set<Account> owns inverse Account::ownedBy;
};
class Account (key (number)) {
    attribute integer number;
    // in cents
    attribute integer balance; 
    // what is a type exactly?
    attribute enum Type { type } type;
    relationship Set<Customer> ownedBy inverse Customer::owns;
};

4.9.2
a.  in class Account:
        - relationship Set<Customer> ownedBy inverse Customer::owns;
        + relationship Customer ownedBy inverse Customer::owns;
b.  in class Customer:
        - relationship Set<Account> owns inverse Account::ownedBy;
        + relationship Account owns inverse Account::ownedBy;
c.  in class Customer: 
        - attribute string address;
        + attribute Set<string> addresses;
        - attribute integer phone;
        + attribute Set<integer> phones;
d.  class Address (key (address)) {
        attribute string address; 
        attribute Set<integer> phones;
    }
    in class Customer:
        - attribute Set<string> addresses;
        + relationship Set<Address> addresses;
        - attribute Set<integer> phones;

4.9.3
class Team (key (name)) {
    attribute string name;
    // attributes in ODL can be sets of primitive types
    // colors can be an attribute instead of a class
    attribute Set<string> uniformColors;
    relationship Set<Player> players inverse Player::team;
    relationship Player captain inverse Player::captainOf;
};
class Player (key (name)) {
    attribute string name;
    relationship Team team inverse Team::players; 
    relationship Team captionOf inverse Team::captain;
};
class Fan (key (name)) {
    // these relations are not mutual: they hold no significance on the other end
    attribute Team favTeam;
    attribute Player favPlayer;
    attribute string favColor;
};

4.9.4
class Person {
    attribute string name;
    relationship Set<Person> parents inverse Person::children;
    relationship Set<Person> children inverse Person::parents;
    // inverse of these two are subsets of children, but not exactly children
    relationship Person mother;
    relationship Person father;
};

4.9.5
class Degree {
    attribute string name;
    attribute string school;
    attribute string date;
};
Set:    order lost
        cannot express dual degree
Bag:    order lost
List:   
Array:  not sensible, people have variable lengths of education
order of education is significant, uniqueness is less so

4.9.6
a.  // there's no way to translate RI to ODL?
    class Department (key (name)) {
        attribute string name;
        relationship Set<Course> courses inverse Course::department;
    };
    class Course (key (number, department)) {
        attribute integer number;
        relationship Department department inverse Department::courses;
    };
b.  // recursion leads to O(n^2) relationships
    class League (key (name)) {
        attribute string name;
        relationship Set<Team> teams inverse Team::league;
        relationship Set<Player> players inverse Player::league;
    };
    class Team (key (name, league)) {
        attribute string name;
        relationship League league inverse League::teams;
        relationship Set<Player> players inverse Player::team;
    };
    class Player (key (name, team, league)) {
        attribute string name;
        relationship League league inverse League::players;
        relationship Team team inverse Team::players;
    };

4.9.7
class Department (key (name)) {
    attribute string name;
    relationship Set<Course> courses inverse Course::offedBy;
    relationship Set<Professor> members inverse Professor::memberOf;
};
class Professor (key (name)) {
    attribute string name;
    relationship Department memberOf inverse Department::members;
    relationship Set<Course> teaches inverse Course::taughtBy;
    relationship Set<Student> tutorOf inverse Student::tutor;
};
class Course (key (name, year)) {
    attribute string name;
    attribute integer year;
    attribute boolean is_remote;
    relationship Department offedBy inverse Department::courses;
    relationship Professor taughtBy inverse Professor::teaches;
    // integer here is the score
    relationship Dictionary<Student, integer> students inverse Student::enrolledIn;
    relationship Set<TA> ta inverse TA::assists;
};
class Student (key (name, enrolledYear)) {
    attribute string name; 
    attribute integer enrolledYear;
    relationship Professor tutor inverse Professor::tutorOf;
    // integer here is the score
    relationship Dictionary<Course, integer> enrolledIn inverse Course::students;
};
class TA extends Student {
    relationship Set<Course> assists inverse Course::ta;
};

4.9.8
OneOne symmetric self relation, e.g. spouse between people

4.10.1
a.  // same to ER model
b.  // same to ER model
c.  // same to ER model
d.  // same to ER model, People may contain an artificial key people# 
e.  Set:    Education((name, school, date))
    Bag:    Education((name, school, date), count)
    List:   Education((name, school, date, index))
    Array:  Education((name0, school0, date0 ... nameN, schoolN, dateN))
    Education-of((name, ...key of Degree))

4.10.2
for an attribute Dictionary<K, V> dict in a ODL class with (key (A))
    create a relation for the dictionary
        Dict((K), V)
    create another relation to connect the dictionary with the class
        Contains((A, K))

4.10.3
a.  Struct Card { rank enum Rank { 2, .., Ace }, suit enum Suit { Clubs, .., Spades }};
b.  class Hand {
        attribute Bag<Card> theHand;
    };
c.  Hand((hand#), rank, suit, count)
    // queried by selecting all Hand with the same hand# then aggregate
d.  class PokerHand {
        attribute Array<Card, 5> theHand;
    }
    PokerHand((hand#), rank0, suit0, .., rank4, suit4)
    // queried by a single selection
e.  Struct NamedHand {
        name string,
        hand Hand
    } 
    Struct Pair {
        first NamedHand,
        second NamedHand
    }
    class Deal {
        attribute Set<Pair> theDeal;
    }
f.  Struct NamedHand {
        name string,
        hand PokerHand
    }.  
g.  attribute Dictionary<string, Hand> theDeal;
h.  // include relations from part c
    deal((deal#), first_name, first_hand#, second_name, second_hand#)
i.  1.  A deal may contain identical hands
    2.  A hand may contain identical cards 
    a possible fix is to define theDeal as Bag<Bag<Card>>:
        Deal((deal#), hand#)
        Hand((hand#), card, count)

4.10.4
a.  C((a), f, g)
b.  C((a), f, g, count)
c.  C((a), f, g, index)
d.  // C((a), f, g, i, j) has BNF violation f, g -> i, j
    C((a), f, g)
    D((f, g), i, j)

5.1.1
./database/query
bag:
speed
-----
1.42
1.86
2.00
2.10
2.20
2.20
2.66
2.80
2.80
2.80
3.06
3.20
3.20
avg of bag: 2.48
set:
speed
-----
1.42
1.86
2.00
2.10
2.20
2.66
2.80
3.06
3.20
avg of set: 2.36

5.1.2
./database/query
bag:
hd
---
80
80
160
160
200
250
250
250
250
250
250
300
320
avg of bag: 215.38
set:
hd
---
80
160
200
250
300
320
avg of set: 218.33

5.1.3
./database/query
a.  bag:
    bore
    ----
    14
    14
    15
    15
    15
    16
    16
    18
    set:
    bore
    ----
    14
    15
    16
    18
b.  π_bore(Classes ⨝ Ships)

5.1.4
a.  assume tuple p appears r, s, t times in R, S and T
    p appears (r + s) + t times in (R ∪ S) ∪ T
    p appears r + (s + t) times in R ∪ (S ∪ T)
a.  assume tuple p appears r, s, t times in R, S and T
    p appears min(min(r, s), t) times in (R ∪ S) ∪ T
    p appears min(r, min(s, t)) times in R ∪ (S ∪ T)
c.  product is associative:
        assume r, s, t appear (rn, sn, tn) times in R, S, T
        (r, s, t) appears (rn * sn) * tn times in (R x S) x T
        (r, s, t) appears rn * (sn * tn) times in R x (S x T)
    and natural join is select and projection applied after product
d.  + is commutative
e.  min is commutative
f.  product is commutative:
        let s, r appear (sn, tn) times in R, S
        (s, r) appears sn * rn times in R x S
        (r, s) appears rn * sn times in S x R
        (s, r) = (r, s), columns are unordered
    and natural join is select and projection applied after product
g.  assume l appears rn, sn times in π_L(R) and π_L(S)
    l appears rn + sn times in π_L(R) ∪ π_L(S)
    there are rn, sn tuples in R, S, where L(r) = L(s) = l
    there are rn + sn tuples in R ∪ S where L(t) = l
    l appears rn + sn times in π_L(R ∪ S)
h.  assume p appears (rn, sn, tn) times in R, S, T
    p appears rn + min(sn, tn) times in R ∪ (S ∩ T)
    p appears min(rn + sn, rn + tn) times in (R ∪ S) ∩ (R ∪ T)
    min(rn + sn, rn + tn) = rn + min(sn, tn)
i.  assume a tuple p satisfying C and D appears r times in R
        p appears min(r, r) = r times in σ_C(R) ∩ σ_D(R)
        p appears r times in σ_{C & D}(R)
    if some p doesn't satisfy C or D,
        p doesn't appear in σ_C(R) or σ_C(R), min(r, 0) = 0
        p doesn't appear in σ_{C & D}(R)
    
5.1.5
define a - b as a & ~b:
    a   b   a - b
    0   0   0
    0   1   0
    1   0   1
    1   1   0
a.  (r & s) - t = r & (s - t) is tautology
    assume p appears 1, 2, 1 times in R, S, T
    p appears min(1, 2) - 1 = 0 times in (R ∩ S) - T
    p appears min(1, 2 - 1) = 1 times in R ∩ (S - T)
b.  r & (s | t) = (r & s) | (r & t) is tautology
    assume p appears 1, 1, 1 times in R, S, T
    p appears min(1, 1 + 1) = 1 times in R ∩ (S ∪ T)
    p appears min(1, 1) + min(1, 1) = 2 times in (R ∩ S) ∪ (R ∩ T)
c.  if p ∈ σ_{C | D}(R), C(p) | D(p), C ∈ σ_C(R) | C ∈ σ_D(R), C ∈ σ_C(R) ∪ σ_D(R)
    assume p satisfies C and D, p appears once in R
    p appears once in σ_{C | D}(R)
    p appears 1 + 1 = 2 times in σ_C(R) ∪ σ_D(R)

5.2.1
./database/query_sqlite
a.  SELECT A + B, A * A, B * B FROM R;
    [1, 0, 1]
    [5, 4, 9]
    [1, 0, 1]
    [6, 4, 16]
    [7, 9, 16]
b.  SELECT B + 1, C - 1 FROM S;
    [1, 0]
    [3, 3]
    [3, 4]
    [4, 3]
    [1, 1]
    [4, 3]
c.  SELECT * FROM R ORDER BY B, A;
    [0, 1]
    [0, 1]
    [2, 3]
    [2, 4]
    [3, 4]
d.  SELECT * FROM S ORDER BY B, C;
    [0, 1]
    [0, 2]
    [2, 4]
    [2, 5]
    [3, 4]
    [3, 4]
e.  SELECT DISTINCT * FROM R;
    [0, 1]
    [2, 3]
    [2, 4]
    [3, 4]
f.  SELECT DISTINCT * FROM S;
    [0, 1]
    [2, 4]
    [2, 5]
    [3, 4]
    [0, 2]
g.  SELECT A, SUM(B) FROM R GROUP BY A;
    [0, 2]
    [2, 7]
    [3, 4]
    [0, 1.5]
    [2, 4.5]
    [3, 4]
h.  SELECT A FROM R GROUP BY A
    [0]
    [2]
    [3]
i.  SELECT A, MAX(C) FROM (R INNER JOIN S ON R.B = S.B) GROUP BY A;
    [2, 4]
j.  SELECT A, R.B, C FROM (R LEFT OUTER JOIN S ON R.B = S.B);
    [0, 1, Null]
    [2, 3, 4]
    [2, 3, 4]
    [0, 1, Null]
    [2, 4, Null]
    [3, 4, Null]
k.  SELECT A, S.B, C FROM (S LEFT OUTER JOIN R ON R.B = S.B);
    [Null, 0, 1]
    [Null, 2, 4]
    [Null, 2, 5]
    [2, 3, 4]
    [Null, 0, 2]
    [2, 3, 4]
l.  SELECT A, R.B, C FROM (R LEFT OUTER JOIN S ON R.B = S.B)
    UNION ALL
    SELECT A, S.B, C FROM (S LEFT OUTER JOIN R ON R.B = S.B) WHERE A IS NULL;
    [0, 1, Null]
    [2, 3, 4]
    [2, 3, 4]
    [0, 1, Null]
    [2, 4, Null]
    [3, 4, Null]
    [Null, 0, 1]
    [Null, 2, 4]
    [Null, 2, 5]
    [Null, 0, 2]
m.  SELECT A, R.B, S.B, C FROM (R LEFT OUTER JOIN S ON R.B < S.B)
    UNION ALL
    SELECT A, R.B, S.B, C FROM (S LEFT OUTER JOIN R ON R.B < S.B) WHERE A IS NULL;
    [0, 1, 2, 4]
    [0, 1, 2, 5]
    [0, 1, 3, 4]
    [0, 1, 3, 4]
    [2, 3, Null, Null]
    [0, 1, 2, 4]
    [0, 1, 2, 5]
    [0, 1, 3, 4]
    [0, 1, 3, 4]
    [2, 4, Null, Null]
    [3, 4, Null, Null]
    [Null, Null, 0, 1]
    [Null, Null, 0, 2]
    
5.2.2
a.  idempotent, set is set
b.  idempotent, no more columns are removed after the first application
c.  idempotent, after the first application all tuples satisfies C
d.  not idempotent
    let R(A, B) = { (1, 2) }
    γ_{A, -SUM(B) -> B}(R) = { (1, -2) } = S
    γ_{A, -SUM(B) -> B}(S) = { (1, 2) } = R
e.  idempotent, sorted list is sorted

5.2.3
set semantic:
    S := R
    π_A(R) ⨝_{R.A = S.A} π_A(S)
bag semantic:
    not sure

5.3.1
S(y) <- R(x) & ~R(x) & x < y
S will always be empty even though it's not mentioned in any non-negate relation predicate

5.4.1
a.  A(a, b, c) <- R(a, b, c) 
    A(a, b, c) <- S(a, b, c)
b.  A(a, b, c) <- R(a, b, c) & S(a, b, c)
c.  A(a, b, c) <- R(a, b, c) & ~S(a, b, c)
d.  A(a, b, c) <- R(a, b, c) & ~T(a, b, c)
    A(a, b, c) <- S(a, b, c) & ~T(a, b, c)
e.  A(a, b, c) <- R(a, b, c) & ~S(a, b, c) & ~T(a, b, c)
f.  A(a, b) <- R(a, b, _)
g.  A(a, b) <- R(a, b, _) & S(_, a, b)

5.4.2
a.  A(x, x, z) <- R(x, x, z)
b.  A(x, y, z) <- R(x, y, z) & x < y & y < z
c.  A(x, y, z) <- R(x, y, z) & x < y
    A(x, y, z) <- R(x, y, z) & y < z
d.  same to part a
e.  A(x, y, z) <- R(x, y, z) & y >= z
    A(x, y, z) <- R(x, y, z) & x = y
f.  A(x, y, z) <- R(x, y, z) & y >= z
    A(x, y, z) <- R(x, y, z) & x >= y & x >= z

5.4.3
a.  A(a, b, c, d) <- R(a, b, c) & S(b, c, d)
b.  A(b, c, d, e) <- S(b, c, d) & T(d, e)
c.  A(a, b, c, d, e) <- R(a, b, c) & S(b, c, d) & T(d, e)

5.4.4
a.  A(a, b, c, x, y, z) <- R(a, b, c) & S(x, y, z) & a = y
// skipped, nothing new 

5.4.5
a.  π_{x, y}(Q ⨝ R)
b.  R(z, y) := Q(x, z)
    π_{x, y}(Q ⨝ R)
c.  σ_{x < y}(π_{x, y}(Q ⨝ R))

6.1.1
B is an alias, A and B are not delimited by a comma

6.1.2
a.  SELECT address
    FROM Studio
    WHERE name = 'MGM';
b.  SELECT birthdate
    FROM MovieStar
    WHERE name = 'Sandra Bullock';
c.  SELECT starName
    FROM StarsIn
    WHERE movieYear = 1980 OR movieTitle LIKE '%love%';
d.  SELECT name
    FROM MovieExec
    WHERE netWorth >= 10_000_000;
e.  SELECT name
    FROM MovieStar
    WHERE gender = 'Male' OR address LIKE '%Malibu%';

6.1.3
a.  (10, 20), (10, NULL), (NULL, 20)
b.  (10, 20)
c.  { (a, b)| (a, b) ∈ R, NOT a IS NULL }
d.  { (a, b)| (a, b) ∈ R, NOT a IS NULL & NOT b IS NULL & a = b }
d.  { (a, b)| (a, b) ∈ R, NOT a IS NULL & NOT b IS NULL & a <= b }

6.1.4
SELECT * 
FROM Movies 
WHERE NOT (length IS NULL)

6.2.1
a.  SELECT name
    FROM StarsIn, StarsIn
    WHERE gender = 'Male' AND movieTitle = 'movieTitle' AND starName = name
b.  SELECT name
    FROM Movies, StarsIn
    WHERE title = movieTitle AND studioName = 'MGM' AND year = 1995
c.  SELECT MovieExec.name
    FROM Studio, MovieExec
    WHERE cert# = presC# AND Studio.name = 'MGM'
d.  SELECT M1.name
    FROM Movies AS M0, Movies AS M1
    WHERE M0.name = 'Gone With the Wind' AND M0.lengh < M1.length
e.  SELECT E1.name
    FROM MovieExec AS E0, MovieExec AS E1
    WHERE M0.name = 'Merv Griffin' AND M0.netWorth < M1.netWorth

6.2.2
SELECT L
FROM R1, R2, .., Rn 
WHERE C

6.2.3
WHERE:
    C AND overlapping attributes must equal 
SELECT:
    any ambiguous attribute in L can be chosen from any possible relation

6.3.1
SELECT Old.title
FROM Movie AS Old, Movie AS New
WHERE Old.title = New.title AND Old.year < New.year

6.3.2
SELECT R1
FROM (R1 NATRUAL JOIN R2 .. NATURAL JOIN Rn)

6.3.3
a.  SELECT name, address
    FROM MovieStar
    WHERE gender = 'F' AND (name, address) IN 
        (
            SELECT name, address
            FROM MovieExec
            WHERE netWorth > 10_000_000
        )
b.  SELECT name address
    FROM MovieStar
    WHERE (name, address) NOT IN
        (
            SELECT name, address
            FROM MovieExec
        )

6.3.4
0 IN (SELECT 0 FROM R)

6.3.5
a.  Cartesian product of Studio and MovieExec
b.  // no overlapping attributes
    ρ_{A(movieTitle, movieStar, starName, NULL, NULL, NULL)}(StarsIn) ∪
    ρ_{A(NULL, NULL, NULL, name, address, birthdate)}(StarsIn)
c.  theta outer join of StarsIn and MovieStar on name = starName

6.3.6
// assume product types are disjoint: no PC can be Laptop etc.
// assume model is distinct
(Product NATURAL RIGHT OUTER JOIN PC) // PC with type and makers if available
FULL NATRUAL OUTER JOIN
(Product NATURAL RIGHT OUTER JOIN Laptop)
FULL NATURAL OUTER JOIN
(Product NATURAL RIGHT OUTER JOIN Printer)
FULL NATURAL OUTER JOIN 
Product // in case any product is neither PC, Laptop nor Printer

6.3.7
CLASS NATURAL RIGHT OUTER JOIN Ships

6.3.8
(CLASS NATURAL RIGHT OUTER JOIN Ships)
UNION
(
    SELECT (class, type country, numGuns, bore, displacement, class AS name, NULL)
    FROM Classes
    WHERE class NOT IN
        (
            SELECT class
            FROM Ships
        )
)

6.3.9
let r, s be all attributes of R and S
a.  SELECT r, s
    FROM R, S
b.  SELECT r ∪ s
    FROM R, S
    WHERE R.a = S.a for all a ∈ r ∩ s
c.  SELECT r, s
    FROM R, S
    WHERE C

6.4.1
the subquery
(
    SELECT producerC#
    FROM Movies, StarsIn
    WHERE title = movieTitle AND
        year = movieYear AND
        starName = 'Harrison Ford'
) AS Prod
produces duplication if Harrison Ford starred in multiple movies by the same producer

6.4.2
for a query
    SELECT S
    FROM R
    HAVING H
    GROUP BY G
π_S(σ_{H = true}(γ_{G, S, H}(R)))

BEGIN_TRANSACTION:
    "begin transaction"

SET_TRANSACTION_LEVEL:
    "set transaction" ("read" "write"?)? ("isolation level" ISOLATION_LEVEL)?

ISOLATION_LEVEL:
    "read uncommitted"
    | "read committed"
    | "repeatable read"
    | "serializable"

6.6.1
// SQLite doesn't have a variety of isolation levels, all transactions are SERIALIZABLE
// READ and WRITE mode in SQLite is auto deducted from the queries
a.  BEGIN TRANSACTION
    SET TRANSACTION READ ONLY 
        ISOLATION LEVEL READ COMMITTED
    ---
    SELECT model, price
    FROM PC
    WHERE speed = $speed AND ram = $ram
    ---
    COMMIT
b.  BEGIN TRANSACTION
    SET TRANSACTION READ WRITE
        ISOLATION LEVEL SERIALIZABLE
    ---
    DELETE FROM PC
    WHERE model = $model;
    ---
    DELETE FROM Product 
    WHERE model = $model;
    ---
    COMMIT
c.  // a single operation is always atomic
    UPDATE PC
    SET price = price - 100
    WHERE model = $model
d.  BEGIN TRANSACTION
    SET TRANSACTION READ WRITE
        ISOLATION LEVEL SERIALIZABLE 
    ---
    SELECT * 
    FROM Product
    WHERE model = $model
    --- if model exists
    ROLLBACK
    // print some error message in host language
    --- if model doesn't exist
    INSERT INTO Product(maker, model, type)
        VALUES($maker, $model, 'PC');
    ---
    INSERT INTO PC(model, speed, ram, hd, price)
        VALUES($model, $speed, $ram, $hd, $price)
    ---
    COMMIT

6.6.2
a.  read only, no unconsistency
b.  dangling tuples in PC or Product
c.  already atomic
d.  dangling tuples in PC or Product 

6.6.3
a.  the query may return uncommitted tuples
b.  intervenes with d, dangling tuples in Product or PC
c.  already atomic
d.  intervenes with b
    dangling tuples in Product or PC 
    or the insertion will not happen even deletion rolled back

6.6.4
a.  read only, no effect
b.  SERIALIZABLE:
        atomic
    REPEATABLE READ:
        the deletion will never be visible from T
    READ COMMITTED:
        atomic
    READ UNCOMMITTED:
        the deletion will be visible before COMMIT or ROLLBACK, inconsistency
c.  update is atomic
    the updated tuple may be included in the query result if the price is now below 1000
d.  SERIALIZABLE:
        atomic  
    REPEATABLE READ:
        insertion visible as phantom tuples after COMMIT
    READ COMMITTED:
        insertion visible as phantom tuples after COMMIT
    READ UNCOMMITTED:
        insertion visible before COMMIT or ROLLBACK, inconsistency

COLUMNS:
    COLUMN ("," COLUMN)*

FOREIGN_KEY:
    "foreign key" "(" COLUMNS ")" REFERENCES

REFERENCES:
    "references" TABLE "(" COLUMNS ")"
        ("on delete" MAINTAIN_POLICY)?
        ("on update" MAINTAIN_POLICY)?
        ("deferrable" DEFERRABLE_OPTION)?
    
MAINTAIN_POLICY:
    "default" 
    | "set null"
    | "cascade"

DEFERRABLE_OPTION:
    "initially deferred"
    "initially immediate"

COLUMN_DECLARATION:
    COLUMN TYPE "primary key"? REFERENCES?

7.1.1
a.  FOREIGN_KEY (producerC#) REFERENCES MovieExec(cert#)
b.  FOREIGN_KEY (producerC#) REFERENCES MovieExec(cert#)
        ON DELETE SET NULL
        ON UPDATE SET NULL
c.  FOREIGN_KEY (producerC#) REFERENCES MovieExec(cert#)
        ON DELETE CASCADE
        ON UPDATE CASCADE
d.  FOREIGN_KEY (movieTitle, movieYear) REFERENCES Movies(title, year)
e.  FOREIGN_KEY (starName) REFERENCES MovieStar(name)
        ON DELETE CASCADE
        ON UPDATE CASCADE

7.1.2
impossible
(movieTitle, movieYear) is not a key of the relation StarsIn

COLUMN_DECLARATION:
    COLUMN TYPE "primary key"? REFERENCES? ('non null' | CHECK)?

CHECK:
    "check" "(" CONDITION ")"

7.2.1
a.  CHECK (year >= 1915)
b.  CHECK (length >= 60 AND length <= 250)
c.  CHECK (studio IN ('Disney', 'Fox', "MGM', 'Paramount'))

7.2.2
a.  CHECK (speed >= 2.0)
b.  CHECK (type IN ('laser', 'ink-jet', 'bubble-jet')) 
c.  CHECK (type IN ('PC', 'laptop', 'printer'))
d.  CHECK (model IN 
        (SELECT model from PC)
        UNION
        (SELECT model from Laptop)
        UNION 
        (SELECT model from printer)
    )

7.2.3
// CHECK constraint may not involve subquery in SQLite
a.  // in StarsIn
    CHECK (
        (SELECT year(birthdate) from MovieStar WHERE name = starName)
        <= (SELECT year from Movies WHERE title = movieTitle)
    )
    // in Movies
    CHECK (NOT EXISTS (
        SELECT *
        FROM StarIn, MovieStar
        WHERE starName = name, movieTitle = title, year(birthdate) > year
    ))
    // in movieStar
    CHECK (year(birthdate) < ALL (
        SELECT year
        FROM Movies, StarsIn
        WHERE title = movieTitle, starName = name
    ))
b.  // in Studio
    CHECK (NOT EXISTS (
        SELECT *
        FROM Studio AS Other,
        WHRERE address = Other.address, name = Other.name
    ))
c.  // in MovieStar
    CHECK (name NOT IN (
        SELECT name
        FROM MovieExec
    ))
    // in MovieExec
    CHECK (name NOT IN (
        SELECT name
        FROM MovieStar
    ))
d.  // in Studio
    CHECK (name IN (
        SELECT studioName
        FROM Movies
    ))
    // in Movies
    // refers no attributes in the current relation
    CHECK (NOT EXISTS (
        SELECT *
        FROM Studio
        WHERE name NOT IN (SELECT studioName from Movies)
    ))
e.  // in Movies
    CHECK (producerC# = (
        SELECT presC#
        FROM Studio
        WHERE name = studioName
    ))
    // in Studio
    CHECK (presC# = ALL (
        SELECT producerC#
        FROM Movies
        WHERE studioName = name
    ))

7.2.4
a.  CHECK (NOT (speed < 2.0 AND price > 600))
b.  CHECK ((NOT screen < 15) OR (hd >= 40 OR price < 1000))

7.2.5
a.  // in Classes
    CHECK (bore <= 16)
b.  // in Classes
    CHECK ((NOT numGuns > 9) OR bore <= 14)
c.  // in Ships
    CHECK (launched <= ALL (
        SELECT date 
        FROM Battles, Outcomes
        WHRER Battles.name = Outcomes.battle, ship = Ships.name
    ))
    // in Battles 
    CHECK (date >= ALL (
        SELECT launched
        FROM Ships, Outcomes
        WHRER Battles.name = Outcomes.battle, ship = Ships.name
    ))
    // in Outcomes
    CHECK (ship IN (
        SELECT Ships.name
        FROM Ships, Battles
        WHERE Outcomes.battle = Battles.name, Ships.name = ship, date >= launched
    ))

7.2.6
// there's no UNKNOWN or boolean value in SQLite
// UNKNOWN is replaced by NULL, boolean TRUE = 1, boolean FALSE = 0
gender CHAR(1) CHECK (gender IN (’F’, ’M’))
    if gender is NULL, gender IN ('F', 'M') evaluates to UNKNOWN, the check fails
CHECK (gender = ’F’ OR name NOT LIKE ’Ms.%’)
    if gender is NULL, gender = 'F' evaluates to UNKNOWN
    the constraint is violated when name starts with 'Ms.'

CONSTRAINTS:
    UNIQUE
    | PRIMARY_KEY
    | TUPLE_CONSTRAINT
    | FOREIGN_KEY

UNIQUE:
    "unique" "(" COLUMNS ")"

PRIMARY_KEY:
    "primary key" "(" COLUMNS ")"

TUPLE_CONSTRAINT:
    ("constraint" IDENT)? CHECK

ALTER_TABLE:
    "alter table" TABLE ADD_CONSTRAINT

ADD_CONSTRAINT:
    "add" ("constraint" IDENT)? CONSTRAINTS

DROP_CONSTRAINT:
    "drop" "constraint" IDENT

// in SQLite, preexisting tuples are not checked when adding a new tuple constraint
// this may change in future versions
7.3.1
a.  ALTER TABLE Movie
        ADD PRIMARY KEY (title, year)
b.  ALTER TABLE Movie
        ADD FOREIGN KEY (producerC#) REFERENCES MovieExec(cert#)
c.  ALTER TABLE Movie
        ADD CONSTRAINT MIN_MAX_LEN CHECK (length >= 60 AND length <= 250)
d.  ALTER TABLE MovieStar
        ADD CONSTRAINT NOT_EXEC CHECK (name NOT IN (
            SELECT name
            FROM MovieExec
        ))
    ALTER STABLE MovieExec
        ADD CONSTRAINT NOT_STAR CHECK (name NOT IN (
            SELECT name
            FROM MovieStar
        ))
e.  ALTER TABLE Studio
        ADD UNIQUE (address)

7.3.2
a.  ALTER TABLE Classes
        ADD PRIMARY KEY (class, country)
b.  // there's no ship in Battles?
c.  ALTER TABLE Outcomes
        // (name) is not a key of Ships
        ADD CHECK (ship IN (
            SELECT name
            FROM Ships
        ))
d.  ALTER TABLE Classes
        ADD CHECK (numGuns <= 14)
e.  // same to 7.2.5

CREATE_ASSERTION:
    "create assertion" IDENT CHECK ("deferrable" DEFERRABLE_OPTION)?

7.4.1
a.  CREATE ASSERTION PC_and_laptop_maker_disjoint
        CHECK (NOT EXISTS (
            (SELECT maker FROM Product WHERE type = 'PC')
            INTERSECTION
            (SELECT maker FROM Product WHERE type = 'laptop')
        ))
b.  CREATE ASSERTION mobile_focus
        CHECK (NOT EXISTS (
            SELECT *
            FROM ((
                    SELECT maker, MAX(speed) AS pc_speed
                    FROM Product, PC
                    WHERE Product.model = PC.model
                    GROUP BY maker
                ) 
                NATURAL JOIN
                (
                    SELECT maker, MAX(speed) AS laptop_speed
                    FROM Product, Laptop
                    WHERE Product.model = Laptop.model
                    GROUP BY maker
                ))
            WHERE pc_speed > laptop_speed
        ))
c.  CREATE ASSERTION mobile_expansive
        CHECK (NOT EXISTS (
            SELECT *
            FROM PC, Laptop
            WHERE PC.ram = Laptop.ram AND PC.price <= Laptop.price
        ))
d.  CREATE ASSERTION integrity
        CHECK (NOT EXISTS (
            SELECT *
            FROM Product
            WHERE (
                (type = 'PC' AND model NOT IN SELECT model FROM PC) OR
                (type = 'laptop' AND model NOT IN SELECT model FROM Laptop) OR
                (type = 'printer' AND model NOT IN SELECT model FROM Printer)
            )
        ))

7.4.2
a.  CREATE ASSERTION disarmament
        CHECK (2 >= ALL (
            SELECT COUNT(*)
            FROM Classes, Ships
            WHERE Classes.class = Ships.class
        ))
b.  CREATE ASSERTION type_loyalty
        CHECK (NOT EXISTS (
            (SELECT country FROM Classes WHERE type = 'bb')
            INTERSECTION
            (SELECT country FROM Classes WHERE type = 'bc')
        ))
c.  CREATE ASSERTION no_weaponized_bully
        CHECK (9 >= ALL (
            SELECT MAX(numGuns)
            FROM Outcomes, Classes, Ships
            WHERE (
                Outcomes.ship = Ships.name AND 
                Ships.class = Classes.class AND
                battle IN (
                    SELECT battle
                    FROM Outcomes, Ships, Classes
                    WHERE (
                        Outcomes.ship = Ships.name AND
                        Classes.class = Ships.class AND
                        numGuns < 9 AND
                        result = 'sunk'
                    )
                )
            )
        ))
d.  CREATE ASSERTION navy_naming_custom
        CHECK (NOT EXISTS (
            SELECT *
            FROM Ships AS Later, Ships AS First
            WHERE 
                Later.name = First.class AND 
                Later.launched < First.launched
        ))
e.  CREATE ASSERTION navy_naming_custom_part_2
        CHECK (NOT EXISTS (
            SELECT *
            FROM Classes
            WHERE Classes.class NOT IN (SELECT name FROM Ships)
        ))

7.4.3
// not enforced on tuple deletion
// in MovieExec
CHECK (NOT EXISTS (
    (
        SELECT Studio.name
        FROM Studio, MovieExec
        WHERE presC# = cert# AND netWorth < 10000000
    )
))

CREATE_TRIGGER:
    "create trigger" IDENT
    TIMING EVENT
    // SQLite has no REFERENCING clause, OLD and NEW are still defined
    // in context of trigger actions, references the inserted / deleted / updated tuples
    "referencing"
        // insert: only new
        // delete: only old
        // update: both
        REFERRED ("," REFERRED)*
    // default is statement
    ("for each" ("row" | "statement"))? 
    ("when" "(" CONDITION ")")?
        (STMT | STMTS)

TIMING:
    "before" 
    | "after"

EVENT:
    "update" ("of" COLUMNS)? "on" TABLE 
    | "insert" "on" TABLE
    | "delete" "on" TABLE

REFERRED:
    ("old" | "new") ("row" | "table") ("of" COLUMN) "on" TABLE

STMTS:
    "begin"
    (STMT ";")*
    "end"

// hypothetic macros (not confirming to C preprocessor syntax):
#define REVERSE_UPDATE(table, key, old, new) ( \
BEGIN \
    DELETE FROM table \
    WHERE key IN (SELECT key FROM new); \
    INSERT INTO table old; \
END \
)

#define REVERSE_INSERT(table, key, new) ( \
    DELETE FROM table \
    WHERE (key) in (SELECT key FROM new) \
)

#define REVERSE_DELETE(table, old) ( \
    INSERT INTO table old \
)

#define REVERT_TABLE_ON_INSERTION(name, table, key, cond) \
CREATE TRIGGER name \
AFTER INSERT ON table \
REFERENCING \
    NEW TABLE AS New \
FOR EACH STATEMENT \
WHEN (cond) \
    REVERSE_INSERT(table, key, New);

#define REVERT_TABLE_ON_DELETION(name, table, cond) \
CREATE TRIGGER name \
AFTER INSERT ON table \
REFERENCING \
    OLD TABLE AS Old \
FOR EACH STATEMENT \
WHEN (cond) \
    REVERSE_DELETE(table, Old);

#define REVERT_TABLE_ON_UPDATE(name, table, columns, key, cond) \
CREATE TRIGGER name \
AFTER UPDATE Of column ON table \
REFERENCING \
    OLD TABLE AS Old \
    NEW TABLE AS New \
FOR EACH STATEMENT \
WHEN (cond) \
    REVERSE_UPDATE(table, key, Old, New);

#define REVERT_TABLE_ON(name, table, columns, key, cond)  \
REVERT_TABLE_ON_INSERTION(name ## _on_insertion, table, key, cond)
REVERT_TABLE_ON_DELETION(name ## _on_deletion, table, cond)
REVERT_TABLE_ON_UPDATE(name ## _on_update, table, columns, key, cond)

// Answers below are overwhelmingly messy because standard SQL 2003 doesn't support exceptions,
// without which most operations cannot be stopped beforehand, hence operations of different 
// consequences must be treated accordingly. A blanket solution BEFORE (INSERT / DELETE / UPDATE) 
// and abort on unsatisfied condition would suffice for most the exercises listed below.
7.5.1
REVERT_TABLE_ON_INSERTION(on_insert, MovieExec, cert#, 500000 > (SELECT AVG(netWorth) FROM MovieExec))
REVERT_TABLE_ON_DELETION(on_delete, MovieExec, 500000 > (SELECT AVG(netWorth) FROM MovieExec))

7.5.2
a.  CREATE TRIGGER pc_unattractive_offer
    AFTER UPDATE OF price ON PC
    REFERENCING
        OLD ROW AS Old,
        NEW ROW AS New
    FOR EACH ROW 
    WHEN (EXISTS (SELECT * FROM PC WHERE PC.price < New.price AND PC.speed = NEW.speed))
        UPDATE PC
        SET price = Old.price
        WHERE model = New.model
b.  CREATE TRIGGER printer_integrity
    AFTER INSERT ON Printer
    REFERENCING
        NEW ROW AS New
    FOR EACH ROW
    WHEN (New.model NOT IN (SELECT model FROM Product))
        DELETE FROM Printer
        WHERE model = New.model
c.  REVERT_TABLE_ON(laptop, Laptop, (price, model), model, 1500 > ANY (
        SELECT AVG(price)
        FROM Laptop, Product
        WHERE Laptop.model = Product.model
        GROUP BY maker
    ))
d.  CREATE TRIGGER enough_hd
    AFTER UPDATE OF ram, hd ON PC
    REFERENCING
        OLD ROW AS Old
        NEW ROW AS New
    FOR EACH ROW
    WHEN (New.hd < New.ram * 100)
        UPDATE PC
        SET hd = Old.hd, ram = Old.ram
        WHERE model = New.model
e.  #define UNSEEN(name, table) \
    CREATE TRIGGER name \
    AFTER INSERT ON table \
    REFERENCING \
        NEW ROW AS New \
    FOR EACH ROW \
    WHEN (New.model IN ( \
        (SELCT model FROM PC) \
        UNION \
        (SELECT model FROM Laptop) \
        UNION \
        (SELECT model FROM Printer) \
    )) \
        DELETE FROM table \
        WHERE model = New.model;
    UNSEEN(unseen_pc, PC)
    UNSEEN(unseen_laptop, Laptop)
    UNSEEN(unseen_printer, Printer)

7.5.3
a.  CREATE TRIGGER first_ship
    AFTER INSERT ON Classes
    REFERENCING
        NEW ROW AS New
    FOR EACH ROW
        INSERT INTO Ships(name, class, launched)
        VALUES (New.class, New.class, NULL)
b.  CREATE TRIGGER min_displacement
    AFTER INSERT ON Classes
    REFERENCING
        NEW ROW AS NewRow
        NEW TABLE AS NewTable
    FOR EACH ROW
    WHEN (35000 > NewRow.displacement)
        UPDATE NewTable
        SET displacement = 35000
        WHERE class = NewRow.class
c.  CREATE TRIGGER outcomes_ships_integrity
    AFTER INSERT ON Outcomes
    REFERENCING
        NEW ROW AS New
    FOR EACH ROW
    WHEN (New.ship NOT IN (SELECT name FROM Ships))
        INSERT INTO Ships(name, class, launched)
        VALUES (New.ship, NULL, NULL)
    CREATE TRIGGER outcomes_battles_integrity
    AFTER INSERT ON Outcomes
    REFERENCING
        NEW ROW AS New
    FOR EACH ROW
    WHEN (New.battle NOT IN (SELECT name FROM Battles))
        INSERT INTO Battles (name, date)
        VALUES (New.battle, NULL)
d.  REVERT_TABLE_ON_INSERTION(on_insertion, Ships, (name, class), 20 >= ALL (
        SELECT COUNT(*)
        FROM Classes, Ships
        WHERE Classes.name = Ships.class
        GROUP BY country
    ))
    REVERT_TABLE_ON_UPDATE(on_update, Ships, class, (name, class), 20 >= ALL (
        SELECT COUNT(*)
        FROM Classes, Ships
        WHERE Classes.name = Ships.class
        GROUP BY country
    ))
e.  #define BATTLE_AFTER_SUNK \
    NOT EXISTS ( \
        SELECT * \
        FROM (( \
                SELECT name, date as sunk_date \
                FROM Ships, Outcomes \
                WHERE Ships.name = Outcomes.ship AND result = 'sunk' \
            ) \
            NATURAL JOIN \
            ( \
                SELECT name, MAX(date) \
                FROM Ships, Outcomes \
                WHERE Ships.name = Outcomes.ship \
                GROUP BY Ships.name \
            )) \
        WHERE date > sunk_date \
    )
    REVERT_TABLE_ON(outcomes, Outcomes, (ship, battle, result), (ship, battle), BATTLE_AFTER_SUNK)
    REVERT_TABLE_ON(battles, Battles, (name, date), name, BATTLE_AFTER_SUNK)
    REVERT_TABLE_ON(ships, Ships, (name, launched), (name, class), BATTLE_AFTER_SUNK)

7.5.4
a.  #define STARSIN_INTEGRITY \
    NOT EXISTS ( \
        SELECT * \
        FROM StarsIn \
        WHERE starName NOT IN ( \
            SELECT name \
            FROM MovieStar \
        ) \
    )  
    REVERT_TABLE_ON_UPDATE(a, StarsIn, starName, (movieTitle, movieYear, starName), STARSIN_INTEGRITY)
    REVERT_TABLE_ON_INSERTION(b, StarsIn, (movieTitle, movieYear, starName), STARSIN_INTEGRITY)
    REVERT_TABLE_ON_DELETION(c, MovieStar, STARSIN_INTEGRITY)
    REVERT_TABLE_ON_UPDATE(d, MovieStar, name, name, STARSIN_INTEGRITY)
b.  #define EXEC_INTEGRITY \
    NOT EXISTS ( \
        SELECT * \
        FROM MovieExec \
        WHERE cert# NOT IN ( \
            (SELECT producerC# FROM Movies) \
            UNION \
            (SELECT presC# FROM Studio) \
        ) \
    )
    REVERT_TABLE_ON_INSERTION(exec_on_insertion, MovieExec, cert#, EXEC_INTEGRITY)
    REVERT_TABLE_ON_UPDATE(exec_on_update, MovieExec, cert#, cert#, EXEC_INTEGRITY)
    REVERT_TABLE_ON_DELETION(movies_on_deletion, Movies, EXEC_INTEGRITY)
    REVERT_TABLE_ON_DELETION(studio_on_deletion, Studio, EXEC_INTEGRITY)
    REVERT_TABLE_ON_UPDATE(movies_on_update, Movies, producerC#, (title, year), EXEC_INTEGRITY)
    REVERT_TABLE_ON_UPDATE(studio_on_update, Studio, presC#, name, EXEC_INTEGRITY)
c.  #define ONE_MALE_FEMALE \
    1 >= ALL ( \
        SELECT COUNT(*) \
        FROM Movies, StarsIn, MovieStar \
        WHERE title = movieTitle, year = movieYear, movieStar = name, gender = 'M' \
        GROUP BY title, year \
    ) AND 1 >= ALL ( \
        SELECT COUNT(*) \
        FROM Movies, StarsIn, MovieStar \
        WHERE title = movieTitle, year = movieYear, movieStar = name, gender = 'F' \
        GROUP BY title, year \
    )
    REVERT_TABLE_ON_UPDATE(
        starsin_on_deletion, 
        StarsIn, 
        ONE_MALE_FEMALE
    )
    REVERT_TABLE_ON_UPDATE(
        starsin_on_deletion, 
        StarsIn, 
        (movieTitle, movieYear),
        (movieTitle, movieYear, starName),
        ONE_MALE_FEMALE
    )
    REVERT_TABLE_ON_INSERTION(movie_on_insertion, Movies, (title, year), ONE_MALE_FEMALE)
    REVERT_TABLE_ON_UPDATE(movie_on_update, Movies, (title, year), (title, year), ONE_MALE_FEMALE)
    REVERT_TABLE_ON_DELETION(star_on_deletion, MovieStar, ONE_MALE_FEMALE)
    REVERT_TABLE_ON_UPDATE(star_on_deletion, (name, gender), name, ONE_MALE_FEMALE)
d.  #define MAX_PRODUCTION \
    100 >= ALL ( \
        SELECT COUNT(*) \
        FROM Movies \
        GROUP BY year, studioName \
    )
    REVERT_TABLE_ON_INSERT(movie_on_insert, Movies, (title, year), MAX_PRODUCTION)
    REVERT_TABLE_ON_UPDATE(movie_on_update, Movies, (year, studioName), (title, year), MAX_PRODUCTION)
e.  #define AVG_LENGTH \
    120 >= ALL ( \
        SELECT AVG(length) \
        FROM Movies \
        GROUP BY year \
    )
    REVERT_TABLE_ON(movies, Movies, (year, length), (title, year), AVG_LENGTH)

CREATE_VIEW:
    "create view" TABLE ( "(" COLUMNS ")" )? "as"
        SELECT_STMT

8.1.1
a.  CREATE VIEW RichExec AS
        SELECT *
        FROM MovieExec
        WHERE netWorth >= 10_000_000
b.  CREATE VIEW StudioPres AS
        SELECT MovieExec.name, MovieExec.address, cert#
        FROM MovieExec, Studio
        WHERE cert# = presC#
c.  CREATE VIEW ExecutiveStar AS
        SELECT MovieExec.name, MovieExec.address, gender, birthdate, cert#, netWorth
        FROM MovieStar, MovieExec
        // one may be registered with different addresses as star and exec
        WHERE MovieStar.name = MovieExec.name

8.1.2
a.  SELECT name
    FROM ExecutiveStar
    WHERE gender = 'F'
b.  SELECT name
    FROM (StudioPres NATURAL JOIN RichExec)
c.  SELECT name 
    FROM (StudioPres NATURAL JOIN ExecutiveStar)
    WHERE netWorth >= 50_000_000

8.2.1
RichExec, the other two select from multiple relations

8.2.2
a.  it's updatable, selects from a single relation, no subquery, no non-null columns omitted
b.  CREATE TRIGGER DisneyComediesInsert
    INSTEAD OF INSERT ON DisneyComedies
    REFERENCING
        NEW ROW AS New
    FOR EACH ROW
        INSERT INTO Movies(title, year, length, studioName, genre)
        VALUES (New.title, New.year, New.length, 'Disney', 'comedy')
c.  CREATE TRIGGER DisneyComediesUpdate
    INSTEAD OF UPDATE OF length ON DisneyComedies
    REFERENCING
        OLD ROW AS Old
        NEW ROW AS New
    FOR EACH ROW
        UPDATE Movies
        SET length = New.length
        WHERE title = Old.title, year = Old.year

8.2.3
a.  it should be, but it's not according to the conditions listed at the start of the section 
b.  CREATE TRIGGER NewPCInsert
    INSTEAD OF INSERT ON NewPC
    REFERENCING
        NEW ROW AS New
    FOR EACH ROW
    BEGIN
        INSERT INTO Product(maker, model, type)
        VALUES (New.maker, New.model, 'pc');
        INSERT INTO PC(model, speed, ram, hd, price)
        VALUES (New.model, New.speed, New.ram, New.hd, New.price);
    END
c.  CREATE TRIGGER NewPCUpdate
    INSTEAD OF UPDATE OF price ON NewPC
    REFERENCING
        OLD ROW AS Old
        NEW ROW AS New
    FOR EACH ROW
        UPDATE PC
        SET price = New.price
        WHERE model = Old.model
d.  CREATE TRIGGER NewPCDelete
    INSTEAD OF DELETE ON NewPC
    REFERENCING
        OLD ROW AS Old
    FOR EACH ROW
    BEGIN
        DELETE FROM Product
        WHERE model = Old.model;
        DELETE FROM PC
        WHERE model = Old.model;
    END

CREATE_INDEX:
    "create index" INDEX "on" TABLE "(" COLUMNS ")"

8.3.1
// indices share the namespace with tables and views, it must be unique across the entire schema
// (at least in PostgreSQL https://www.postgresql.org/docs/current/catalog-pg-class.html)
a.  CREATE INDEX MoviesStudioNameIndex ON Movies(studioName)
b.  CREATE INDEX MovieExecAddressIndex ON MovieExec(address)
c.  CREATE INDEX MoviesGenreLengthIndex ON Movies(genre, length)

8.4.1
no indices:
    2 + 98p1 + 98p2
Star index:
    4 + 96p2
Movie index:
    4 + 96p1
both indices:
    6 - 2p1 - 2p2

8.4.2
cost of SELECT * FROM Ships WHERE name = n, index on name:
    no index: 25 on avg, name is key, the database can stop once the answer is found
    w/ index: 1 (index) + 1 (name is unique) = 2
cost of SELECT * FROM Ships WHERE class = c, index on class:
    no index: 50
    w/ index: 1 (index) + 1 (ship is clustered on class) = 2
cost of SELECT * FROM Ships WHERE launched = y, index on launched:
    no index: 50
    // when the distribution is uniform, the probability a page won't be accessed 
    // is (49/50)^25 ~ 0.6, on avg. 50 * 0.6 = 30 pages won't be accessed
    w/ index: 1 (index) + 20 = 21
const of INSERT INTO Ships:
    no index: 1 (read) + 1 (write) = 2
    w/ index: 2 + 2 * indices
// combination and function skipped

8.5.1
// update of name in MovieExec
UPDATE MovieProd
SET name = New.name
WHERE cert# = Old.cert#
// update of cert# in MovieExec
// the new cert# must be distinct to any existing ones, cert# is key of MovieExec
UPDATE MovieProd
SET cert# = New.cert#
WHERE cert# = Old.cert#
// update of title or year in Movies
// new (title, year) must be distinct
UPDATE MovieProd
SET name = New.name, year = New.year
WHERE name = Old.name, year = Old.year

8.5.2
insertion, deletion and updates to Product and PC
// insertion into Product or PC
INSERT INTO NewPC (
    SELECT maker, model, speed, ram, hd, price
    FROM (NewTable NATURAL JOIN PC)
)
// deletion from Product or PC
DELETE FROM NewPC
WHERE model IN (SELECT model from Old)
// update similar to 8.5.1, skipped

8.5.3
insertion to / deletion from Ships or Classes
update of name, country, displacement on Classes
// insertion into Classes, new country
INSERT INTO ShipStats (
    SELECT New.country, New.displacement, COUNT(*)
    FROM Ships
    WHERE Ships.class = New.class
)
// insertion into Classes, existing country
UPDATE ShipStats
SET 
    // recalculated, otherwise vulnerable to rounding error
    avg = (
        SELECT AVG(displacement),
        FROM Classes, Ships
        WHERE Classes.name = class
        GROUP BY country
    ),
    count = count + (
        SELECT COUNT(*)
        FROM Ships
        WHERE class = New.name
    )
WHERE country = New.country
// insertion into Ships
UPDATE ShipStats
SET
    avg = (
        SELECT AVG(displacement),
        FROM Classes, Ships
        WHERE Classes.name = class
        GROUP BY country
    ),
    count = count + 1
WHERE country = (
    SELECT country 
    FROM Classes 
    WHERE name = New.class
)
// deletion from Classes, not last class of a country
UPDATE ShipStats
SET
    avg = (
        SELECT AVG(displacement),
        FROM Classes, Ships
        WHERE Classes.name = class
        GROUP BY country
    ),
    count = count - (
        SELECT COUNT(*) 
        FROM Ships
        WHERE class = Old.name
    )
WHERE country = Old.country
// deletion from Classes, last class of country
DELETE FROM ShipStats
WHERE country = Old.country
// deletion from Ships
UPDATE ShipStats
SET
    avg = (
        SELECT AVG(displacement),
        FROM Classes, Ships
        WHERE Classes.name = class
        GROUP BY country
    ),
    count = count - 1
WHERE country = (
    SELECT country 
    FROM Classes 
    WHERE name = Old.class
)
// update of displacement on Classes
UPDATE ShipStats
SET
    avg = (
        SELECT AVG(displacement),
        FROM Classes, Ships
        WHERE Classes.name = class
        GROUP BY country
    )
WHERE country = Old.country
// other update = deletion + insertion

5.5.4
query form:
    SELECT LQ
    FROM RQ
    WHERE CQ
LQ ∩ Movies ⊆ { title, year }
LQ ∩ MovieExec ⊆ { name }
{ Movies, MovieExec } ⊆ RQ
∃C, CQ = producerC# = cert# AND C
any columns of Movies or MovieExec mentioned in C is in { title, year, name }

// SQL is almost never directly embedded into the host language now, SQL preprocessor
// has always been a bad idea and nearly impossible in any language more complicated
// than C, most SQL vendors expose either a dynamic SQL server-client interface
// or a C CLI interface
8.3.1
./database/query_sqlite/

8.3.2
./database/query_sqlite/
format of Battles.date is not in the same format as Ships.launched 
Battles.date is not a date but a time span (e.g. 5/24-27/41)

CREATE_PROCEDURE:
    "create procedure" PROCEDURE_NAME "("
        (PARAM ("," PARAM)*)?
    ")"
    (DECLARATION ";")*
    PROCEDURE_STMT

PARAM:
    ("in" | "out" | "inout") IDENT TYPE

DECLARATION:
    "declare" VARIABLE_NAME TYPE

PROCEDURE_STMT:
    (LABEL ":")?
    ( RETURN // only in function
    | CALL_PROCEDURE
    | ASSIGNMENT
    | PROCEDURE_STMT_GROUP
    | IF_STMT
    | LOOP_STMT
    | LEAVE_STMT
    | FOR_STMT
    | WHILE_STMT
    | REPEAT_STMT )

RETURN:
    "return" EXPRESSION

CALL_PROCEDURE:
    "call" PROCEDURE_NAME "(" EXPRESSION ("," EXPRESSION)* ")"

ASSIGNMENT:
    "set" VARIABLE_NAME "=" EXPRESSION

PROCEDURE_STMT_GROUP:
    "begin" (PROCEDURE_STMT ";")* "end"

PROCEDURE_STMT_LIST:
    (PROCEDURE_STMT ";")*

IF_STMT:
    "if" CONDITION "then"
        PROCEDURE_STMT_LIST
    ("elseif" CONDITION "then" 
        PROCEDURE_STMT_LIST)*
    ("else" 
        PROCEDURE_STMT_LIST)?
    "end if"

LOOP_STMT:
    "loop"
        PROCEDURE_STMT_LIST
    "end loop"

LEAVE_STMT:
    "leave" LABEL

// columns are automatically declared as local variables
FOR_STMT:
    "for" LABEL "as" CURSOR_NAME "cursor for"
        SELECT_STMT
    "do"
        PROCEDURE_STMT_LIST
    "end for"

WHILE_STMT:
    "while" CONDITION "do"
        PROCEDURE_STMT_LIST
    "end while"

REPEAT_STMT:
    "repeat"
        PROCEDURE_STMT_LIST
    "until" CONDITION
    "end repeat"

CREATE_FUNCTION:
    "create function" PROCEDURE_NAME "("
        PARAM ("," PARAM)*
    ")" "returns" TYPE
    PROCEDURE_STMT

// block local exception handler
DECLARE_HANDLER:
    "declare" ON_LEAVING "handler for" EXCEPTION_CONDITION_LIST
        PROCEDURE_STMT

ON_LEAVING:
    "continue" | "exit" | "undo"

EXCEPTION_CONDITION_LIST:
    EXCEPTION_CONDITION ("," EXCEPTION_CONDITION)

EXCEPTION_CONDITION:
    NAMED_SQLSTATE
    | SQLSTATE

DECLARE_NAMED_SQLSTATE:
    "declare" NAMED_SQLSTATE "condition" "for" SQLSTATE

SQLSTATE:
    "sqlstate" "'" [0-9A-Z]{5} "'"

8.4.1
a.  CREATE FUNCTION WorthOfPres (
        studioName  VARCHAR(255)
    ) RETURNS INTEGER
    // set to NULL on declaration
    DECLARE presNewWorth INTEGER;
    BEGIN
        SELECT netWorth
        INTO presNewWorth
        FROM Studio, MovieExec
        WHERE name = studioName AND presC# = cert#;
        RETURN presNewWorth;
    END
b.  CREATE FUNCTION CategorizeExec (
        name        VARCHAR(255),
        address     VARCHAR(255),
    )
    DECLARE category INTEGER;
    BEGIN
        IF 
            (name, address) IN (SELECT name, address FROM MovieExec)
        THEN 
            SET category = category + 1;
        ENDIF;
        IF
            (name, address) IN (SELECT name, address FROM MovieStar)
        THEN
            SET category = category + 2;
        ENDIF;
        IF
            category = 0
        THEN
            SET category = 4;
        ENDIF;
        RETURN category;
    END
c.  CREATE PROCEDURE TwoLongestMovies (
        IN  studio      VARCHAR(255)
        OUT fstLongest  VARCHAR(255)
        OUT sndLongest  VARCHAR(255)
    )
    DECLARE index INTEGER; 
    BEGIN
        SET index = 0;
        FOR movieLoop AS movieCursor CURSOR FOR
            SELECT title
            FROM Movies
            WHERE studioName = studio 
            ORDER BY length DESC
        DO
            IF index = 1
            THEN SET fstLongest = title;
            ELSEIF index = 2
            THEN SET sndLongest = title;
            END IF;
            SET index = index + 1;
            IF index >= 2
            THEN LEAVE movieLoop;
            END IF;
        END FOR;
    END
d.  CREATE FUNCTION EarlistMovie (
        name    VARCHAR(255)
    ) RETURNS VARCHAR(255)
    DECLARE earlistMovie VARCHAR(255);
    DECLARE index INTEGER;
    BEGIN
        set earlistMovie = 0;
        set index = 0;
        FOR movieLoop AS movieCursor CURSOR FOR
            SELECT title
            FROM Movies, StarsIn
            WHERE
                length >= 120 AND
                starName = name AND
                movieTitle = title
            ORDER BY year ASC
        DO
            IF index = 0
            THEN SET earlistMovie = title;  
            ELSE LEAVE movieLoop;
            ENDIF;
            SET index = index + 1;
        END FOR;
    END
e.  CREATE FUNCTION NameByAddress (
        starAddress     VARCHAR(255)
    ) RETURNS VARCHAR(255)
    DECLARE starName VARCHAR(255);
    BEGIN
        SELECT name
        INTO starName
        FROM MovieStar
        WHERE address = starAddress;
        RETURN starName;
    END
f.  CREATE PROCEDURE DeleteStar (
        deleteName  VARCHAR(255) 
    )
    BEGIN
        DELETE FROM MovieStar
        WHERE name = deleteName;
        DELETE FROM Movies
        WHERE (title, year) IN (
            SELECT movieTitle, movieYear
            FROM StarsIn
            WHERE starName = deleteName
        );
        DELETE FROM StarsIn
        WHERE starName = deleteName;
    END

8.4.2
a.  CREATE FUNCTION ClosestPrice (
        targetPrice     INTEGER
    ) RETURNS INTEGER
    DECLARE closestModel INTEGER;
    DECLARE index INTEGER;
    BEGIN
        SET index = 0;
        FOR PCLoop AS PCCursor CURSOR FOR
            SELECT model 
            FROM PC
            ORDER BY ABS(price - targetPrice)
        DO
            IF index = 0
            THEN closestModel = model;
            ELSE LEAVE PCLoop;
            END IF;
            SET index = index + 1;
        END FOR;
        RETURN closestModel;
    END
b.  CREATE FUNCTION GetPrice (
        inMaker CHAR(1),
        inModel INTEGER
    ) RETURNS CHAR(10)
    DECLARE outType CHAR(10);
    BEGIN
        SELECT type
        INTO outType
        FROM Product
        WHERE maker = inMaker AND model = inModel;
        RETURN outType;
    END
c.  CREATE PROCEDURE InsertPC (
        inModel INTEGER,
        inSpeed REAL,
        inRam   INTEGER,
        inHd    INTEGER,
        inPrice INTEGER
    ) 
    DECLARE tModel INTEGER;
    DECLARE Exist CONDITION FOR SQLSTATE '23000';
    BEGIN 
        SET tModel = inModel;
        REPEAT
            INSERT INTO PC
            VALUES (tModel, inSpeed, inRam, inHd, inPrice);
            SET tModel = tModel + 1;
        UNTIL NOT Exist
        END REPEAT;
    END
d.  DECLARE PROCEDURE GetNumbers (
        IN  inPrice     INTEGER,
        OUT outPCNumber INTEGER,
        OUT outLaptopNumber     INTEGER,
        OUT outPrinterNumber    INTEGER
    )
    BEGIN
        SET outPCNumber = 0;
        SET outLaptopNumber = 0;
        SET outPinterNumber = 0;
        SELECT COUNT(*)
        INTO outPCNumber
        FROM PC 
        WHERE price > inPrice;
        SELECT COUNT(*)
        INTO outLaptopNumber
        FROM Laptop
        WHERE price > inPrice;
        SELECT COUNT(*)
        INTO outPrinterNumber
        FROM Printer
        WHERE price > inPrice;
    END

8.4.3
a.  CREATE FUNCTION Filepower (
        inClass     VARCHAR(255)
    ) RETURNS INTEGER
    RETURN (
        SELECT numGuns * bore * bore * bore
        FROM Classes
        WHERE class = inClass
    )
b.  CREATE PROCEDURE Involved (
        IN  inBattle    VARCHAR(255),
        OUT fstCountry  VARCHAR(255),
        OUT sndCountry  VARCHAR(255)
    )
    DECLARE nInvolved INTEGER;
    BEGIN
        SET nInvolved = 0;
        FOR battleLoop AS battleCursor CURSOR FOR
            SELECT country
            FROM Classes, Ships, Battles, Outcomes
        WHERE 
            Classes.class = Ships.class AND 
            Ships.name = Outcomes.ship AND
            Battles.name = Outcomes.battle AND
            Battles.name = inBattle
        DO
            IF nInvolved = 0
            THEN SET fstCountry = country;
            ELSE IF nInvolved = 1
            THEN SET sndCountry = country;
            ELSE LEAVE battleLoop;
            END IF;
            nInvolved = nInvolved + 1;
        END FOR;
        IF nInvolved <> 2
        THEN
            SET fstCountry = NULL;
            SET sndCountry = NULL;
        END IF;
    END
c.  CREATE PROCEDURE InsertClass (
        IN  inClass     VARCHAR(255),
        IN  inType      CHAR(2),
        IN  inCountry   VARCHAR(255),
        IN  inNumGuns   INTEGER,
        IN  inBore      INTEGER,
        IN  inDisplacement  INTEGER
    )
    BEGIN
        INSERT INTO Classes
        VALUES (inClass, inType, inCountry, inNumGuns, inBore, inDisplacement);
        INSERT INTO Ships (name, class)
        VALUES (inClass, inClass);
    END
d.  CREATE PROCEDURE FixDate (
        IN  inShip  VARCHAR(255),
    )
    FOR fixLoop AS fixCursor CURSOR FOR 
        SELECT Battles.name AS battle
        FROM Ships, Outcomes, Battles
        WHERE
            Ships.name = inShip AND
            Ships.name = Outcomes.ship AND
            Battles.name = Outcomes.battle AND 
            Battles.date < Ships.launched
    DO
        UPDATE Ships
        SET launched = 0
        WHERE name = inShip;
        UPDATE Battles
        SET date = 0
        WHERE name = battle;
    END FOR

8.4.4
Var(X)  = E[(X - E[X]^2]
        = E[X^2 - 2XE[X]^2 + E[X]^2]
        = E[X^2] - 2E[X]^2 + E[X]^2 // linearity of expectation
        = E[X^2] - E[X]^2

8.5.1 - 8.5.2
// skipped

8.6.1 - 8.6.2
// skipped

8.7.1 - 8.7.2
// skipped

8.7.3
MessageFormat class

GRANT_STMT:
    "grant" PRIVILEGE ("," PRIVILEGE)*
    "on" DATABASE_ELEMENT
    "to" USER ("," USER)*
    ("with grant option")?

REVOKE_STMT:
    "revoke" "grant option for"? PRIVILEGE ("," PRIVILEGE)*
    "on" DATABASE_ELEMENT
    "from" USER ("," USER)*
    ("cascade" | "restrict")
    // there's no way to revoke a privilege from only the
    // immediate grantee

9.1.1
A/p** -> B/p*

9.1.2
A/p** -> B/p
A/p** -> E/p*
E/p* -> C/p
E/p* -> D/p*

9.1.3
A/p**

SEP_BY_COMMA(EXPR) = EXPR ("," EXPR)

WITH_STMT:
    "with"
        SEP_BY_COMMA("recursive"? TABLE "(" COLUMNS ")" "as" QUERY_STMT)
    SQL_STMT

set operations (UNION, EXCEPT, ..) in FROM or WITH statements is invalid in multiple flavor of DB

9.2.1
a.  Reachable(frm, to, departs, arrives) <- Flights(_, frm, to, departs, arrives)
    Reachable(frm, to, departs, arrives) <- Flights(_, frm, mid, arrives, to_transfer) &
                                            Reachable(mid, to, from_transfer, departs) &
                                            hour(to_transfer) + 1 <= hour(from_transfer)
b.  WITH RECURSIVE Reaches(frm, to, departs, arrives)
        (SELECT frm, to, departs, arrives FROM Flights)
        UNION
        (
            SELECT Flights.frm, Reaches.to, Flights.departs, Reaches.arrives
            FROM Flights, Reaches
            WHERE 
                Flights.to = Reaches.frm AND 
                HOUR(Flights.arrives) + 1 <= HOUR(Reaches.departs)
        )
    SELECT frm, to FROM Reaches

9.2.2
it's a keyword of SQL, like most languages a keyword cannot be used as an identifer

9.2.3
a.  // the same to Reachable, skipped
b.  // the same to Reachable, skipped
c.  WITH FollowOn(x, y) AS
        // ..
    SELECT * FROM (FollowOn EXCEPT SequelOf)
d.  WITH FollowOn(x, y, n) AS
        (SELECT x, y, 1 FROM SequelOf)
        UNION
        (
            // if SequelOf is recursive (i.e. (x, x) IN SequelOf for some x)
            // this query won't terminate
            SELECT SequelOf.x, FollowOn.y, FollowOn.n + 1
            FROM SequelOf, FollowOn
            WHERE SequelOf.y = FollowOn.x
        )
    SELECT x, y FROM FollowOn WHERE n >= 2
e.  WITH FollowOn AS
        // ..
    SELECT x 
        FROM FollowOn 
        GROUP BY FollowOn.x
        HAVING COUNT(*) >= 2
f.  WITH FollowOn AS
        // ..
    SELECT x, y
        FROM FollowOn AS Outer
        WHERE 1 >= (SELECT COUNT(*) FROM FollowOn WHERE x = Outer.y)

9.2.4
a.  WITH R(class, rclass) AS
        (SELECT class, rclass FROM Rel)
        UNION
        (
            SELECT Rel.class, R.rclass
            FROM Rel, R
            WHERE Rel.rclass = R.class
        )
    SELECT * FROM R
b.  WITH R(class, rclass, mult) AS
        (SELECT * FROM Rel WHERE mult = 'single')
        UNION
        (
            SELECT Rel.class, R.rclass, 'single'
            FROM Rel, R
            WHERE 
                Rel.rclass = R.class AND
                Rel.mult = 'single' AND
                R.mult = 'single'
        )
    SELECT class, rclass FROM R
c.  WITH R(class, rclass) AS
        (SELECT class, rclass FROM Rel WHERE mult = 'multi')
        // bidirectional growth from a multi-only base set
        UNION
        (
            SELECT Rel.class, R.rclass
            FROM Rel, R
            WHERE Rel.rclass = R.class
        )
        UNION
        (
            SELECT Rel.class, R.rclass
            FROM Rel, R
            WHERE Rel.rclass = R.class
        )
    SELECT class, rclass FROM R
d.  part a EXCEPT part b
e.  WITH R(class, rclass, mult) AS
        Rel
        UNION
        (
            SELECT Rel.class, R.rclass, Rel.mult
            FROM Rel, R
            WHERE 
                Rel.rclass = R.class AND
                Rel.mult = 'single' AND
                R.mult <> Rel.mult
        )
    SELECT class, rclass FROM R
f.  WITH R(class, rclass, multi) AS 
        // same to part b
    SELECT *
    FROM R INTERSECTION (SELECT rclass, class FROM R)

9.3.5
a.  Movies(title, year, length, genre, studioName, stars({*Stars}))
    // Stars unchanged
b.  Studio(name, address, presC#, movies({*Movies}))
    // Movies from part a
c.  Movies(title, year, length, genre, studio(*Studio), stars({*Stars}))

CREATE_TYPE:
    "create type" TYPE "as" "(" SEP_BY_COMMA(IDENT TYPE) ")"

9.4.7
CREATE TABLE Movies (
    title   MovieTitle,
    year    Year,
    length  Minute, 
    genre   Genre,
    studioName  StudioName
);
CREATE Table Studio (
    name    StudioName,
    address Address,
    presC#  Cert
);
CREATE Table MovieStar (
    name    ExecName,
    address Address,
    birthdate   Date
);
CREATE Table MovieExec (
    name    ExecName,
    address Address,
    cert#   Cert,
    netWorth    Worth
);
CREATE Table StarsIn (
    movieTitle  MovieTitle,
    movieYear   Year,
    starName    ExecName
);

9.4.8
a.  CREATE TYPE NameType AS (
        first   VARCHAR(255),
        middle  VARCHAR(255),
        last    VARCHAR(255),
        title   VARCHAR(255)
    );
b.  CREATE TYPE PersonType AS (
        name    NameType,
        mother  REF(PersonType),
        father  REF(PersonType)
    );
c.  CREATE TYPE MarriageType AS (
        date    Date, 
        spouse1 REF(PersonType),
        spouse2 REF(PersonType)
    )

// introducing OO concepts to relational database seems to be violating OOP itself
// leaking object definitions and references to DB is by no means seperation of concern
// references and relations are two implementation of the same concept

CREATE_ORDERING:
    "create ordering for" TYPE
        ("equals only | "ordering full")
        "by" ("state" | "relative with" FUNCTION)

9.5.5
a.  SELECT star->name
    FROM StarsIn
    WHERE movie->title = 'Dogma'
b.  SELECT DISTINCT movie->title, movie->year
    FROM StarsIn
    WHERE star->address.city = 'Malibu'
c.  SELECT DISTINCT DEREF(movie)
    FROM StarsIn 
    WHERE star->name = 'Melanie Griffith'
d.  SELECT DISTINCT movie->title, movie->year
    FROM StarsIn
    GROUP BY movie
    HAVING COUNT(star) >= 5

9.5.2
CREATE FUNCTION ThenCmp (
    a   INTEGER,
    b   INTEGER
) RETURNS INTEGER
IF a = 0 THEN RETURN b;
ELSE RETURN a;
END IF;

CREATE FUNCTION StarLEG (
    lhs     StarType
    rhs     StarType
) RETURNS INTEGER
// compare name then address
// by the FD (name, address) -> birthyear, birthyear can be ignored in comparison
DECLARE name_cmp INTEGER;
DECLARE addr_cmp INTEGER;
BEGIN
    IF lhs.name < rhs.name THEN SET name_cmp = -1;
    ELSE IF lhs.name > rhs.name THEN SET name_cmp = 1;
    ELSE SET name_cmp = 0;
    END IF;
    SET addr_cmp = AddrLEG(lhs.address, rhs.address);
    RETURN ThenCmp(name_cmp, addr_cmp);
END

9.5.3
CREATE PROCEDURE DeleteStar (
    IN inName   CHAR(30) 
)
BEGIN
    BEGIN TRANSCATION;
    // otherwise another session may insert dangling pointers into StarsIn
    // after deletion of StarsIn and before deletion of MovieStar
    SET TRANSACTION READ WRITE ISOLATION LEVEL SERIALIZABLE;
    DELETE FROM StarsIn
    WHERE star IN (
        SELECT starID
        FROM MovieStar
        WHERE name = inName
    );
    DELTE FROM MovieStar
    WHERE name = inName;
    COMMIT;
END

9.6.1
a.  dimension attributes: cust, date, proc, hd, od, memory
    dependent attributes: quant, price
b.  Customer(id)
    Date(day, week, month, year)
    Processor(id, brand, speed, cores, ..)
    Harddisk(id, brand, space, ..)
    Optical(id, brand, type, speed, writable, ..)

9.6.2
SELECT week, type, SUM(*) 
FROM (Order NATURAL JOIN Optical ON od = id)
WHERE year = $current_year
GROUP BY week, type

9.7.1
a.  F: 10^10
    CUBE(F): Σ_{i=0}^10 (10^i * C(10, i)) = 25937424601
    25937424601 / 10^10 = 2.5937424601
b.  F: 2^10
    CUBE(F): Σ_{i=0}^10 (2^i * C(10, i)) = 59049
    59049 / 2^10 = 57.665

9.7.2
a.  SELECT dealer, SUM(val)
    FROM SalesCube
    WHERE 
        model = NULL AND
        color = 'blue' AND
        date = NULL
    GROUP BY dealer
b.  SELECT SUM(cnt)
    FROM SalesCube
    WHERE
        model = 'Gobis' AND
        color = 'green' AND
        date = NULL AND
        dealer = 'Smilin\' Sally'
c.  SELECT dealer, AVG(SUM(cnt))
    FROM SalesCube
    WHERE 
        model = 'Gobis' AND
        color = NULL AND
        Year(date) = 2007 AND
        Month(date) = 3
    GROUP BY date, dealer

9.7.3
none of them has NULL tail

9.7.4
CREATE MATERIALIZED VIEW OrderCube AS 
    SELECT cust, date, proc, hd, od, memory, SUM(sale), SUM(quant)
    FROM Order
    GROUP BY cust, date, proc, hd, od, memory WITH CUBE

9.7.5
a.  SELECT speed, Month(date), SUM(SUM(quant))
    FROM OrderCube, Processor, Date
    WHERE
        cust = NULL AND
        Year(date) = 2007 AND 
        proc = Processor.id AND
        hd = NULL AND
        od = NULL AND
        memory = NULL
    GROUP BY speed, Month(date)
b.  SELECT Harddisk.type, Processor.type, SUM(SUM(quant))
    FROM OrderCube, Processor, Harddisk
    WHERE
        cust = NULL AND
        date = NULL AND
        proc = Processor.id AND
        hd = Harddisk.id AND
        od = NULL AND
        memory = NULL
    GROUP BY Harddisk.type, Processor.type
c.  SELECT Month(date), AVG(SUM(sale) / SUM(quant))
    FROM OrderCube, Processor
    WHERE
        cust = NULL AND
        Year(date) >= 2005 AND
        proc = Processor.id AND
        Processor.speed = 3.0 AND
        hd = NULL AND
        od = NULL AND
        memory = NULL
    GROUP BY Month(date)

9.7.6
GROUP BY model, date, dealer, color WITH ROLLUP

9.7.7
assume there are n dimension attributes in F, each with ki possible value, the size of CUBE is
    let N = {1, .., n},
    Σ_{A ∈ 2^N} (Π_A kj) C(n, |A|)
the fact table may be empty, the ratio is not well defined

//  1.  XML is more dead than ever
//  2.  most use cases of its replacement, JSON, assumes a schema automatically generated from a type 
//      or explicitly descripted in the host language, hence this chapter doesn't apply
//  3.  the last two sections are details of DTD and XML schema, while JSON schema is a whole other beast
//  the next chapter is skipped