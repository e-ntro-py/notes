//  whenever appropriate, all "Write a program" practices will be done in Rust instead of C
Chapter 2
2.1
A.  1110011010011111111000
B.  c97b
C.  11010101111001001100
D.  26e7b5

2.2
19  524288  0x80000
14  16384   0x4000
16  65536   0x10000
17  131072  0x20000
5   32      0x20
7   128     0x80

2.3
167 10100111    0xa7
62  00111110    0x3e
188 10111100    0xbc
55  00110111    0x37
136 10001000    0x88
82  01010010    0x52
172 10101100    0xac
231 11100111    0xe7

2.4
A. 0x503c + 0x8 = 0x5044
B. 0x503c − 0x40 = 0x4ffc 
C. 0x503c + 64 = 0x503c + 0x40 = 0x507c
D. 0x50ea − 0x503c = 0xae

2.5
A.  21
    87
B.  21 43
    87 65
C.  21 43 65
    87 65 43

2.6
A.  00000000001101011001000101000001
    01001010010101100100010100000100
B.  00000000001101011001000101000001
      01001010010101100100010100000100
    21 bits match
C.  the first non-zero bit in the representation of the integer number
    the first 9 bits in the representation of the float number
    the last 2 bits in the representation of the float number

2.7
61 62 63 64 65 66
will not include the terminating character

2.8
a = 01101001
b = 01010101
~a = 10010110
~b = 10101010
a & b = 01000001
a | b = 01111101
a ^ b = 00111100

2.9
A.  ~Black = White
    ~Blue = Yellow
    ~Green = Magenta
    ~Cyan = Red
    and vice versa
B.  Blue | Green = Cyan 
    Yellow  & Cyan = Green 
    Red ^ Magenta = Blue

2.10
a   a^b
b   a^b
b   a

2.11
A.  both equals k
B.  the function in the final iteration swaps the k+1-th elements with itself
    the two references applied to the function inplace_swap refers to the same address
    in step 1 of inplace_swap, *y = *x ^ *y = *x ^ *x = 0, further computations always result in 0
C.  change line 4 to
        first < last;

2.12
A.  x & 0xff
B.  x ^ ~0xff
C.  x | 0xff

2.13
x   y   bis(x, y)
0   0   0
0   1   1
1   0   1
1   1   1
therefore x | y == bis(x, y)
x   y   bic(x, y)
0   0   0
0   1   0
1   0   1
1   1   0
therefore x ^ y = bic(x, y) | bic(y, x) = bis(bic(x, y), bic(y, x))

2.14
x & y == 0x20
x | y == 0x7f
~x | ~y == 0xdf
x & !y == 0x01
x && y == 0x01
x || y == 0x01
!x || !y == 0x00
x && ~y == 0x01

2.15
!(x ^ y)

2.16
0xc3    11000011    11000       0x18    110000  0x30    11110000    0xf0
0x75    1110101     10101000    0xa8    11101   0x1d    11101       0x1d
0x87    10000111    111000      0x38    100001  0x21    11100001    0xe1 
0x66    1100110     110000      0x30    11001   0x19    11001       0x19

2.17
0x0 0000    0   0
0x5 0101    5   5
0x8 1000    8   -8
0xd 1101    13  -3
0xf 1111    15  -1

2.18
A.  440
B.  20
C.  -424
D.  -396
E.  68
F.  -312
G.  16
H.  12
I.  -276
J.  32

2.19
-8  8
-3  13
-2  14
-1  15
0   0
5   5

2.20
T2U4(x) =   x if x >= 0
            x + 16 if x < 0

2.21
unsigned    1
signed      1
unsigned    0
signed      1
unsigned    1

2.22
A.  1011 = -2^3 + 2^1 + 2^0 = -5
B.  11011 = -2^4 + 2^3 + 2^1 + 2^0 = -5
C.  111011 = -2^5 + 2^4 + 2^3 + 2^1 + 2^0 = -5

2.23
A.  118     118
    33      33
    201     -55
    135     -121
B.  returns the least significant 8 bits of a word, padded by either 0 or 1, interpreted as sa signed integer

2.24
0   0
2   2
1   1
3   3
7   -1

2.25
length - 1, when length == 0, will underflow and wrap to 2^w - 1, given w-bit word size
change loop condition from i <= length - 1 to i < length will fix the error

2.26
A.  whenever strlen(s) < strlen(t), the function will return 1
B.  when strlen(s) < strlen(t), the result of strlen(s) - strlen(t) will underflow and wrap to a positive number
C.  return strlen(s) > strlen(t);

2.27
fn uadd_ok(x: u32, y: u32) -> bool {
  let s = x.wrapping_add(y);
  s >= x
}

2.28
0   0   0   0
5   5   11  b
8   8   8   8
d   13  3   3
f   15  1   1

2.29
10100   10001
-12     -15     -27     5       1
11000   11000
-8      -8      -16     -16     2
10111   01000
-9      8       -1      -1      2
00010   00101
2       5       7       7       3
01100   00100
12      4       16      -16     4

2.30
fn tadd_ok(x: i32, y: i32) -> bool {
  let s = x.wrapping_add(y);
  !((x >= 0 && y >= 0 && s < 0) || (x < 0 && y < 0 && s >= 0))
}

2.31
cause I was being harsh against others
and the implementation is based on the exact meaning of signed substraction
when sum = x + y overflowed, sum - x and sum - y may also overflow, the result is UB in the specification of C

2.32
when y == -(2^w), w the size of the word, y doesn't have a positive counterpart representable as a w-bit word
when y == -(2^w), -y overflows, the result is UB and tadd_ok(x, -y) may return anything depend on -y

2.33
0   0   0   0
5   5   -5  b
8   -8  -8  8
d   -3  3   3
f   -1  1   1
they have the same bit representation

2.34
100     101
4       5       20[100100]      4[100]
-4      -3      12[001100]      -4[100]
010     111
2       7       14[001110]      6[110]
2       -1      -2[111110]      -2[110]
110     110
6       6       36[100100]      4[100]
-2      -2      4[000100]       -4[100]

2.35
when x == 0, xy will always be 0, no matter truncated to how many bits, thereby no overflow
tmult_ok(0, y) should return 1 for all y
when x == 0, !x == 1, (!x || p/x == y) == 1, the answer is correct
when x != 0, xy didn't overflow, xy == p
reversely, when xy == p, xy didn't overflow
when xy overflowed,
    p   = U2Tw(xy mod 2^w)
        = [xy mod 2^w] + k2^w, k = -1 or 0
    xy  = [xy mod 2^w] + r2^w
        = p + (r - k)2^w
define t = r - k then xy = p + t2^w
the specification of C language requires (p / x) * x + p % x == p for integers
http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf
hence for q = p/x, p == q * x + p % x, where p % x is the reminder of p divides x, therefore r = p % x and |r| < |x|
when t == 0, r == 0, xy didn't oveflow, xy == p, q == p / x == y
when t != 0, xy overflowed, xy == p + t2^w, p == xy - t2^w
if q == p / x == y, p == xy + r, |r| < |x|, which implies |t2^w| < |x|, contradiction
therefore when t != 0, q != y, and q == y <=> (t == 0 && r == 0)

2.36
fn tmult_ok(x: i32, y: i32) -> bool {
  // product of two w-bit signed integer can be represented by 2w bits
  // so product of two i32 will fit in an i64, the calculation can never overflow
  let p = (x as i64) * (y as i64);
  let min = i32::min_value() as i64;
  let max = i32::max_value() as i64;
  p >= min && p <= max
}

2.37
A.  not so much. the library function memcpy expects input of type size_t, and will truncate asize to that size
    by carefully choosing ele_cnt and ele_size, the trancated asize can still be small
B.  explicitly check for overflow using function tmult_ok
    immediately return NULL when the multiplication will overflow

2.38
a << k == a * 2^k
a << k + a == a * 2^k + a == a * (2^k + 1)
for k ∈ {0 .. 3}, LEA can calculate pa for p ∈ {1, 2 4, 8} ∪ {2, 3, 5, 9} = {1, 2, 3, 4, 5, 8, 9}

2.39
(x << n) << 1 - (x << m)

2.40
6[110]      (x << 2) + (x << 1)
31[11111]   (x << 6) - x
-6, 2 - 8   (x << 1) - (x << 3)
55[110111]  (x << 7) - (x << 3) - x

2.41
when (n - m) is greater than 2 and subtraction has similar cost to addition, use form B
otherwise (n - m <= 2 or substraction is significantly more costy than addition), use form A

2.42
fn div16(x: i32) -> i32 {
  let bits = x >> 31;
  let bias = 16 - 1;
  (x + (bias & bits)) >> 4
}

2.43
M == 2^5 - 1 == 31
N == 2^3 == 8

2.44
A.  for x = -2^31, x < 0, x - 1 == 2^31 - 1 > 0
B.  x & 7 truncates x to 3 bits
    when x & 7 intepreted as a 32-bit signed integer equals to 7, the least significant 3 bits of x is 111
    thereby x << 29 will have most significant bit equals to 1, is a negative number when interpreted as a signed int
C.  for x = 1234567891, x * x == -1521747479 < 0
D.  if x >= 0, -x is representable in 32 bits and will not overflow, -x <= 0
E.  for x = -2^31, -x is defined as -2^31, x < 0 && -x < 0
F.  this is how signed integer addition is defined according to 2.13
    x + y and ux + uy will have the same bit representation
    also == will cast the signed x + y to unsigned integer
G.  x * (~y + 1) == x * -y == - (x * y)
    x * y and ux * uy have the same bit representation
    for some signed z and its unsigned interpretation uz
    if z == -2^(w-1),
        -z          == -2^(w-1)
        T2Uw(-z)    == 2^w + -2^(w-1) == 2^(w-1)
        T2Uw(z)     == 2^(w-1)
        -T2Uw(z)    == 2^w - 2^(w-1) == 2^(w-1)
    if -2^(w-1) < z < 0,
        -z          == -(z) (integer)
        T2Uw(-z)    == -(z)
        T2Uw(z)     == 2^w + z
        -T2Uw(z)    == 2^w - (2^w + z) == -(z)
    if z == 0,
        -z          == 0
        T2Uw(-z)    == 0
        T2Uw(z)     == 0
        -T2Uw(z)    == 0
    if z > 0,
        -z          == -(z)
        T2Uw(-z)    == 2^w - z
        T2Uw(z)     == z 
        -T2Uw(z)    == 2^w - z
    therefore -z and -uz has the same bit representation, and 
        -(x * y) + ux * uy == 0
        x * (~y + 1) + ux * uy == 0
        x * ~y + x + ux * uy == 0
    by definition, x * ~y + ux * uy is the addictive inverse of ux
    again -ux and -x has the same bit representation, so
        x * ~y + ux * uy == -x

2.45
3/4     0.11    0.75
25/16   1.1001  1.5625
43/16   10.1011 2.6875
9/8     1.001   1.125
47/8    101.111 5.875
51/16   11.0011 3.1875

2.46
x = 0.00011001100110011001100
A.  0.1 - x == 0.0000000000000000000000011[0011]...
B.  0.1 - x ≒ 0.0000000953674316
C.  t_diff == 100 * 3600 * (0.1 - x) ≒ 0.034332275392634 second
D.  2000 * t_diff ≒ 68.664550785 meters

2.47
./CSAPP/float

2.48
the bit representation of 3510593 is 1101011001000101000001, 22 bit long
drop the leading 1, get 101011001000101000001
pad it to 23 bits with 0, get 10101100100010100000100
the fraction should be shifted to 21 positions to the right of binary point
21 + 127 = 149, has binary representation 10010101
combined with a sign bit 0, 01001010110101100100010100000100 is the final result

2.49
A.  for a floating-format with n-bit fraction, let f = [10^n1], then f * 2^k cannot be represented exactly for any k
    let sd be the smallest positive denormalized number and sn the smallest positive normalized number
    the smallest positive number np that cannot be represented exactly is
        np  == sd/2 + sn
            == 2^(-n - 2^(k-1) + 1) + 2^(-2^(k-1) + 2)
B.  for n = 23, k = 8,
        np == 2^-149 + 2^-125

2.50
A.  10.010(2 + 1/4)     10.0(2)
B.  10.011(2 + 3/8)     10.1(2 + 1/2)
C.  10.110(2 + 3/4)     11.0(3)
D.  11.001(3 + 1/8)     11.0(3)

2.51
A.  0.1 == 0.00011001100110011001100[1100]...
    x' == 0.00011001100110011001101
B.  x' - 0.1 == 0.10000002384185791
C.  t_diff == 100 * 3600 * (x' - 0.1) == 0.008583068845657849 seconds
D.  2000 * t_diff == 17.166137691315697 meters

2.52
101 1110    30      1001 111    30
010 1001    25/32   0110 100    12/16
110 1111    31/2    1011 000    16
000 0001    1/32    0001 000    1/32

2.53
#define POS_INFINITY (1e308 * 2)
#define NEG_INFINITY (1e308 * -2)
#define NEG_ZERO (1 / NEG_INFINITY)

2.54
A.  true, int -> double will be exact, no rounding performed on the way back
B.  x = 0x80000001
C.  x = 0.1234567890123
D.  true, float -> double will be exact, no rounding performed on the way back
E.  true, negation of a floating number only changes the sign bit
F.  true, integer literals will be implicitly converted to float
G.  guarenteed by IEEE format
H.  f = 1e10, d = 1e-10

2.55
most of them are little-endian

2.56
./CSAPP/float

2.57
a properly coded polynomial function show_bytes<T> in Rust can handle all types which implements trait Sized
i.e. show_short, show_long, show_double all unnecessary

2.58
./CSAPP/float

2.59
(0x00000001 & x) | (0xfffffffe & y)

2.60
./CSAPP/float

2.61
A.  !!x
B.  !(~x)
C.  !!(x & 0xff)
D.  !!(~x & (INT_MIN >> 1))

2.62
./CSAPP/float

2.63
./CSAPP/float

2.64
./CSAPP/float

2.65
thanks https://stackoverflow.com/questions/27467595/
./CSAPP/float
given a w-bit word x = [b1b2 .. bw], the parity function is defined as
    f(x) = b1 xor b2 xor .. xor bw
by commutativity and associativity of xor, every pair of 1s will cancel each other
if there are odd 1s in the bit representation of x, f(x) == 1, otherwise f(x) == 0
also for a 2w-bit word x = [b1..b2w],
    f(x)    = b1 xor .. xor b2w
            = (b1 xor bw+1) xor (b2 xor bw+2) .. xor (bw xor b2w)
            = f(x'), where x' = x[1..w] xor x[w+1..2w]
hence given a w-bit x = x1||x2, |x1| = |x2|, the parity of x can be computed as the parity of x1 xor x2
doing so iteratively and odd_ones can be computed with log2(w) xors and log2(w) shifts

2.66
./CSAPP/float
let x = [0 .. 0bk .. bw], where bk is the most significant non-zero bit
by computing x |= x >> 1, both bk and bk+1 now is guarenteed to be 1
such a computation will never change bits more significant than bk, as right shift is logical for unsigned integer
then x |= x >> 2, as bk and bk+1 are 1, bk+2 and bk+3 will be 1 after this step
after t steps, 2^t bits after bk will be 1
so 5 steps is sufficient to transfer any 32-bit x to [0 .. 01 .. 1], where k-th bit is still the first non-zero bit
let y be x after 5 iterations
then (y >> 1) + 1 will give the right answer for all x except 0
so ((y >> 1) + 1) & x is the answer

2.67
A.  shift count in C cannot be equal to or greater than the size of the integer
    for a 32-bit int, 1 << 32 will be UB
B.  change line 4 and 6 to
        int set_msb = 1 << 31;
        int beyond_msb = 1 << 31 << 1;
C.  change line 4 and 6 to
        int set_msb = 1 << 15 << 15 << 1;
        int beyond_msb = 1 << 15 << 15 << 2;

2.68
./CSAPP/float

2.69
./CSAPP/float

2.70
./CSAPP/float

2.71
A.  word is of type unsigned, and type casting in C between unsigned and int preserves bit representation, not value
    (word >> (bytenum << 3)) will always be extended with 0, the result will always be interpreted as positive
B.  return 0xff - ((word << ((3 - bytenum) << 3)) >> 24)

2.72
A.  the one of the operator of (maxbytes - sizeof(val)) is of type size_t, which is unsigned
    so the result will be casted to unsigned, and an unsigned number is always greater or equal to 0
B.  if (maxbytes >= 0 && maxbytes >= sizeof(val))

2.73
thanks https://zhangjunphy.github.io/csapp/chap2.html
./CSAPP/float

2.74
check if y == INT_MIN, then run tadd_ok(x, -y)

2.75
when x, y <= INT_MAX, the result of unsigned_high_prod(x, y) should be equal to signed_high_prod(x, y)
when both x, y > INT_MAX, denote tx = U2Tw(x) and ty = U2Tw(y)
    tx = x - 2^w, ty = y - 2^w
    tx * ty = 2^2w + xy - x2^w - y2^w
    xy = tx * ty + x2^w + y2^w - 2^2w = tx * ty + x2^w + y2^w mod 2^2w
both x2^w and y2^w have zeros in lower w bits
thus unsigned_high_prod(x, y) = signed_high_prod(x, y) + x + y
when x <= INT_MAX and y > INT_MAX, denote tx = U2Tw(x) and ty = U2Tw(y)
    tx = x, ty = y - 2^w
    tx * ty = xy - x2^w
    xy = tx * ty + x2^w
and unsigned_high_prod(x, y) = signed_high_prod(x, y) + x
when x > INT_MAX and y <= INT_MAX, symmetrically
unsigned_high_prod(x, y) = signed_high_prod(x, y) + y
./CSAPP/float

2.76
A.  x + (x << 4)
B.  x - (x << 3)
C.  (x << 6) - (x << 2)
D.  (x << 4) - (x << 7)

2.77
./CSAPP/float 

2.78
./CSAPP/float

2.79
thanks https://dreamanddead.gitbooks.io/csapp-3e-solutions/chapter2/2.80.html
./CSAPP/float

2.80
A.  -1 << k
B.  ~(-1 << k << j) & (-1 << j)

2.81
A.  when x == INT_MIN, y >= 0, x < y == 1 and -x > -y == 0
B.  (x + y) << 4 == 16 * (x + y) == 16 * x + 16 * y
    (x + y) << 4 + y - x == 17 * y + 15 * x
C.  ~(x + y) + 1 == -(x + y), ~(x + y) == -(x + y) - 1
    ~x + 1 == -x, ~y == -y - 1, ~x + ~y + 1 = -x + -y - 1
    -x + x + -y + y == 0, x + y + (-x + -y) == 0, (-x + -y) == -(x + y), negation distributes over addition
D.  substraction, addition and negation are all isomorphic in signed and unsigned arithmetics
    the bit representation is always the same after signed or unsigned computation
    -(y - x) == -(uy - ux)
    ux - uy + (uy - ux) == 0, -(uy - ux) == ux - uy
    therefore ux - uy == -(unsigned)(y - x)
E.  (x << 2) >> 2 erases the least significant 2 bits of x
    in two's complement representation, these two bits always have positive weights
    therefore (x << 2) >> 2 <= x holds

2.82
A.  0.yyyyy... == Y/2^k + Y/2^2k + ... == Y(1/2^k + 1/2^2k + ...) == Y(2^k/(2^k - 1) - 1) == Y/(2^k - 1)
B.  a.  5/(2^3 - 1) == 5/7
    b.  6/(2^4 - 1) == 6/15 == 2/5
    c.  35/(2^6 - 1) == 35/63 == 5/9

2.83
return sx == sy ? (sx ? ux << 1 >= uy << 1 : ux << 1 <= uy << 1) : (ux << 1 == 0 && uy << 1 == 0) || sx > sy

2.84
A.  E = 2, M = 7/4, f = 3/4, V = 7
    x = 0||e||m
    where e is the k-bit representation of 2^(k-1) + 1
    m is the n-bit representation of 3/4, binary point placed before the first bit
B.  for E > n + 1, every number representable will be even
    E = n, M = 2 - 1/2^n, f = 1 - 1/2^n, V = 2^(n+1) - 1
    x = 0||e||1^n
    where e is the k-bit representation of n
C.  the smallest positive normalized value = 2^(2 - 2^(k-1))
    its reciprocal is 2^(2^(k-1) - 2)
    E = 2^(k-1) - 2, M = 1, f = 0, V = 2^(2^(k-1) - 2)
    x = 0||e||0^n
    where e is the n-bit representation of 2^(k-1) - 2 + 2^(k-1) - 1 = 2^k - 3

2.85
2^-16445            about 1e-4950
2^-16382            about 1e-4931
2^16384 - 2^16320   about 1e4932

2.86
0x8000      0       -63     -0
0x2001      257/256 1       257 * 2^-7
0x4800      0       9       512
0x00ff      255/256 -62     255 * 2^-70
0x3bb0      432/256 -4      27 * 2^-8

2.87
routine

2.88
A.  casting from int -> double is accurate, int -> float is equivalent to int -> double -> float
B.  dx - dy will not underflow
    when x - y underflowed (x - y < INT_MIN), (double)(x - y) will be positive, while dx - dy is negative
C.  floating point arithmetics is not associative
    when dx = 1e-10, dy = 1e10, dz = -1e10
    (dx + dy) + dz == 0, dx + (dy + dz) == 1e-10
D.  again floating point arithmetics is not associative
    when dx = 1e300, dy = 1e300, dz = 1e-300
    (dx * dy) * dz == inf, dx * (dy * dz) == 1e300
E.  when dx = 0, dz = 1
    dx / dx == NaN, dz / dz == 1

2.89
x < -149
    exp = 0
    frac = 0
x < -126
    exp = 0
    frac = 1 << (x + 149)
x < 128
    exp = x + 127
    frac = 0
else 
    exp = 0xff
    frac = 0

2.90
A.  11.0010010000111111011011
B.  22/7 = 3 + 1/7, 1/7 = 0.[001]..., 22/7 = 11.[001]...
C.  at the 9th binary position

2.91 - 2.95
./CSAPP/float

Chapter 3
3.1
%eax            0x100
0x104           0xAB
$0x108          0x108
(%eax)          0xFF
4(%eax)         0xAB
9(%eax,%edx)    0x11
260(%ecx,%edx)  0x13
0xFC(,%ecx,4)   0xFF
(%eax,%edx,4)   0x11

3.2
movl
movw
movb
movb
pushl
movw
popl

3.3
1.  addresses have to be 32-bit long, while %bl is 8-bit
2.  movl moves 32-bit double words, while %ax is 16-bit
3.  mov instructions cannot move memory address to another memory address directly
4.  no register called %sh 
5.  the destination of movl cannot be an immediate value
6.  movl moves 32-bit double words, while %dx is 16-bit
7.  movb moves 8-bit bytes, while %si is 16-bit 

3.4
movsbl %al, (%edx)
movzbl %al, (%edx)
movsbl %al, (%edx)
movb %al, (%edx)
movb %al, (%edx)
movl %eax, (%edx)

3.5

fn decode1(xp: &mut i32, yp: &mut i32, zp: &mut i32) {
    let x = *xp;
    let y = *yp;
    let z = *zp;
    *xp = z;
    *yp = x;
    *zp = y;
}

3.6
x + 6
x + y
x + 4y
9x + 7
4y + 10
x + 2y + 9

3.7
0x100       0x100
0x104       0x99
0x10C       0x110
0x108       0x14
%ecx        0x0
%eax        0xFC

3.8
movl 8(%ebp), %eax 
sall $2, %eax
movl 12(%ebp), %ecx
sarl %cl, %eax

3.9
int t1 = y;
int t2 = t1 ^ x;
int t3 = t2 >> 3;
int t4 = -t3 - z;

3.10
A.  it sets %edx to 0x00000000, as for any number x, x ^ x == 0
B.  movl $0, %edx
C.  xorl %edx, %edx is two bytes (31 d2) in machine code
    movl $0, %edx is five bytes (ba 00 00 00 00), the last four bytes encode a 32-bit immediate value zero

3.11
movl 8(%edp), %eax
xorl %edx, %edx
divl 12(%edp)
movl %eax, 4(%esp)
movl %edx, (%esp)

3.12
A.  num_t is long long unsigned, or u64
    it has size twice a dword, and computing x * y compiled to mull, the unsigned full multiplication instructure
B.  movl 20(%edp), %ecx, on a little-endian machine, moves the higher 8 bytes of y to %ecx
    y == 20(%edp) * 2^32 + 16(%edp) == %ecx * 2^32 + 16(%edp)
    x * y == (x * %ecx mod 2^32) * 2^32 + x * 16(%edp) mod 2^64
    imull %eax, %ecx computes x * %ecx mod 2^32 and puts it at %ecx
    mull 16(%edp) computes x * 16(%edp) and puts the result at %edx:%eax
    leal (%ecx, %edx) %edx computes %ecx + %edx, the higher 32 bits of x * y mod 2^64, puts the result at %edx
    therefore %edx:%eax is the result of x * y mod 2^64 at the end

3.13
A.  int, <
B.  short, >=
C.  unsigned char, >
D.  int or unsigned, !=

3.14
A.  int or unsigned, !=
B.  short or unsigned short, ==
C.  char, >
D.  unsigned short, >

3.15
A.  0x8048296
B.  0x8048341
C.  0x804837f
D.  0x80482a5
E.  absolute address

3.16
A.  void cond(int a, int *p) {
        if (p == 0)
            goto done;
        if (a <= 0)
            goto done;
        *p += a;
    done:
    }
B.  the && operator in C is short-circuiting
    when p == 0, it will not, and generally should not evaluate a > 0
    therefore if the computer find that p == 0, it should immediately skip to the end of the function

3.17
A.  int gotodiff(int x, int y) {
        int result;
        if (x < y)
            goto x_l_y;
        result = y - x;
        goto done;
    x_l_y:
        result = x - y;
    done:
        return result;
    }
B.  if the if clause without the corresponding else clause is compiled in the same way
    this rule performs one more unnecessary jump

3.18
int test(int x, int y) {
    int val = x - y;
    if (x < -3) {
        if (x > y) {
            val = x * y;
        } else {
            val = x + y;
        }
    } else if (x <= 2)
        val = x ^ y;
    return val;
}


3.19
A.  12
B.  20

3.20
A.  %eax    x       x 
    %ecx    y       y
    %edx    n       n
B.  test-expr: n > 0 && y < n
    body-statemenet: x += n; y *= n; n--;
C.  movl    8(%edp), %eax       Get x
    movl    12(%edp), %ecx      Get y 
    movl    16(%edp), %edx      Get n
  .L2:                        loop:
    addl    %edx, %eax          Compute x += n 
    imull   %edx, %ecx          Compute y *= n 
    subl    $1, %edx            Decrement n
    testl   %edx, %edx          Compare n:0
    jle     .L5                 if <=, goto done
    cmpl    %edx, %ecx          Compare y:n
    jl      .L2                 if <, goto loop
  .L5:                        done:

3.21
A.  %edx == a + b
B.  %ecx    a       a
    %ebx    b       b
    %eax    result  1
    %edx    (a+b)   (a+b)
C.  -
D.  int loop_while(int a, int b) {
        int result = 1;
        int s;
        if (a >= b)
            goto done;
        s = a + b;
        result = 1;
    loop:
        result *= s;
        a += 1;
        s += 1;
        if (b > a)
            goto loop;
    done:
    }

3.22
A.  int fun_a(unsigned x) {
        int val = 0;
        while (x != 0) {
            val ^= x;
            x = x >> 1;
        }
        return val & 1;
    }
B.  after the while loop, val is a 32-bit word
    the kth most significant bit of val is the parity of the k most significant bits of x
    val & 1 gives the least significant bit of val, which is the parity of all 32 bits in x

3.23
A.  int fun_b(unsigned x) {
        int val = 0;
        int i;
        for (i = 0; i != 32; i++) {
            val = (x & 1) | (val + val);
            x = x >> 1;
        }
        return val;
    }
B.  the result val have reversed bit representation of x

3.24
A.  int sum = 0;
    int i = 0;
    while (i < 10) {
        if (1 & 1)
            continue;
        sum += i;
        i++;
    }
    continue in a for loop will still execute the update-expr
    however in a while loop continue will pass control to the condition-expr, skips update-expr along with loop body
B.  int sum = 0;
    int i = 0;
    while (i < 10) {
        if (1 & 1)
            goto update;
        sum += i;
    update:
        i++;
    }

3.25
A.  30 cycles 
B.  46 cycles

3.26
A.  /
B.  when x < 0, the result is (x + 3) >> 2
    hence the division is always rounded towards zero, instead of towards -∞

3.27
int test(int x, int y) {
    int val = x + y;
    if (y > 0) {
        if (x < y) {
            val = x - y;
        } else {
            val = y - x;
        }
    } else if (y >= -2) {
        val = 4 * x;
    }
    return val;
}

3.28
A.  -2  -> .L3
    0   -> .L4 
    1   -> .L5 
    2,3 -> .L6 
    4   -> .L7
    def -> .L2
B.  .L6, has labels 2 and 3

3.29
int switcher(int a, int b, int c) {
    int answer;
    switch (a) {
    case 5:
        c = b ^ 0xf;
    case 0:
        answer = c + 112;
        break;
    case 2:
    case 7:
        answer = (b + c) >> 2;
        break;
    case 4:
        answer = 4;
        break;
    default:
        answer = b;
    } 
    return answer;
}

3.30
A.  the absolute address of the instruction following the label next
B.  there's nowhere to go back: the return address already been poped to %eax
C.  to get an address on fly, so it can later be used in indirect calls/jumps

3.31
%edi, %esi and %ebx are callee-save registers
procedure been called has to restore them at the end

3.32
int fun(int c, int d, int *p, int x);

3.33
A.  0x80003c
B.  0x800014
C.  x at %edp - 4 == 0x800038
    y at %edp - 8 == 0x800034
D.  0x80003c    8x800060    %edp
    0x800038    0x53        x
    0x800034    0x46        y
    0x800030
    |
    0x800020
    0x80001c    0x800038    &x
    0x800018    0x800034    &y
    0x800014    0x300070    %esp and .LCO
E.  0x800030 - 0x800020

3.34
A.  x
B.  int rfun(unsigned x) {
        if (x == 0)
            return 0;
        unsigned nx = x >> 1;
        int rv = rfun(nx);
        return (x & 1) + rv;
    }
C. the number of 1s in the bit representation of x

3.35
short: 2 bytes
*short: 4 bytes
**short: 4bytes
long double: 10 bytes in IA32, 8 bytes otherwise
*long double: 4 bytes

3.36
S+1         *short      xE + 2      leal 2(%edx), %eax
S[3]        short       M[xE + 6]   movw 6(%edx), %ax
&S[i]       *short      xE + 2i     leal (%edx, %ecx, 2), %eax
S[4*i+1]    short       M[xE+2i+2]  movw 2(%edx, %ecx, 2), %ax
S+i-5       *short      xE+2i-10    leal -10(%edx, %ecx, 2), %eax

3.37
%eax == 7i + j before line 8, N == 7
%edx == 5j + i before line 9, M == 5

3.38
void fix_set_diag_opt(fix_matrix A, int val) {
    int i;
    for (i = 0; i != (N+1) * N; i += N+1) {
        *(A+i) = val;
    }
}

3.39
A.  p:      0
    s.x:    4
    s.y:    8
    next:   12
B.  16
C.  void sp_init(struct prob *sp) {
        sp->s.x = sp->s.y;
        sp->p = s.x;
        sp->next = sp;
    }

3.40
up->t1.v    short
    movw (%eax), %ax 
    movw %ax, %dx
&up->t1.d   *short
    leal 2(%eax), %edx
up->t2.a    int[2]
    movl (%eax), %edx
up->t2.a[up->t1.s]  int
    movl 4(%eax), %edx
    movl (%eax), %eax
    movl (%eax,%edx,4), %edx
*up->t2.p   char
    movl 8(%eax), %eax
    movb (%eax), %dl

3.41
A.  i: 0, c: 4, j: 8, d: 12
    size: 16, alignment: 4/8
B.  i: 0, c: 4, d: 5, j: 8
    size: 12, alignment: 4/4
C.  w: 0, c: 6
    size: 10, alignment: 2/2
D.  w: 0, c: 8
    size: 24, alignment: 4/4
E.  a: 0, p: 32
    size: 36, alignment: 4/4

3.42
A.  a   b   c   d   e   f   g   h
    0   4   8   16  20  24  32  40
B.  48
C.  struct {
        double      c;
        long long   g;
        float       e;
        void       *h;
        char       *a;
        char        d;
        char        f;
    }
    c   g   e   h   a   d   f
    0   8   16  20  24  28  29
    size: 32

3.43
A.  0x4     08 04 86 43 return address
    %ebp    bf ff fc 94 stored %ebp
    -0x4    00 00 00 02 stored %edi
    -0x8    00 00 00 03 stored %esi
    -0xc    00 00 00 01 stored %ebx
    ...
    -0x28               <- %esp
B.  0x4     00 04 86 43 return address, first byte overwritten by the terminate character
    %ebp    30 31 32 33 "0123", %ebp overwritten
    -0x4    36 37 38 39 "6789", %edi overwritten
    -0x8    32 33 34 35 "2345", %esi overwritten
    -0xc    38 39 30 31 "8901", %ebx overwritten
    -0x10   34 35 36 37 "4567"
    -0x14   30 31 32 33 "0123"
    ...
    -0x28   -0x14       <- %esp
C.  0x00048643
D.  %ebp, %edi, %esi and %ebx
E.  thanks CSAPP-2e
    result should be large enough to contain the terminate character, strlen(buf) + 1
    malloc may fail and return NULL pointer, this case has to be handled

3.44
A.  131072
B.  1024

3.45
A.  without protector
        v:      %edp - 8
        buf:    %edp - 20
    with protector
        canary: %edp - 8
        v:      %edp - 24
        buf:    %edp - 20
B.  in the original order, the canary can only detect the overflow if the overflow overwrites more than 4 bytes
    by putting canary value right below buf on the stack, the canary can detect buffer overflow ASAP

3.46
A.  2034
B.  2045
C.  2028 
    2039

3.47
int             long            movslq  %edi    %rax
char            long            movsbq  %dil    %rax
unsigned int    unsigned long   movq    %edi    %rax
unsigned char   unsigned long   movzbq  %dil    %rax
long            int             movl    %edi    %eax
unsigned long   unsigned        movl    %edi    %eax

3.48
long arithprob(int a, char b, long c, int d);

3.49
A.  long fun_c(unsigned long x) {
        long val = 0;
        int i;
        for (i = 0; i != 8; x >>= 1, i++) {
            val += 0x101010101010101 & x;
            // 0b0000000100000001000000010000000100000001000000010000000100000001 in binary
        }
        val += val >> 32;
        val += val >> 16;
        val += val >> 8;
        return val & 0xff;
    }
B.  view val and x as 8 chars
    after the for loop, every char in val records the number of 1s in the corresponding chars in x
    after val += val >> 32, ith char in the lower 4 chars of val encodes the number of 1s in ith and (i+4)th char in x
    similarly, after val += val >> 16 and val += val >> 8
    the lowest char in val encodes the number of 1s in the whole x
    therefore val & 0xff returns the number of 1s in x
    there are at most 64 1s in x, and a char can encode numbers <= 127, the calculation will not overflow

3.50
the first argument must be x, of 4-byte size, stored in %edi
the second argument must be q, of 8-byte size, stored in %rsi
as %edi is sign-extended to %rdi before adding to (%rsi), q has type (long *)
the third argument must be t, of 8-byte size, stored in %rdx
from addl %edi, (%rdx), %rdx points to a 4-byte integer, signed or unsigned
void incrprob(int x, long *q, int *t);
void incrprob(int x, long *q, unsigned *t);
void incrprob(unsigned x, long *q, int *t);
void incrprob(unsigned x, long *q, unsigned *t);

3.51
A.  -8
    -16 7
    -24 5
    -32 3
    -40 2
B.  -
C.  the array is allocated on %rsp - 7 to %rsp - 40, without actually substracing %rsp

3.52
A.  x 
B.  store and restore the callee-save register %rbx
C.  -
D.  it uses pushq to automatically increment %rsp and store the value at the same time
    other programs manually substracts the number of bytes it allocates from %rsp

3.53
A.  i   c   j   d
    0   4   8   16
    size: 24, alignment: 8
B.  i   c   d   j 
    0   8   9   12
    size: 16, alignment: 8
C.  w   c
    0   6
    size: 10, alignment: 2
D.  w   c
    0   8
    size: 24, alignment: 8
E.  a   p 
    0   48
    size: 56, alignment: 8

3.54
./CSAPP/asm

3.55
assume y = yh * 2^32 + yl
yh is the integer represented by the higher 32 bits of y
yl is the positive integer represented by the lower 32 bits of y
then x * y == x * yh * 2^32 + x * yl
as x * yh * 2^32 will have least significant 32 bits equal to 0
the lower 32 bits of x * yl is the lower 32 bits of x * y
when x >= 0, (x * yl) >> 32 + x * yh is the higher 32 bits of x * y
when x < 0, T2U(x) = 2^32 + x, T2U(x) * yl == (2^32 + x) * yl == 2^32 * yl + x * yl
the higher 32 bits of x * y can be computed as T2U(x) * yl >> 32 + x * yh - yl
assuming little-endian machine
movl    16(%ebp), %esi          retrieve lower 4 bytes of y, save to %esi
movl    12(%ebp), %eax          retrieve x, save to %eax 
movl    %eax, %edx              copy x to %edx
sarl    $31, %edx               if x < 0, %edx == -1; otherwise %edx == 0
movl    20(%ebp), %ecx          retrieve higher 4 bytes of y, save to %ecx
imull   %eax, %ecx              compute product of x and yh, save to %ecx
movl    %edx, %ebx              copy the sign mask to %ebx
imull   %esi, %ebx              compute product of yl and sign mask, save to %ebx
addl    %ebx, %ecx              if x >= 0, %ecx unchanged; otherwise %ecx += -yl
mull    %esi                    compute full unsigned product of yl and x, save to %edx:%eax
leal    (%ecx,%edx), %edx       add %ecx and %edx, save to %edx
movl    8(%edp), %ecx           retrieve dest, save to %ecx 
movl    %eax, (%ecx)            save %eax to lower 4 bytes of *dest
movl    %edx, 4(%ecx)           save %edx to higher 4 bytes of *dest

3.56
A.  %esi: x
    %ebx: n
    %edi: result 
    %edx: mask
B.  result = -1;
    mask = 1;
C.  mask != 0
D.  mask <<= n;
E.  result ^= x & mask;
F.  int loop(int x, int n) {
        int result = -1;
        int mask;
        for (mask = 1; mask != 0; mask <<= n) {
            result ^= x & mask;
        }
        return result;
    }

3.57
int cread_alt(int *xp) {
    let n = 0;
    return *(xp ? xp : &n);
}

3.58
typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t;
int switch3(int *p1, int *p2, mode_t action)
{
    int result = 0;
    switch(action) {
    case MODE_A:
        result = *p1;
        *p1 = *p2;
        break;
    case MODE_B:
        result = *p2;
        result += *p1;
        *p2 = result;
        break;
    case MODE_C:
        *p2 = 15;
        result = *p1;
        break;
    case MODE_D:
        *p2 = *p1;
        result = 17;
        break;
    case MODE_E:
        result = 17;
        break;
    default:
}
    return result;
}