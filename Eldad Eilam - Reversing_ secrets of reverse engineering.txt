Useful links:
    - https://support.wiley.com/s/article/reversing-secrets-of-reverse-engineering-missing-files
        main archive of book resources
    - https://www.wiley.com/en-us/Reversing%3A+Secrets+of+Reverse+Engineering+-p-9780764574818
        Errata and other book resources 
    - https://www.felixcloutier.com/x86/index.html
        x86_64 instruction reference
    - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
        x86_64 cheat sheet
    - https://wiki.osdev.org/
        OSDev wiki

2. Low-level software
p43, Errata: `char szWelcome` should be `char *szWelcome`
when declared as
    char *szWelcome = " .. "
the string will appear in .data section of the ELF executable, however
    const char *szWelcome = " .. "
will appear in (more approperate) .rodata section of the executable.
both compiled with non-optimizing gcc 8.3.0, content of data sections can be printed with 
    readelf -x [.data|.rodata] <FILE_PATH>

p45, x86_64 architecture additionally have 8 general purpose registers
    r8, r9, .., r15
the corresponding lower 32/16/8-bit register names are 
    r8d, r9d, .., r15d // d -> double (word)
    r8w, r9w, .., r15w // w -> a word, as in Intel 8086, the chip that kicked off x86
    r8b, r9b, .., r15b // b -> byte
the original 8 general purpose registers are extended to 64-bit as
    eax -> rax, ebx -> rbx, ..

p50, another common arithmetic instruction used by most optimized compilers is
    LEA, <mem>, <reg>
which write the _address_ of <mem> to <reg>, because of how expressive x86 memory address
expressions are LEA can be used to compute a multiply and up to two additions as a single operation,
for example 
    LEA, [RBX + RSI * 8], EDI
computes (RBX + 8 * RSI) and store it in EDI

p50, TEST instruction is emitted more frequently by gcc, while CMP performs a subtraction TEST 
performs a bitwise AND on the two operands

the EFLAGS register can be directly manipulated by x86 instructions:
    LAHF:   load flags into AH (9 - 16th least significant bits of RAX)
    SAHF:   set flags into AH
    PUSHF:  push flags onto stack
    POPF:   pop flags from stack into ELFAGS register
interestingly the first two instructions are removed in 64-bit mode for the first few 64-bit product
lines by Intel and AMD but later put back

p53, "DWORD PTR" is a size directive, it indicates the size of the data pointed by the memory
address therefore forces the operand to be treated as a pointer to data of certain size, in this
case
    push DWORD PTR [esp + 0x24]
pushes 32 bit (a DWORD) pointed by [esp + 0x24] to the stack. The four size directives in x86 are
    QWORD (64-bit), DWORD (32-bit), WORD (16-bit) and BYTE (8-bit)

p59, the gcc options producing only non-preprocessed listing file is
    gcc -E -fdirectives-only -o <LISTING_PATH> <SOURCE_PATH>
the rustc options producing assembly file is
    rustc --emit asm -C llvm-args="--x86-asm-syntax=intel" <SOURCE_PATH>

3. Windows Fundamentals
Win32 APIs _used to_ follow a cryptic flavor of the Hungarian notation:
    https://learn.microsoft.com/en-us/windows/win32/learnwin32/windows-coding-conventions

p72, narrator: "He didn't update his book." 
Good news is most of the innovative 64-bit desktop architectures didn't survive the competition.
One of the two modern architecture supported by modern Windows, x86_64, is strictly backward
compatible with x86, hence this book is still relevant after all these years.

p73, the speed gap between drives and physical memory narrowed quite a lot recently, a cutting edge
NVMe SSD operates at 7GB/s reading, only a magnitude lower than high end DDR5 memory (~70GB/s), as a
result SSDs are much more feasible as paging storages now.

p88, found an in-depth explanation of the initialization process, including calls into the native
APIs, but not sure whether it's describing Windows NT or another OS with a similar API since the
author referenced multiple times actual source code paths to these APIs which shouldn't be
available:
    https://www.cs.miami.edu/home/burt/journal/NT/processinit.html

p91, "Microsoft won’t be so concerned about developers using the native API and will soon publish
some level of documentation for it." They didn't.

p91, Zw has no meaning, it's chosen solely to avoid name conflict:
    https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/what-does-the-zw-prefix-mean-

p96, the first method is the ordinary dynamic linking, the second method requires the programmer to
manually load the dll with LoadLibrary then search the header with GetProcAddress, also the callee
must be explicitly exported with __declspec(dllexport) keyword or a DEF file.

p101, reference of PE format:
    https://learn.microsoft.com/en-us/windows/win32/debug/pe-format
Thread Local Storage Table: each thread when initialized is assigned a TLS (Thread Local Storage)
    data area, a TLS index and an entry in the TLS array pointing to its TLS data area, for each
    variable declared as 
        // C
        __declspec (thread) int x = 0;
        // Rust
        thread_local! { 
            // currently immutable only because of lifetime complications
            static x: i32 = 0;
        }
    there's a TLS data object at some fixed offset in the TLS data area, the same binary code
    therefore is able to access different memory location based on the current thread.

p105, that means exception would be thousands of times slower than return code as exception handling
has to go through the system call interface. It's always 

p107, line by line explanation of the code:
00411F8A push   ExceptionHandler
    push the pointer to the exception handler onto stack
00411F8F mov    eax, dword ptr fs:[00000000h]
    fs:[00000000h] fetches location 0x0 from the x86 FS segment instead of the default ds segment
    ([<ADDRESS>] is shorthand of ds:[<ADDRESS>]), the FS segment doesn't have hardware defined
    meaning, in WinNT FS:[0x0] points to the current head of the exception handler list
00411F95 push   eax
    push the old head to the stack
00411F96 mov    dword ptr fs:[0], esp
    stack in x86 grows downwards, the current state of stack is:
        esp+0x0     Ptr32   FS:[0x0] ;old head
        esp+0x4     Ptr32   ExceptionHandler
    thus esp points to a valid _EXCEPTION_REGISTRATN_RECORD struct


p107, again
0411F83 push 0FFFFFFFFh
00411F85 push 425090h
    addresses to two different exception handlers 
00411F8A push offset @ILT+420(__except_handler3) (4111A9h)
    __except_handler3 is part of the C++ runtime, therefore address to it is located in the ILT
    (import lookup table)
00411F8F mov eax,dword ptr fs:[00000000h]
00411F95 push eax
    push old head
00411F96 mov dword ptr fs:[0],esp
    the current state of stack is:
        esp+0x0     Ptr32   FS:[0x0] ;old head
        esp+0x4     Ptr32   __except_handler3
        esp+0x8     Ptr32   425090h
        esp+0xc     Ptr32   0FFFFFFFFh
    __except_handler3 when called would somehow delegate exceptions to the two exception handlers

4. Reversing Tools
The major addition to the tool scene is Ghidra released by NSA in 2019, an open-source and free
alternative to IDA pro. It's a nearly complete toolkit of reverse engineering: disassembly,
decompilation, debugging, patching, header dumping, etc. Its decompiler can incrementally improve
the output on user inputs including type hints, data layouts and loop structure.
Video series using Ghidra to reverse engineer WannaCry ransomware:
    part 1: https://www.youtube.com/watch?v=Sv8yu12y5zM
    part 2: https://www.youtube.com/watch?v=Q90uZS3taG0
    part 3: https://www.youtube.com/watch?v=ru5VzUigKqw

wrestool is a command-line tool to list and extract resources (embedded binaries) from PE
executables.

llvm-readobj from LLVM toolchain is a tool similar to readelf but supports a range of executable
formats, including PE32/PE32+ on WinNT and Mach-O on OSX.

5. Beyond the Documentation
p147, x86 real and protected mode memory segments:
    CS: code segment, pointed by CS register
    DS: data segment, default, points to heap
    SS: stack segment, manipulated by PUSH and POP, pointed by ESP and EBP
    ES: extra segment, used by string instructions (e.g STOS and MOVS)
    FS: no hardware use, points to TIB on 32-bit WinNT
    GS: no hardware use, points to TIB on 64-bit WinNT
on x86_64 however, base of all segments but FS and GS are _ignored_ and treated as 0

p147, Errata: cdecl and stdcall has the same parameter order right-to-left.
https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions
identify x86 calling conventions
cdecl: RET has no operand
    all parameters on stack
    parameters on stack pushed right-to-left
    caller restores stack
fastcall: ECX or EDX are used before initialization in function body
    first two parameters passed in ECX and EDX, rest on stack
    parameters on stack pushed right-to-left
    callee restores the stack
stdcall: RET has operand & is not fastcall
    all parameters on stack
    parameters on stack pushed right-to-left
    callee restores stack
thiscall: always decorated with class name and parameter type
    this pointer passed via ECX
    parameters on stack pushed right-to-left
    callee restores stack
fastcc: anything goes (https://llvm.org/docs/LangRef.html#callingconv)
    calling convention used by LLVM for non-interoperable code, uses _whatever trick_ possible for
    faster code, ABI unstable

x86_64 has only two calling conventions (https://wiki.osdev.org/Calling_Conventions): 
SystemV X86_64 (every platform besides Windows):
    RDI, RSI, RDX, RCX, R8, R9 then stack
    parameters on stack pushed right-to-left
    caller restores stack
    return value in RAX and RDX 
Microsoft x64:
    RCX, RDX, R8, R9 then stack
    parameters on stack pushed right-to-left
    caller restores stack
    return value in RAX 

p147, RtlInitializeGenericTable:
    7C921A39 MOV EDI,EDI
        https://devblogs.microsoft.com/oldnewthing/20110921-00/?p=9583
        a two-byte NOP inserted as a hot-patch point, replaced by a 2-byte jmp instruction when the
        function is hot-patched
    7C921A3B PUSH EBP
    7C921A3C MOV EBP,ESP
        prologue, store and set up ebp
        state of the stack:
            esp+0x0     OLD_EBP
            esp+0x4     RETURN_ADDRESS
            esp+0x8     PARAM_1
            ...
    7C921A3E MOV EAX,DWORD PTR SS:[EBP+8]
        EAX = PARAM_1
    7C921A41 XOR EDX,EDX
        EDX = 0
    7C921A43 LEA ECX,DWORD PTR DS:[EAX+4]
        ECX = PARAM_1 + 0x4
    7C921A46 MOV DWORD PTR DS:[EAX],EDX
        [PARAM_1] = 0
        PARAM_1 is a pointer
    7C921A48 MOV DWORD PTR DS:[ECX+4],ECX
        [PARAM_1+0x8] = PARAM_1 + 0x4
    7C921A4B MOV DWORD PTR DS:[ECX],ECX
        [PARAM_1+0x4] = PARAM_1 + 0x4
    7C921A4D MOV DWORD PTR DS:[EAX+C],ECX
        [PARAM_1+0xC] = PARAM_1 + 0x4
    7C921A50 MOV ECX,DWORD PTR SS:[EBP+C]
    7C921A53 MOV DWORD PTR DS:[EAX+18],ECX
        [PARAM_1+0x18] = PARAM_2
    7C921A56 MOV ECX,DWORD PTR SS:[EBP+10]
    7C921A59 MOV DWORD PTR DS:[EAX+1C],ECX
        [PARAM_1+0x1C] = PARAM_3
    7C921A5C MOV ECX,DWORD PTR SS:[EBP+14]
    7C921A5F MOV DWORD PTR DS:[EAX+20],ECX
        [PARAM_1+0x20] = PARAM_4
    7C921A62 MOV ECX,DWORD PTR SS:[EBP+18]
    7C921A65 MOV DWORD PTR DS:[EAX+14],EDX
        [PARAM_1+0x14] = 0
    7C921A68 MOV DWORD PTR DS:[EAX+10],EDX
        [PARAM_1+0x10] = 0
    7C921A6B MOV DWORD PTR DS:[EAX+24],ECX
        [PARAM_1+0x24] = PARAM_5
    7C921A6E POP EBP
    7C921A6F RET 14
        epilogue
this function initializes a structure that looks like:
    struct TABLE
    {
        UNKNOWN4        Member1; // = 0
        UNKNOWN_PTR32   Member2; // = &Member2
        UNKNOWN_PTR32   Member3; // = &Member2
        UNKNOWN_PTR32   Member4; // = &Member2
        UNKNOWN4        Member5; // = 0
        UNKNOWN4        Member6; // = 0
        UNKNOWN4        Member7; // = PARAM_2
        UNKNOWN4        Member8; // = PARAM_3
        UNKNOWN4        Member9; // = PARAM_4
        UNKNOWN4        Member10; // = PARAM_5
    }
Ghidra is able to automatically deduct the above type definition from the code of
RtlInitializeGenericTable, amazing

p152, RtlNumberGenericTableElements:
    7C923FD2 PUSH EBP
    7C923FD3 MOV EBP,ESP
        prologue
    7C923FD5 MOV EAX,DWORD PTR [EBP+8]
        EAX = PARAM_1
    7C923FD8 MOV EAX,DWORD PTR [EAX+14]
        EAX = *(PARAM_1 + 0x14)
    7C923FDB POP EBP
    7C923FDC RET 4
        EAX is returned
Member6 (PARAM_1 + 0x14) is the number of elements in the table, its type should be UInt32.

p152, RtlIsGenericTableEmpty:
    7C92715B PUSH EBP
    7C92715C MOV EBP,ESP
        prologue
    7C92715E MOV ECX,DWORD PTR [EBP+8]
        ECX = PARAM_1
    7C927161 XOR EAX,EAX
        EAX = 0
    7C927163 CMP DWORD PTR [ECX],EAX
    7C927165 SETE AL
        if (*PARAM_1 == 0) EAX = 1;
    7C927168 POP EBP
    7C927169 RET 4
        return EAX
Member1 is a pointer, non-null when the table has elements.

p154, void* RtlGetElementGenericTable(TABLE *Table, UInt32 index):
    7C9624E0 PUSH EBP
    7C9624E1 MOV EBP,ESP                    ; prologue
    7C9624E3 MOV ECX,DWORD PTR [EBP+8]      ; ECX = Table
    7C9624E6 MOV EDX,DWORD PTR [ECX+14]     ; EDX = Table->TotalElements
    7C9624E9 MOV EAX,DWORD PTR [ECX+C]      ; EAX = Table->LastElementFound
    7C9624EC PUSH EBX
    7C9624ED PUSH ESI                       ; callee saved registers
    7C9624EE MOV ESI,DWORD PTR [ECX+10]     ; ESI = Table->LastIndexFound
    7C9624F1 PUSH EDI                       ; callee saved registers
    7C9624F2 MOV EDI,DWORD PTR [EBP+C]      ; EDI = index
    7C9624F5 CMP EDI,-1
    7C9624F8 LEA EBX,DWORD PTR [EDI+1]      ; EBX = index + 1
    7C9624FB JE SHORT ntdll.7C962559        ; SHORT i.e. intramodule jump
                                            ; if (index == 0xFFFFFFFF)
                                            ;   jump to error_exit
    7C9624FD CMP EBX,EDX                    ; if (index + 1 > Table->TotalElements)
    7C9624FF JA SHORT ntdll.7C962559        ;   jump to error_exit
    7C962501 CMP ESI,EBX                    ; if (Table->LastIndexFound == index + 1) {
    7C962503 JE SHORT ntdll.7C962554        ;   jump to skip_header
                                            ; if (Table->LastIndexFound < index + 1) {
    7C962505 JBE SHORT ntdll.7C96252B       ;   jump to forward_search_1
    7C962507 MOV EDX,ESI                    ; EDX = Table->LastIndexFound
    7C962509 SHR EDX,1                      ; EDX = Table->LastIndexFound / 2
    7C96250B CMP EBX,EDX                    ; if (index + 1 <= Table->LastIndexFound / 2)
    7C96250D JBE SHORT ntdll.7C96251B       ;   jump to forward_search_2
    7C96250F SUB ESI,EBX                    ; ESI = Table->LastIndexFound - index - 1
                                            ; if (Table->LastIndexFound == index + 1)
    7C962511 JE SHORT ntdll.7C96254E        ;   jump to set_cache
loop_1:                                     ; while (ESI > 0) {
    7C962513 DEC ESI                        ;   ESI = ESI - 1
    7C962514 MOV EAX,DWORD PTR [EAX+4]      ;   EAX = EAX->PrevElement
                                            ; Table->LastElementFound points to a 3-pointer header structure, 
                                            ; EAX+0x4 points to the second entry of the 3 pointers,
                                            ; these structures form a linked list 
    7C962517 JNZ SHORT ntdll.7C962513       ; }
    7C962519 JMP SHORT ntdll.7C96254E       ; jump to set_cache
forward_search_2:
    7C96251B TEST EBX,EBX                   
    7C96251D LEA EAX,DWORD PTR [ECX+4]      ; EAX = Table->LastElement
    7C962520 JE SHORT ntdll.7C96254E        ; if (index + 1 == 0) jump to set_cache
    7C962522 MOV EDX,EBX                    ; EDX = index + 1
loop_4:                                     ; while (EDX > 0) {
    7C962524 DEC EDX                        ;   EDX -= 1
    7C962525 MOV EAX,DWORD PTR [EAX]        ;   EAX = EAX->NextElement
    7C962527 JNZ SHORT ntdll.7C962524       ; follow the first pointer in 3-pointer header
                                            ; the linked list must be circular
                                            ; } 
    7C962529 JMP SHORT ntdll.7C96254E       ; jump to set_cache
forward_search_1:
    7C96252B MOV EDI,EBX                    ; EDI = index + 1
    7C96252D SUB EDX,EBX                    ; EDX = Table->TotalElements - index - 1
    7C96252F SUB EDI,ESI                    ; EDI = index + 1 - Table->LastIndexFound
                                            ; distance from index to the last found element
    7C962531 INC EDX                        ; EDX = Table->TotalElements - index
                                            ; distance from index to the last element in table
    7C962532 CMP EDI,EDX                    ; if (EDI > EDX)
    7C962534 JA SHORT ntdll.7C962541        ;   jump to backward_search_1
    7C962536 TEST EDI,EDI                   ; if (EDI == 0)
    7C962538 JE SHORT ntdll.7C96254E        ;   jump to set_cache
loop_3:                                     ; while (EDI > 0) {
    7C96253A DEC EDI                        ;   EDI -= 1
    7C96253B MOV EAX,DWORD PTR [EAX]        ;   EAX = EAX->NextElement
                                            ; follow the first pointer in the 3-pointer structure
    7C96253D JNZ SHORT ntdll.7C96253A       ; }
    7C96253F JMP SHORT ntdll.7C96254E       ; jump to set_cache
backward_search_1;
    7C962541 TEST EDX,EDX                   
    7C962543 LEA EAX,DWORD PTR [ECX+4]      ; EAX = Table->LastElement
    7C962546 JE SHORT ntdll.7C96254E        ; if (EDX == 0) jump to set_cache
loop_2:                                     ; while (EDX > 0) {
    7C962548 DEC EDX                        ;   EDX -= 1;
    7C962549 MOV EAX,DWORD PTR [EAX+4]      ;   EAX = EAX->PrevElement
    7C96254C JNZ SHORT ntdll.7C962548       ; follow the second pointer in the 3-pointer header
                                            ; }
set_cache:
    7C96254E MOV DWORD PTR [ECX+C],EAX      ; Table->LastElementFound = EAX
    7C962551 MOV DWORD PTR [ECX+10],EBX     ; Table->LastIndexFound = EBX
skip_header:
    7C962554 ADD EAX,0C                     ; EAX = EAX + 0xC, skips the 3-pointer header
    7C962557 JMP SHORT ntdll.7C96255B       ; jump to exit
error_exit:
    7C962559 XOR EAX,EAX                    ; EAX = NULL
exit:
    7C96255B POP EDI                        ; epilogue
    7C96255C POP ESI                        ; restore callee saved registers
    7C96255D POP EBX                        
    7C96255E POP EBP                        
    7C96255F RET 8                          
high level description of void* RtlGetElementGenericTable(TABLE *Table, UInt32 index):
    if index + 1 is in range [0, Table->LastIndexFound / 2]:
        traverse forward from Table->LastElement
    if index + 1 is in range (Table->LastIndexFound / 2, Table->LastIndexFound]:
        traverse backward from Table->LastElementFound
    if index + 1 is in range (Table->LastIndexFound, Table->TotalElements]:
        if index + 1 is closer to Table->LastIndexFound:
            traverse forward from Table->LastElementFound
        if index + 1 is closer to Table->TotalElements
            traverse backward from Table->LastElement
    set Table->LastElementFound, Table->LastIndexFound to the search results
    return pointer to the data section of the listed list node found

p169, UNKNOWN4 RtlInsertElementGenericpTable {
    TABLE *pTable,
    PVOID ElementData,
    UInt32 ElementLength,
    UInt8 *pResult,
}
    7C924DC0 PUSH EBP                   ; prologue
    7C924DC1 MOV EBP,ESP            
    7C924DC3 PUSH EDI
    7C924DC4 MOV EDI,DWORD PTR [EBP+8]  ; EDI = pTable, 1st parameter
    7C924DC7 LEA EAX,DWORD PTR [EBP+8]  ; EAX = EBP + 0x8
    7C924DCA PUSH EAX                   ; 3rd parameter
    7C924DCB PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C924DCE CALL ntdll.7C92147B
    7C924DD3 PUSH EAX                   ; return value, 6th parameter
    7C924DD4 PUSH DWORD PTR [EBP+8]     ; mutated by ntdll.7C92147B, 5th parameter
    7C924DD7 PUSH DWORD PTR [EBP+14]    ; pResult, 4th parameter
    7C924DDA PUSH DWORD PTR [EBP+10]    ; ElementLength, 3rd parameter
    7C924DDD PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C924DE0 PUSH EDI                   ; pTable, 1st parameter
    7C924DE1 CALL ntdll.7C924DF0        ; return value returned
    7C924DE6 POP EDI                    ; epilogue
    7C924DE7 POP EBP
    7C924DE8 RET 10

p171, int RtlLocateNodeGenericpTable(
    TABLE *pTable, 
    PVOID DataToLocate, 
    NODE **ppNodeFound
)
                                        ; EDI = pTable, passed in register
    7C92147B MOV EDI,EDI                ; hot patch point
    7C92147D PUSH EBP                   ; prologue
    7C92147E MOV EBP,ESP
    7C921480 PUSH ESI
    7C921481 MOV ESI,DWORD PTR [EDI]    ; pNode = pTable->Root
    7C921483 TEST ESI,ESI               ; if (pTable->Root == NULL)
    7C921485 JE ntdll.7C924E8C          ;   jump to error
loop_1:                                 
                                        ; pNode is changed every loop
    7C92148B LEA EAX,DWORD PTR [ESI+18] ; EAX = pNode->data
    7C92148E PUSH EAX                   ; 3rd parameter
    7C92148F PUSH DWORD PTR [EBP+8]     ; DataToLocate, 2nd parameter
    7C921492 PUSH EDI                   ; pTable, 1st parameter
    7C921493 CALL DWORD PTR [EDI+18]    ; pTable->Comparator (Member_7)
    7C921496 TEST EAX,EAX               ; if (comparison_result == 0)
    7C921498 JE ntdll.7C924F14          ;   jump to right_branch
    7C92149E CMP EAX,1                  ; if (comparison_result != 1)
    7C9214A1 JNZ SHORT ntdll.7C9214BB   ;   jump to set_ret_1
    7C9214A3 MOV EAX,DWORD PTR [ESI+8]  ; EAX = pNode->LeftChild
    7C9214A6 TEST EAX,EAX               ; if (EAX != NULL)
    7C9214A8 JNZ ntdll.7C924F22         ;   jump to follow_right_branch
    7C9214AE PUSH 3
pop_ret:
    7C9214B0 POP EAX                    ; possible return values are 0, 1, 2, 3
                                        ; 0: error code
                                        ; 1: equal
                                        ; 2: greater (DataToLocate > pNode->data)
                                        ; 3: lesser
set_out_var:
    7C9214B1 MOV ECX,DWORD PTR [EBP+C]  ; ECX = ppNodeFound
    7C9214B4 MOV DWORD PTR [ECX],ESI    ; *ppNodeFound = pNode
exit:
    7C9214B6 POP ESI                    ; epilogue
    7C9214B7 POP EBP
    7C9214B8 RET 8
set_ret_1:
    7C9214BB XOR EAX,EAX
    7C9214BD INC EAX                    ; EAX = 1
    7C9214BE JMP SHORT ntdll.7C9214B1   ; jump to set_out_var
error:
    7C924E8C XOR EAX,EAX                ; EAX = 0
    7C924E8E JMP ntdll.7C9214B6         ; jump to exit
right_branch:
    7C924F14 MOV EAX,DWORD PTR [ESI+4]  ; EAX = pNode->RightChild
    7C924F17 TEST EAX,EAX               ; if (EAX != NULL)
    7C924F19 JNZ SHORT ntdll.7C924F22   ;   jump to follow_right_branch
    7C924F1B PUSH 2
    7C924F1D JMP ntdll.7C9214B0         ; jump to pop_ret
follow_right_branch:
    7C924F22 MOV ESI,EAX                ; pNode = pNode->RightChild
    7C924F24 JMP ntdll.7C92148B         ; jump to loop_1

p180, RtlRealInsertElementWorker
UNKNOWN RtlRealInsertElementWorker {
    TABLE *pTable,
    PVOID ElementData,
    UInt32 ElementSize,
    UInt8 *pResult,
    NODE *pNode,
    UInt32 SearchResult,
}
    7C924DF0 MOV EDI,EDI                ; prologue
    7C924DF2 PUSH EBP                   
    7C924DF3 MOV EBP,ESP
    7C924DF5 CMP DWORD PTR [EBP+1C],1   
    7C924DF9 PUSH EBX
    7C924DFA PUSH ESI
    7C924DFB PUSH EDI
    7C924DFC JE ntdll.7C935D5D          ; if (SearchResult == 1)
                                        ;   jump to splay_parent
    7C924E02 MOV EDI,DWORD PTR [EBP+10] ; EDI = ElementSize
    7C924E05 MOV ESI,DWORD PTR [EBP+8]  ; ESI = pTable
    7C924E08 LEA EAX,DWORD PTR [EDI+18] ; EAX = ElementSize + 0x18
                                        ; 0x18 is size of node header? 
    7C924E0B PUSH EAX                   ; ElementSize + 0x18, 2nd parameter
    7C924E0C PUSH ESI                   ; pTable, 1st parameter
    7C924E0D CALL DWORD PTR [ESI+1C]    ; pTable->Allocator (Member 8)
    7C924E10 MOV EBX,EAX                ; EBX = (Node *)return_value
    7C924E12 TEST EBX,EBX               ; if (node == NULL)
    7C924E14 JE ntdll.7C94D4BE          ;   jump to set_presult_false
    7C924E1A AND DWORD PTR [EBX+4],0    ; *(EBX + 0x4) = 0u32
    7C924E1E AND DWORD PTR [EBX+8],0    ; *(EBX + 0x8) = 0u32
    7C924E22 MOV DWORD PTR [EBX],EBX    ; *EBX = EBX
    7C924E24 LEA ECX,DWORD PTR [ESI+4]  ; ECX = &pTable->LLHead
    7C924E27 MOV EDX,DWORD PTR [ECX+4]  ; EDX = pTable->Member3
    7C924E2A LEA EAX,DWORD PTR [EBX+C]  ; EAX = EBX + 0xC
    7C924E2D MOV DWORD PTR [EAX],ECX    ; *(EBX + 0xC) = &pTable->LLHead
    7C924E2F MOV DWORD PTR [EAX+4],EDX  ; *(EBX + 0x10) = pTable->Member3
    7C924E32 MOV DWORD PTR [EDX],EAX    ; *pTable->Member3 = EBX + 0xC
    7C924E34 MOV DWORD PTR [ECX+4],EAX  ; pTable->Member3 = EBX + 0xC
    7C924E37 INC DWORD PTR [ESI+14]     ; pTable->TotalElements += 1
    7C924E3A CMP DWORD PTR [EBP+1C],0   ; if (SearchResult == 0)
    7C924E3E JE SHORT ntdll.7C924E88    ;   jump to set_root
    7C924E40 CMP DWORD PTR [EBP+1C],2
    7C924E44 MOV EAX,DWORD PTR [EBP+18] ; EAX = pNode
    7C924E47 JE ntdll.7C924F0C          ; if (SearchResult == 2)
                                        ;   jump to right_child
    7C924E4D MOV DWORD PTR [EAX+8],EBX  ; pNode->LeftChild = EBX
set_parent:
    7C924E50 MOV DWORD PTR [EBX],EAX    ; EBX->Parent = pNode
memcpy:
    7C924E52 MOV ESI,DWORD PTR [EBP+C]  ; ESI = ElementData
    7C924E55 MOV ECX,EDI
    7C924E57 MOV EAX,ECX                ; EAX = ElementSize
    7C924E59 SHR ECX,2                  ; ECX = ElementSize / 4
    7C924E5C LEA EDI,DWORD PTR [EBX+18] ; EDI = &pNode->data
    7C924E5F REP MOVS DWORD PTR ES:[EDI],DWORD PTR [ESI]
                                        ; for (; ECX > 0; ECX--) {
                                        ;   *(UInt32 *)EDI = *(UInt32 *)ESI
                                        ;   EDI += 4
                                        ;   ESI += 4
                                        ; }
    7C924E61 MOV ECX,EAX
    7C924E63 AND ECX,3                  ; ECX = ElementSize % 4
    7C924E66 REP MOVS BYTE PTR ES:[EDI],BYTE PTR [ESI]
                                        ; for (; ECX > 0; ECX--) {
                                        ;   *EDI = *(BYTE *)ESI
                                        ;   EDI += 1
                                        ;   ESI += 1
                                        ; }
    7C924E68 PUSH EBX                   ; pNewNode, 1st paremter
call_splay:
    7C924E69 CALL ntdll.RtlSplay        ; EAX = RETURN_VALUE
    7C924E6E MOV ECX,DWORD PTR [EBP+8]  ; ECX = pTable
    7C924E71 MOV DWORD PTR [ECX],EAX    ; pTable->Root = RETURN_VALUE
    7C924E73 MOV EAX,DWORD PTR [EBP+14] ; EAX = pResult
    7C924E76 TEST EAX,EAX               ; if (pResult != NULL)
    7C924E78 JNZ ntdll.7C935D4F         ;   jump to set_presult_true
set_return_value:
    7C924E7E LEA EAX,DWORD PTR [EBX+18] ; EAX = pNewNode->data
exit:
    7C924E81 POP EDI                    ; epilogue
    7C924E82 POP ESI
    7C924E83 POP EBX
    7C924E84 POP EBP
    7C924E85 RET 18
set_root:
    7C924E88 MOV DWORD PTR [ESI],EBX    ; pTable->Root = EBX
    7C924E8A JMP SHORT ntdll.7C924E52   ; jump to memcpy
    7C924E8C XOR EAX,EAX
    7C924E8E JMP ntdll.7C9214B6
right_child:
    7C924F0C MOV DWORD PTR [EAX+4],EBX  ; pNode->RightChild = EBX
    7C924F0F JMP ntdll.7C924E50         ; jump to set_parent
splay_parent:
    ; not given
    ; set EBX = pNode then jump to call_splay
set_presult_true:
    ; not given
    ; set *pResult = TRUE then jump to set_return_value
set_presult_false:
    7C94D4BE MOV EAX,DWORD PTR [EBP+14] ; EAX = pResult
    7C94D4C1 TEST EAX,EAX               ; if (pResult == NULL)
    7C94D4C3 JE SHORT ntdll.7C94D4C7    ;   jump to return_null
    7C94D4C5 MOV BYTE PTR [EAX],BL      ; *pResult = FALSE
return_null:
    7C94D4C7 XOR EAX,EAX                ; EAX = NULL
    7C94D4C9 JMP ntdll.7C924E81         ; jump to exit

p185, Errata: ECX = ElementSize / 4

p190, RtlLookupElementGenericTable
    7C9215BB PUSH EBP                   ; prologue
    7C9215BC MOV EBP,ESP 
    7C9215BE LEA EAX,DWORD PTR [EBP+C]  ; EAX = EBP + 0xC
    7C9215C1 PUSH EAX                   ; 4th parameter, output
    7C9215C2 LEA EAX,DWORD PTR [EBP+8]  ; EAX = EBP + 0x8
    7C9215C5 PUSH EAX                   ; 3rd parameter, output
    7C9215C6 PUSH DWORD PTR [EBP+C]     ; PARAM_2, 2nd parameter
    7C9215C9 PUSH DWORD PTR [EBP+8]     ; PARAM_1, 1st parameter
    7C9215CC CALL ntdll.7C9215DA        
    7C9215D1 POP EBP                    ; epilogue
    7C9215D2 RET 8

p192, ntdll.7C9215DA
PVOID RtlLookupElementGenericTableWorker(
    TABLE *pTable,
    PVOID ElementData, 
    NODE **ppNode,
    int *SearchResult,
)
    7C9215DA MOV EDI,EDI                ; prologue
    7C9215DC PUSH EBP           
    7C9215DD MOV EBP,ESP
    7C9215DF PUSH ESI
    7C9215E0 MOV ESI,DWORD PTR [EBP+10] ; ESI = ppNode
    7C9215E3 PUSH EDI
    7C9215E4 MOV EDI,DWORD PTR [EBP+8]  ; EDI = pTable, 1st parameter
    7C9215E7 PUSH ESI                   ; ppNode, 3rd parameter
    7C9215E8 PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C9215EB CALL ntdll.7C92147B        ; RtlLocateNodeGenericpTable
    7C9215F0 TEST EAX,EAX
    7C9215F2 MOV ECX,DWORD PTR [EBP+14] ; ECX = SearchResult
    7C9215F5 MOV DWORD PTR [ECX],EAX    ; *SearchResult = RETURN_VALUE
    7C9215F7 JE SHORT ntdll.7C9215FE    ; if (RETURN_VALUE == 0)
                                        ;   jump to return_null
    7C9215F9 CMP EAX,1                  ; if (RETURN_VALUE == 1)
    7C9215FC JE SHORT ntdll.7C921606    ;   jump to splay
return_null:
    7C9215FE XOR EAX,EAX                ; EAX = NULL
exit:
    7C921600 POP EDI                    ; epilogue
    7C921601 POP ESI
    7C921602 POP EBP
    7C921603 RET 10
splay:
    7C921606 PUSH DWORD PTR [ESI]       ; ppNode, 1st parameter
    7C921608 CALL ntdll.RtlSplay
    7C92160D MOV DWORD PTR [EDI],EAX    ; pTable->Root = RETURN_VALUE
    7C92160F MOV EAX,DWORD PTR [ESI]
    7C921611 ADD EAX,18                 ; EAX = *ppNode + 0x18
                                        ; points to data section
    7C921614 JMP SHORT ntdll.7C921600   ; jump to exit

p193, BOOLEAN RtlDeleteElementGenericTable(
    TABLE *pTable,
    PVOID ElementData,
)
    7C924FFF MOV EDI,EDI                ; prologue
    7C925001 PUSH EBP
    7C925002 MOV EBP,ESP
    7C925004 PUSH EDI
    7C925005 MOV EDI,DWORD PTR [EBP+8]  ; EDI = pTable, 1st parameter
    7C925008 LEA EAX,DWORD PTR [EBP+C]  ; EAX = &ElementData
    7C92500B PUSH EAX                   ; 3rd parameter
    7C92500C PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C92500F CALL ntdll.7C92147B        ; RtlLocateNodeGenericpTable
                                        ; ElementData is overwritten with parent node header 
                                        ; rename ElementData -> pNode
                                        ; there's a 0x18 byte minimal length requirement for data?
    7C925014 TEST EAX,EAX               ; if (searchResult == 0)
    7C925016 JE SHORT ntdll.7C92504E    ;   jump to not_found
    7C925018 CMP EAX,1                  ; if (searchResult != 1)
    7C92501B JNZ SHORT ntdll.7C92504E   ;   jump to not_found
    7C92501D PUSH ESI                   ; 
    7C92501E MOV ESI,DWORD PTR [EBP+C]  ; ESI = pNode
    7C925021 PUSH ESI                   ; 2nd parameter 
    7C925022 CALL ntdll.RtlDelete       ; pTable passed in register
                                        ; returns root after splay
    7C925027 MOV DWORD PTR [EDI],EAX    ; pTable->Root = root
                                        ; remove current node from linked list
    7C925029 MOV EAX,DWORD PTR [ESI+C]  ; EAX = pNode->LLEntry->NextElement
    7C92502C MOV ECX,DWORD PTR [ESI+10] ; ECX = pNode->LLEntry->PrevElement
    7C92502F MOV DWORD PTR [ECX],EAX    ; *pNode->LLEntry->PrevElement = pNode->LLEntry->NextElement
    7C925031 MOV DWORD PTR [EAX+4],ECX  ; *pNode->LLEntry->NextElement->PrevElement = pNode->LLEntry->PrevElement
    7C925034 DEC DWORD PTR [EDI+14]     ; pTable->TotalElements -= 1
    7C925037 AND DWORD PTR [EDI+10],0   ; pTable->LastIndexFound = 0
    7C92503B PUSH ESI                   ; ElementData, 2nd parameter
    7C92503C LEA EAX,DWORD PTR [EDI+4]  
    7C92503F PUSH EDI                   ; pTable, 1st parameter
    7C925040 MOV DWORD PTR [EDI+C],EAX
    7C925043 CALL DWORD PTR [EDI+20]    ; pTable->Deallocator
    7C925046 MOV AL,1                   ; EAX = TRUE
exit_1:
    7C925048 POP ESI                    ; epilogue
exit_2:
    7C925049 POP EDI
    7C92504A POP EBP
    7C92504B RET 8
not_found:
    7C92504E XOR AL,AL                  ; EAX = FALSE
    7C925050 JMP SHORT ntdll.7C925049   ; jump to exit_2

continuously updated type definitions:
struct TABLE
{
    Node            *Member1;
    ListEntry       LLHead;
    ListEntry       *LastElementFound;
    UInt32          *LastIndexFound;
    UInt32          TotalElements;
    Comparator      *Comparator;
    Allocator       *Allocator;
    Deallocator     *Deallocator;
    UNKNOWN4        Member10;
}
struct ListEntry {
    ListEntry       *NextElement;
    ListEntry       *PrevElement;
}
struct Node {
    Node            *Parent;        // 0x0
    Node            *RightChild;    // 0x4
    Node            *LeftChild;     // 0x8
    ListEntry       LLEntry;        // 0xC
    UNKNOWN4        PARAM_5;        // 0x14
    char            data[];         // 0x18
}
// return value of Comparator is very likely an enum
// enum Ordering {
//  GT = 0;
//  LT = 1;
//  EQ = 2;
// }
typedef UInt32 (* Comparator)(TABLE *, PVOID, PVOID);
typedef PVOID (* Allocator)(TABLE *, UInt32);
typedef void (* Deallocator)(TABLE *, PVOID);

6. Deciphering File Formats
OllyDbg discontinued around 2014, the planned x64 support was never finished. x64dbg is what's
closest to a modern OllyDbg alternative on the market.  homepage: https://x64dbg.com/

p211, with the help of a feature rich reverse engineering toolkit it's easy to arrive at the same
conclusion. Ghidra for example can list all embedded strings and their memory location, which leads
to all the locations these strings are cross referenced.
Ghidra decompilation of Listing 6.4:
---CODE START---
BOOL __cdecl HashHeader(BYTE *src,BYTE *dst)

{
  BOOL ok;
  HCRYPTHASH phHash;
  DWORD dataLen;
  
  ok = CryptCreateHash((HCRYPTPROV)CRYPT_PROVIDER,CALG_MD5,0,0,&phHash);
  if (ok != FALSE) {
    ok = CryptHashData(phHash,src,0x14,0);
    if (ok != FALSE) {
      dataLen = 0x10;
      ok = CryptGetHashParam(phHash,2,dst,&dataLen,0);
      CryptDestroyHash(phHash);
      return ok;
    }
    CryptDestroyHash(phHash);
  }
  return 0;
}
---CODE END---

p214, Ghidra decompilation of Listing 6.5
---CODE START---
HCRYPTKEY __cdecl DeriveKeyFromPassword(HCRYPTPROV cryptProvider,BYTE *password)

{
  BOOL createHash_ok;
  BYTE *passwordEnd;
  BOOL hashDataOk;
  BOOL getHashParamOk;
  BOOL hashHeaderOk;
  HCRYPTKEY dummyKey;
  HCRYPTHASH hHash;
  HCRYPTKEY key;
  DWORD dataLen;
  BYTE hashVal [20];
  BYTE c;
  dword cookie;
                    /* initial value set to BB40E64Eh (3141592654, PI) */
  cookie = COOKIE;
  createHash_ok = CryptCreateHash(cryptProvider,CALG_SHA,0,0,&hHash);
  if (createHash_ok != FALSE) {
                    /* strlen */
    passwordEnd = password;
    do {
      c = *passwordEnd;
      passwordEnd = passwordEnd + 1;
    } while (c != '\0');
    hashDataOk = CryptHashData(hHash,password,(int)passwordEnd - (int)(password + 1),0);
    if (hashDataOk != 0) {
                    /* memset 0, unrolled */
      hashVal._1_4_ = 0;
      hashVal._5_4_ = 0;
      hashVal._9_4_ = 0;
      hashVal._13_4_ = 0;
      hashVal._17_2_ = 0;
      hashVal[19] = 0;
      hashVal[0] = 0;
      dataLen = 0x14;
      getHashParamOk = CryptGetHashParam(hHash,HP_HASHVAL,hashVal,&dataLen,0);
      if (getHashParamOk == 0) {
        printf("Unable to obtain MD5 hash value for file.\n");
      }
      hashHeaderOk = HashHeader(hashVal,HASH_BUFFER);
      if (hashHeaderOk != 0) {
        key = 0;
        CryptDeriveKey(cryptProvider,CALG_3DES,hHash,0,&key);
        CryptDestroyHash(hHash);
                    /* buffer overrun check */
        OverrunCheck(cookie);
        return key;
      }
    }
    CryptDestroyHash(hHash);
  }
  dummyKey = 0;
  OverrunCheck(cookie);
  return dummyKey;
}
---CODE END---

p219, decompilation of 0x004019F0:
---CODE START---
int __cdecl ListFilesInArchive(HANDLE hArchive,HCRYPTKEY key,int *totalClusters)

{
  int filesListed;
  BYTE *pByte;
  BYTE *pCluster;
  dword entries;
  DWORD clusterNumber;
  
  filesListed = 0;
  SetFilePointer(hArchive,0,(PLONG)NULL,FILE_BEGIN);
  ReadFile(hArchive,HEADER_BUFFER,0x28,&entries,(LPOVERLAPPED)NULL);
                    /* header 0xc: the first-cluster index */
  DecryptCluster(hArchive,HEADER_BUFFER._12_4_,key);
  clusterNumber = HEADER_BUFFER._12_4_;
  pCluster = CLUSTER_BUFFER;
  printf("\n   File Size    File Name\n");
  while( true ) {
    if (clusterNumber == 0) {
                    /* no block may have id = 0, must be NULL termination */
      return filesListed;
    }
                    /* first (size, file_name) entry starts at 0x8 */
    pByte = (BYTE *)((int)pCluster + 8);
    entries = 0x1a;
    do {
                    /* empty file entry is indicated by 0 number of clusters occupied */
      if (*(int *)pByte != 0) {
                    /* 0x0: 4-byte number of clusters occupied
                       0x4: ??
                       0x8: ??
                       0x14: file name
                       
                       8 bytes in each cluster is reserved by next/prev pointers? */
        printf(" %10dK    %s\n",(uint)(*(int *)pByte * (0x1008 - 0x8)) >> 10,pByte + 0x14);
        *totalClusters = *totalClusters + *(int *)pByte;
        filesListed = filesListed + 1;
      }
                    /* each entry is 0x98 (152) bytes in length
                       0x1a (26) is the biggest number of entries fits in a cluster */
      pByte = pByte + 0x98;
      entries = entries - 1;
    } while (entries != 0);
                    /* pointer to the next cluster in the file list */
    clusterNumber = *(DWORD *)pCluster;
    if (clusterNumber == 0) break;
    pCluster = DecryptCluster(hArchive,clusterNumber,key);
  }
  return filesListed;
}
---CODE END---

p221, decompilation of 0x00401030:
---CODE START---
BYTE * __cdecl DecryptCluster(HANDLE hArchive,DWORD clusterNumber,HCRYPTKEY key)

{
  uint lowLen;
  BOOL ok;
  DWORD bytesRead;
  DWORD clusterNo;
  longlong highLen;
  
                    /* the id of 0x1008 byte chunks */
  clusterNo = clusterNumber;
                    /* badly decompiled multiplication */
  highLen = (ulonglong)(clusterNumber - 1) * 0x1008;
  lowLen = (uint)highLen;
  clusterNumber = (int)((ulonglong)highLen >> 32) + (uint)(0xffffffd7 < lowLen);
                    /* set to (clusterNumber - 1) * 0x1008 + 0x28 */
  SetFilePointer(hArchive,lowLen + 0x28,(PLONG)&clusterNumber,FILE_BEGIN);
  ok = ReadFile(hArchive,CLUSTER_BUFFER,0x1008,&bytesRead,(LPOVERLAPPED)NULL);
  if (ok == FALSE) {
    return (BYTE *)NULL;
  }
  clusterNumber = 0x1008;
  if (key != NULL) {
    ok = CryptDecrypt(key,0,TRUE,0,CLUSTER_BUFFER,&clusterNumber);
    if (ok == FALSE) {
      GetLastError();
      printf("ERROR: Unable to decrypt block from cluster %d.\n",clusterNo);
                    /* WARNING: Subroutine does not return */
      exit(1);
    }
  }
  return CLUSTER_BUFFER;
}
---CODE END---

p233, decompilation of 00401670 is rather messy, it checks if an archive file of the same base name
exists (extension is implicit wrt. cryptex CLI), if true checks the password stored in the archive,
if not it reports error or creates a new archive with the given password according to 3rd
(allowWrite?) and 4th (allowCreate?) parameters: In the extract scenario both 3rd and 4th parameters
are set to 0 (FALSE). Return value is a file handle to the archive file.

p228, decompilation of 0x00401BB0
--- CODE START---
/* WARNING: Could not reconcile some variable overlaps */

void __cdecl ExtractFileFromArchive(char *archivePath,char *fileName,HCRYPTKEY key)

{
  dword cookie_00;
  HANDLE hArchive;
  BOOL ok;
  DWORD fileCluster;
  char *pDirSep;
  int iVar1;
  int *piVar2;
  uint fileClusterCount;
  int *piVar3;
  bool bVar4;
  DWORD clusterNumber;
  HANDLE hOut;
  char *baseName;
  HCRYPTHASH hHash;
  float percentPerCluster;
  DWORD hashLen;
  DWORD DStack88;
  _CONSOLE_SCREEN_BUFFER_INFO screenInfo;
  _CONSOLE_SCREEN_BUFFER_INFO _Stack60;
  BYTE hashVal [16];
  BYTE fileHash [16];
  DWORD cookie;
  DWORD dataLen;
  float fClusterCount;
  
  cookie_00 = __security_cookie;
  hArchive = CheckArchivePasswordOrCreate(key,archivePath,FALSE,FALSE);
  ok = CryptCreateHash(CRYPT_PROVIDER,CALG_MD5,0,0,&hHash);
  if (ok == FALSE) {
    printf("Unable to verify the file\'s hash value!\n");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  SetFilePointer(hArchive,0,(PLONG)NULL,FILE_BEGIN);
  ReadFile(hArchive,HEADER_BUFFER,0x28,(LPDWORD)&percentPerCluster,(LPOVERLAPPED)NULL);
                    /* initializing a struct? */
  fileHash._1_4_ = 0;
  fileHash._5_4_ = 0;
  fileHash._9_4_ = 0;
  fileHash._13_2_ = 0;
  clusterNumber = 0;
  hOut = fileName;
  fileHash[0] = '\0';
  fileHash[15] = '\0';
  fileCluster = LocateFile(hArchive,fileName,&clusterNumber,(DWORD *)fileHash,key);
  fileClusterCount = clusterNumber;
                    /* extract basename */
  baseName = fileName;
  pDirSep = strchr(fileName,L'\\');
  while (pDirSep != (char *)0x0) {
    baseName = pDirSep + 1;
    pDirSep = strchr(baseName,L'\\');
  }
  if (fileCluster == 0) {
    printf("File \"%s\" not found in archive.\n");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
                    /* first parameter should be basename */
  hOut = CreateFileA((LPCSTR)hOut,GENERIC_READ | GENERIC_WRITE,0,(LPSECURITY_ATTRIBUTES)0x0,2,0,
                     (HANDLE)NULL);
  if (hOut == (HANDLE)INVALID_HANDLE_VALUE) {
    GetLastError();
    printf("ERROR: Unable to create file \"%s\" (Last Error=%d).\n");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  DecryptCluster(hArchive,fileCluster,key);
  fClusterCount = (float)fileClusterCount;
  if ((int)fileClusterCount < 0) {
    fClusterCount = fClusterCount + 4.294967e+09;
  }
  percentPerCluster = 100.0 / fClusterCount;
  clusterNumber = 0;
  printf("Extracting \"%.35s\" - ",baseName);
  while (fileClusterCount != 0) {
    GetConsoleScreenBufferInfo(CONSOLE_SCREEN_BUFFER_HANDLE,&screenInfo);
    printf("%2.2f percent completed.");
                    /* the last cluster may not be full
                       cluster+0x0 is the actual data size of the cluster
                       a full cluster has 0xffc bytes of data
                       0x1008 - 0xffc = 12 bytes of header */
    dataLen = 0xffc;
    if (fileClusterCount < 2) {
      dataLen = CLUSTER_BUFFER._0_4_;
    }
    ok = CryptHashData(hHash,CLUSTER_BUFFER + 4,dataLen,0);
    if (ok == FALSE) {
      printf("Unable to verify the file\'s hash value!\n");
                    /* WARNING: Subroutine does not return */
      exit(1);
    }
    dataLen = 0xffc;
    if (fileClusterCount < 2) {
      dataLen = CLUSTER_BUFFER._0_4_;
    }
    WriteFile(hOut,CLUSTER_BUFFER + 4,dataLen,&DStack88,(LPOVERLAPPED)0x0);
    fileClusterCount = fileClusterCount - 1;
    if (fileClusterCount != 0) {
                    /* when not last cluster of a file, 0x0 is the pointer to the next cluster
                       otherwise 0x0 is the number of actual data size of the current cluster */       
      DecryptCluster(hArchive,CLUSTER_BUFFER._0_4_,key);
    }
                    /* update progress percentage after each cluster */
    GetConsoleScreenBufferInfo(CONSOLE_SCREEN_BUFFER_HANDLE,&_Stack60);
    SetConsoleCursorPosition(CONSOLE_SCREEN_BUFFER_HANDLE,screenInfo.dwCursorPosition);
    clusterNumber = (DWORD)((float)clusterNumber + percentPerCluster);
  }
  printf("%2.2f percent completed.");
  printf("\n");
  hashVal._1_4_ = 0;
  hashVal._5_4_ = 0;
  hashVal._9_4_ = 0;
  hashVal._13_2_ = 0;
  hashVal[15] = '\0';
  hashVal[0] = '\0';
  hashLen = 0x10;
  ok = CryptGetHashParam(hHash,HP_HASHVAL,hashVal,&hashLen,0);
  if (ok == FALSE) {
    printf("Unable to obtain MD5 hash value for file.\n");
  }
                    /* test fileHash == hashVal */
  iVar1 = 4;
  bVar4 = true;
  piVar2 = (int *)hashVal;
  piVar3 = (int *)fileHash;
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    bVar4 = *piVar2 == *piVar3;
    piVar2 = piVar2 + 1;
    piVar3 = piVar3 + 1;
  } while (bVar4);
  if (!bVar4) {
    printf("ERROR: File \"%s\" is corrupted!\n");
  }
  CryptDestroyHash(hHash);
  CloseHandle(hOut);
  CloseHandle(hArchive);
  __security_check_cookie(cookie_00);
  return;
}
---CODE END---

Cryptex header:
    0x00:8      signature, "CrYpTeX9"
    0x08:2      ??, always 1
    0x0a:2      ??, always 0, maybe major and minor version number
    0x0c:4      first file list cluster index
    0x10:4      pointer to the head of the free cluster list
                00401290 is the function that allocates a new cluster
    0x14:4      the total number of clusters
    0x18:16     MD5 checksum of SHA hash of user password

Cryptex file list cluster:
    0x00:152*26 file entries

Cryptex file entry:
    0x00:4      next cluster index
    0x04:4      first data cluster
    0x08:4      total number of clusters used by this file
    0x0C:16     MD5 hash of the file
    0x1C:128    file name, null terminated

Crytex data cluster:
    0x00:4      next cluster index, or actual data size
    0x04:4      ??
    0x08:4      ??
    0x0c:4096   data

decompilation of 00401290:
---CODE START---
DWORD __cdecl AllocateNewCluster(HANDLE hArchive,HCRYPTKEY key)

{
  longlong lVar1;
  uint posLow;
  int i;
  int posHigh;
  DWORD freeCluster;
  undefined4 *pData;
  
  freeCluster = HEADER_BUFFER._16_4_;
  if (HEADER_BUFFER._16_4_ != 0) {
    DecryptCluster(hArchive,HEADER_BUFFER._16_4_,key);
                    /* remove one free cluster from the free cluster list */
    HEADER_BUFFER._16_4_ = CLUSTER_BUFFER._0_4_;
                    /* memset(CLUSTER_BUFFER + 4, 0, 8 + 4092) */
    pData = (undefined4 *)(CLUSTER_BUFFER + 4);
    for (i = 0x3ff; i != 0; i = i + -1) {
      *pData = 0;
      pData = pData + 1;
    }
    return freeCluster;
  }
                    /* total number of clusters += 1 */
  HEADER_BUFFER._20_4_ = HEADER_BUFFER._20_4_ + 1;
                    /* archive end = number of clusters * 0x1008 + 0x28 */
  posLow = (uint)((ulonglong)HEADER_BUFFER._20_4_ * 0x1008);
  posHigh = (int)((ulonglong)HEADER_BUFFER._20_4_ * 0x1008 >> 0x20) + (uint)(0xffffffd7 < posLow);
  SetFilePointer(hArchive,posLow + 0x28,&posHigh,0);
  SetEndOfFile(hArchive);
                    /* new cluster start = (number of clusters - 1) * 0x1008 + 0x28 */
  lVar1 = (ulonglong)(HEADER_BUFFER._20_4_ - 1) * 0x1008;
  posLow = (uint)lVar1;
  posHigh = (int)((ulonglong)lVar1 >> 0x20) + (uint)(0xffffffd7 < posLow);
  SetFilePointer(hArchive,posLow + 0x28,&posHigh,0);
                    /* memset(CLUSTER_BUFFER, 0, 12 + 4092) */
  pData = (undefined4 *)CLUSTER_BUFFER;
  for (i = 0x402; i != 0; i = i + -1) {
    *pData = 0;
    pData = pData + 1;
  }
  return HEADER_BUFFER._20_4_;
}
---CODE END---

7. Auditing Program Binaries
p243, JPEG example
just like air crashes, such a security breach could only be possible due to a cascade of unaccounted
errors on every level of the system: 
    - the operating system has no proper, fine-grained permission control
    - the programming language used by default doesn't bound check memory access
    - only finally, coding error by programmer of the JPEG library

p247, Chapter7!launch:
    00401060 mov eax,[esp+0x4]                  ; PARAM_1
    00401064 sub esp,0x64                       ; esp = -0x64, relative to return address
                                                ; stack state:
                                                ;   -0x64: char buffer[100]
                                                ;   -0x00: return address
    00401067 push eax                           ; PARAM_1, char *src
                                                ; esp = -0x68
    00401068 lea ecx,[esp+0x4]                  ; ecx = buffer (-0x64)
    0040106c push ecx                           ; buffer, char *dest
                                                ; esp = -0x6C
    0040106d call Chapter7!strcpy (00401180)    
    00401072 lea edx,[esp+0x8]                  ; edx = buffer (-0x64)
    00401076 push 0x408128                      ; some string literal, char *src
                                                ; esp = -0x70
    0040107b push edx                           ; buffer, char *dest
                                                ; esp = -0x74
    0040107c call Chapter7!strcat (00401190)
    00401081 lea eax,[esp+0x10]                 ; buffer (-0x64)
    00401085 push eax                           ; buffer, char *command
                                                ; esp = -0x78
    00401086 call Chapter7!system (004010e7)
    0040108b add esp,0x78                       ; esp = 0
    0040108e ret

p250, Chapter7!launch:
    00401060 mov eax,[esp+0x4]                  ; eax = PARAM_1
    00401064 lea edx,[esp-0x64]                 ; edx = buffer
    00401068 sub esp,0x64
    0040106b sub edx,eax                        ; edx = buffer - &PARAM_1
                                                ; i = 0
    0040106d lea ecx,[ecx]                      ; ecx = ecx? maybe padding
strcpy:
    00401070 mov cl,[eax]                       ; cl = PARAM_1[i]
    00401072 mov [edx+eax],cl                   ; buffer[i] = PARAM_1[i]
    00401075 inc eax                            ; i += 1
    00401076 test cl,cl                         ; if (PARAM_1[i] != '\0')
    00401078 jnz Chapter7!launch+0x10 (00401070);   jump to strcpy
    0040107a push edi
    0040107b lea edi,[esp+0x4]
    0040107f dec edi                            ; i = -1
strcat:
    00401080 mov al,[edi+0x1]                           ; al = buffer[i + 1] 
    00401083 inc edi                                    ; i += 1;
    00401084 test al,al                                 ; if (buffer[i] != '\0')
    00401086 jnz Chapter7!launch+0x20 (00401080)        ;   jump to strcat
    00401088 mov eax,[Chapter7!'string’ (00408128)]     ; eax = string[0..4] as DWORD
    0040108d mov cl,[Chapter7!'string’+0x4 (0040812c)]  ; cl = string[4]
                                                        ; string is 5-chars long
    00401093 lea edx,[esp+0x4]                          ; edx = buffer
    00401097 mov [edi],eax                              ; buffer[i..i+4] = string[0..4]
    00401099 push edx                                   ; buffer, char *command
    0040109a mov [edi+0x4],cl                           ; buffer[i+4] = string[i+4]
    0040109d call Chapter7!system (00401102)
    004010a2 add esp,0x4                                ; epilogue
    004010a5 pop edi
    004010a6 add esp,0x64
    004010a9 ret

p258, allocate_object:
    00401021 push esi                                   ; esp = -0x4, relative to origin
    00401022 push edi                                   ; esp = -0x8
    00401023 mov edi,[esp+0x10]                         ; edi = PARAM_2 (+0x8)
    00401027 lea esi,[edi+0x18]                         ; esi = PARAM_2 + 0x18
    0040102a push esi                                   ; PARAM_2 + 0x18, size_t size
    0040102b call Chapter7!malloc (004010d8)
    00401030 pop ecx
    00401031 xor ecx,ecx                                ; ecx = 0
    00401033 cmp eax,ecx                                ; if (eax != NULL)
    00401035 jnz Chapter7!allocate_object+0x1a (0040103b)   ;   jump to malloc_ok
    00401037 xor eax,eax                                ; return NULL
    00401039 jmp Chapter7!allocate_object+0x42 (00401063)
malloc_ok:
    0040103b mov [eax+0x4],ecx                          ; memset(eax, 0, 0x18)
    0040103e mov [eax+0x8],ecx
    00401041 mov [eax+0xc],ecx
    00401044 mov [eax+0x10],ecx
    00401047 mov [eax+0x14],ecx
    0040104a mov ecx,edi                                ; ecx = PARAM_2
    0040104c mov edx,ecx                                ; edx = PARAM_2
    0040104e mov [eax],esi                              ; *eax = PARAM_2 + 0x18
                                                        ; first 4 bytes in header is length
                                                        ; memcpy(PARAM_1, eax + 0x18, PARAM_1, PARAM_2)
    00401050 mov esi,[esp+0xc]                          ; esi = PARAM_1 (+0x4)
    00401054 shr ecx,0x2                                ; ecx = PARAM_2 / 4
    00401057 lea edi,[eax+0x18]                         ; edi = eax + 0x18
    0040105a rep movsd                                  ; PARAM_2 bytes copied from PARAM_1 to eax
                                                        ; 4 bytes at a time
    0040105c mov ecx,edx                                ; edx = PARAM_2
    0040105e and ecx,0x3                                ; edx = PARAM_2 % 4
    00401061 rep movsb                                  ; copy reminders
exit:
    00401063 pop edi 
    00401064 pop esi
    00401065 ret

p262, the original analysis of Code Red by eEye:
http://web.archive.org/web/20081226021124/http://research.eeye.com/html/advisories/published/AL20010717.html
the initial infection vector 
    GET /default.ida?NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u9090%u8190%u00c3%u0003%u8b00%u531b%u53ff%u0078%u0000%u00=a  HTTP/1.0
overwrites the stack with 
    4E 00 4E 00 4E 00 4E 00
    4E 00 4E 00 4E 00 4E 00
    4E 00 4E 00 4E 00 4E 00
    92 90 58 68 4E 00 4E 00
    4E 00 4E 00 4E 00 4E 00
    FA 00 00 00 90 90 58 68
    D3 CB 01 78 90 90 58 68
    D3 CB 01 78 90 90 58 68
    D3 CB 01 78 90 90 90 90
    90 81 C3 00 03 00 00 8B
    1B 53 FF 53 78
where the address to exception handler is overwritten by 7801CBD3, which is an address in msvcrt.dll
that reads:
    call ebx
the code flow is then redirected to the stack, then to the worm payload in the HTTP request body.

p267, void __stdcall DecodeURLEscapes(
    // [in] encoded ascii url
    unsigned char *url,
    // [in, out?] length of ascii url
    unsigned long &urlLen,
    // [out] decoded, unescaped utf-16 url
    unsigned WCHAR *decoded,
    // +0x8 of EXTENSION_CONTROL_BLOCK
    // https://learn.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms525658(v=vs.90)
    // [in] a unique number assigned by the HTTP server
    HCONN connID,
)

8. Reversing Malware
p278, Information-Stealing Worms: better known as ransomware, since 2017 surged in popularity
because of cryptocurrency as an anonymous method of global payment. 

p279, BIOS/Firmware Malware, Intel ME, a backdoor on modern Intel platforms, allegedly planted by
Intel instructed by NSA, runs in ring -3 under the kernel and the CPU, has full access to the
memory, the network stack and any type of peripherals (keyboard, mouse, display etc.), (until the
recent discovery of an undocumented configuration for government agencies) cannot be disabled by
users, cannot even be turned off as long as the computer is plugged in. A similar firmware backdoor
was discovered on AMD platforms well. 
Another group of kernel-level malware that people willingly install on their system is anti-cheat
software. Despite their name these softwares seldomly prevented cheats to a perceivable degree,
instead they frequently are closed-source, introduce vulnerabilities to the system and in rare cases
have embedded crypto miners.

Polymorphism: 
    - encrypt / decrypt the malware with random keys each time it's replicated
    - randomize registers each time the malware is decrypted

Metamorphism:
    - rearrange registers, instructions, functions, insert garbage in between, reverse branches
    - basically a decompiler and a randomizing compiler combined

p291, The Initial Installation
DWORD GetModuleFileNameA(
    // when NULL, retrieves the executable path of the current process
    [in, optional] HMODULE hModule,
    [out]          LPSTR   lpFilename,
    // size of lpFilename buffer
    [in]           DWORD   nSize
);
DWORD CharUpperBuffA(
    // converts lower case characters to upper case, according to the system locale
    // which means lpsz is not treated as ascii nor unicode but anything in between
    // also in unicode there's no guarantee the upper case character has the same byte length as the
    // lower case character, hence the function doesn't work with unicode
    [in, out] LPSTR lpsz,
    // size of lpsz
    [in]      DWORD cchLength
);
// creates or _opens_ a named mutex
HANDLE CreateMutexA(
    [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes,
    // ignored if named mutex exists
    [in]           BOOL                  bInitialOwner,
    [in, optional] LPCSTR                lpName
);
...
    004026CE MOV EDI,0                      ; retry = 0
    004026D3 JMP SHORT ZoneLock.004026E0    ; jump to copy_to_system_dir
sleep_before_retry:
    004026D5 PUSH 1F4                       ; Timeout = 500. ms
    004026DA CALL <JMP.&KERNEL32.Sleep>
    004026DF INC EDI
copy_to_system_dir:
    004026E0 PUSH 0 ; FailIfExists = FALSE
    004026E2 PUSH ZoneLock.00404010         ; NewFileName = “C:\WINNT\system32\ZoneLockup.exe”
    004026E7 PUSH ZoneLock.00404540         ; ExistingFileName = “C:\WINNT\SYSTEM32\ZoneLockup.exe”
    004026EC CALL <JMP.&KERNEL32.CopyFileA>
    004026F1 OR EAX,EAX
    004026F3 JNZ SHORT ZoneLock.004026FA
    004026F5 CMP EDI,5                      ; the operation is retried at most 5 times
    004026F8 JL SHORT ZoneLock.004026D5     ; jump to sleep_before_retry
...
    00402760 PUSH 7D0                       ; Timeout = 2000. ms  
    00402765 CALL <JMP.&KERNEL32.Sleep>     ; wait for the main process to exit
    0040276A MOV EAX,ESI
    0040276C ADD EAX,4
    0040276F PUSH EAX                       ; FileName
    00402770 CALL <JMP.&KERNEL32.DeleteFileA>
...
    0040277E CALL <JMP.&KERNEL32.CreateMutexA> 
    00402783 MOV DWORD PTR DS:[404650],EAX
    00402788 CALL <JMP.&KERNEL32.GetLastError>  
    0040278D CMP EAX,0B7                        ; ERROR_ALREADY_EXISTS
                                                ; system objects in windows share the same namespace,
                                                ; if another non-mutex object by the same name
                                                ; exists, ERROR_ALREADY_EXISTS is set
                                                ; this should be an easy switch to kill this trojan
    00402792 JNZ SHORT ZoneLock.0040279B
    00402794 PUSH 0 ; ExitCode = 0
    00402796 CALL <JMP.&KERNEL32.ExitProcess>

p294, Initializing Communications
BOOL InternetGetConnectedState(
    // connection description
    [out] LPDWORD lpdwFlags,
    // must be 0
    [in]  DWORD   dwReserved
);

p300,
    00402EED XOR EDI,EDI                        ; i = 0
loop:
    00402EEF LEA EAX,DWORD PTR SS:[EBP-60]      ; s2 = EBP-0x60
    00402EF2 PUSH EAX                           ; s2, char *str2
    00402EF3 IMUL EAX,EDI,50
    00402EF6 LEA EAX,DWORD PTR DS:[EAX+4051C5]  ; s1 = NAME_TABLE + i * 50
    00402EFD PUSH EAX                           ; s1, char *str1
    00402EFE CALL <JMP.&CRTDLL.strcmp> ; strcmp ; ord = strcmp(s1, s2)
    00402F03 ADD ESP,8                          
    00402F06 OR EAX,EAX                         ; if (ord != 0)
    00402F08 JNZ SHORT ZoneLock.00402F0D        ;   jump to not_equal
    00402F0A XOR EBX,EBX
    00402F0C INC EBX                            ; found = TRUE
not_equal:
    00402F0D INC EDI                            ; i += 1
    00402F0E CMP EDI,3                          ; if (i <= 3)
    00402F11 JLE SHORT ZoneLock.00402EEF        ;   jump to loop

9. Piracy and Copy Protection
p312, among today's major operating systems, iOS is the obvious one that doesn't qualify as an open
architecture: all applications must be signed with a known Apple developer key otherwise iOS will
refuse to load the executable. Any modification to the application will invalid the signature.
There's no easy way for iOS users to bypass the check as they usually do not have root access to the
OS: they do not actually own the device they purchased.

p323, LeGrande Technology, later re-branded as Intel Trusted Execution Technology (Intel TXT),
hashes code / memory at every boot step in help of a Trusted Platform Module (TPM) providing safe
memory region inaccessible to kernel / user code, to determine if any part of the BIOS or operating
system has been modified therefore defends them against software attack.

p323, NGSCB is scaled back and eventually cancelled / absorbed by other project inside Microsoft,
only BitLocker, a part of the original NGSCB, was shipped with Windows Vista in 2006. BitLocker is a
full-volume encryption tool that encrypts entire disk partition with keys secured by TPM protected
memory region.

10. Antireversing Techniques
p342, the indirect jump didn't confuse objdump nor Ghidra, today's disassembler are much more
powerful than they were in 2005. Steps to build such an executable:
    move to ./Reversing/chapter_10/indirect_jump
    execute ./build.sh (requires linux environment, nasm and gcc)

p348, Listing 10.2
    00401000 push esi
    00401001 push edi                       ; esp = -0x8, relative to origin value
    00401002 mov edi,dword ptr [esp+10h]    ; edi = PARAM_2 (esp+0x8)
    00401006 xor eax,eax                    ; eax = 0
    00401008 xor esi,esi                    ; esi = 0
    0040100A cmp edi,3                      ; if (edi <= 3)
    0040100D jbe 0040103A                   ;   jump to exit
    0040100F mov edx,dword ptr [esp+0Ch]    ; edx = PARAM_1 (esp+0x4)
    00401013 add edi,0FFFFFFFCh             ; edi = PARAM_2 - 4
    00401016 push ebx                       ; esp = -0xC
    00401017 mov ebx,dword ptr [esp+18h]    ; ebx = PARAM_3 (esp+0xC)
    0040101B shr edi,2                      ; edi = (PARAM_2 - 4) / 4
    0040101E push ebp                       ; esp = -0x10
    0040101F add edi,1                      ; edi = PARAM_2 / 4
loop:
                                            ; CBC XOR decryption
    00401022 mov ecx,dword ptr [edx]
    00401024 mov ebp,ecx                    ; ecx = ebp = *(DWORD *)edx
                                            ; PARAM_1 must be 4-byte aligned
    00401026 xor ebp,esi
    00401028 xor ebp,ebx                    ; ebp = ebp ^ esi ^ PARAM_3 
    0040102A mov dword ptr [edx],ebp        ; (DWORD *)edx = ebp
    0040102C xor eax,ecx                    ; eax = eax ^ ecx, unused?
    0040102E add edx,4                      ; edx += 4
    00401031 sub edi,1                      ; edi -= 1
    00401034 mov esi,ecx                    ; esi = ecx
    00401036 jne 00401022                   ; if (edi != 0) 
                                            ;   jump to loop
                                            ; nothing happens to the remainder?
    00401038 pop ebp
    00401039 pop ebx
exit:
    0040103A pop edi
    0040103B pop esi
    0040103C ret

p349, Listing 10.3
    00401040 push ecx                       ; esp = -0x4
    00401041 mov edx,dword ptr [esp+8]      ; edx = PARAM_1
    00401045 push ebx
    00401046 push ebp                       ; esp = -0xC
    00401047 mov ebp,dword ptr [esp+14h]    ; ebp = PARAM_2
    0040104B push esi
    0040104C push edi                       ; esp = -0x14
    0040104D mov edi,dword ptr [esp+10h]    ; edi = ecx
    00401051 xor eax,eax                    ; eax = 0
    00401053 xor ebx,ebx                    ; ebx = 0
reset:
    00401055 mov ecx,1                      ; ecx = 1
    0040105A lea ebx,[ebx]                  ; noop
jump_table:
    00401060 lea esi,[ecx-1]                ; esi = ecx - 1
    00401063 cmp esi,8                      ; if (esi > 8)
    00401066 ja 00401060                    ;   jump to jump_table
    00401068 jmp dword ptr [esi*4+4010B8h]  ; jump to table[esi]
table[3]:
    0040106F xor dword ptr [edx],ebx        ; *(DWORD *)edx ^= ebx
enter_loop:
    00401071 add ecx,1                      ; ecx += 1
    00401074 jmp 00401060                   ; jump to table[ecx - 1], table[1] or table[4]
table[1]:
    00401076 mov edi,dword ptr [edx]        ; edi = *(DWORD *)edx
    00401078 add ecx,1                      ; ecx = 3
    0040107B jmp 00401060                   ; jump to table[2]
table[0]:
    0040107D cmp ebp,3                      ; if (ebp > 3)
    00401080 ja 00401071                    ;   jump to enter_loop
    00401082 mov ecx,9                      ; ecx = 9
    00401087 jmp 00401060                   ; jump to table[8]
table[4]:
    00401089 mov ebx,edi                    ; ebx = edi
    0040108B add ecx,1                      ; ecx = 6
    0040108E jmp 00401060                   ; jump to table[5]
table[7]:
    00401090 sub ebp,4                      ; ebp -= 4
    00401093 jmp 00401055                   ; jump to reset
table[2]:
    00401095 mov esi,dword ptr [esp+20h]    ; esi = PARAM_3
    00401099 xor dword ptr [edx],esi        ; *(DWORD *)edx ^= PARAM_3
    0040109B add ecx,1                      ; ecx = 4
    0040109E jmp 00401060                   ; jump to table[3]
table[5]:
    004010A0 xor eax,edi                    ; eax ^= edi
    004010A2 add ecx,1                      ; ecx = 7
    004010A5 jmp 00401060                   ; jump to table[6]
table[6]:
    004010A7 add edx,4                      ; edx += 4
    004010AA add ecx,1                      ; ecx += 1
    004010AD jmp 00401060                   ; jump to table[7]
table[8]:                                   ; exit
    004010AF pop edi
    004010B0 pop esi
    004010B1 pop ebp
    004010B2 pop ebx
    004010B3 pop ecx
    004010B4 ret
The function’s jump table:
    0x004010B8 0040107d 00401076 00401095 0040106f
    0x004010C8 00401089 004010a0 004010a7 00401090
    0x004010D8 004010af

Effective, Ghidra couldn't make any sense from the code, steps to build:
    move to ./Reversing/chapter_10/jump_table/
    execute ./build.sh (requires linux environment and nasm)

p351, Listing 10.4: similar to 10.3 except that value of ecx are from a stack array i.e. one more
level of indirection

p356, performance is less of an issue now because most consumer electronics are vastly overpowered
for the intended use. That leaves a fat margin for developers to employ whatever anti-reversing
measure they want, for example Denuvo Anti-Tamper technology by Irdeto, which reportedly halves the
performance of software in worst case scenario, are gaining population year by year among the
industry because of how effective it is.

Another anti-reversing technique not mentioned in this book is to write program in a language that
    1.  compiles directly to native binary code 
    2.  is not C or C++
    3.  (preferably) pre-process format strings during compilation
    4.  (preferably) statically link standard library with no stable ABI
That includes Go, Ada, Rust etc. Since most reversing toolkit are specialized towards C/C++, any
native program written in other languages are considerably harder to reverse.

11. Breaking Protections
p358. in Ghidra:
    1.  search string "Wrong Serial"
    2.  find the sole reference to the string in .text
    3.  find the preceding conditional in decompiler 
    4.  patch out with nop

p365, UINT GetDlgItemTextA(
    // handle to the dialog box
    [in]    HWND    hDlg,
    // identifier of the control in the dialog box
    [in]    int     nIDDlgItem, 
    // output buffer, 8-bit characters
    [out]   LPSTR   lpString,
    // max length of lpString including null terminator
    [in]    int     cchMax
);
// return number of chars copied to the buffer, not including the null terminator
// error return value is 0, which is also a valid return value for 0 character copied

p366, Listing 11.1, second half
    ...
    004012F6 PUSH Key4.0040303F                 ; input_1
    004012FB CALL <JMP.&KERNEL32.lstrlenA>
    00401300 XOR ESI,ESI                        ; esi = 0
    00401302 XOR EBX,EBX                        ; ebx = 0
    00401304 MOV ECX,EAX                        ; ecx = strlen(input_1)
    00401306 MOV EAX,1                          ; eax = 1
loop:
    0040130B MOV EBX,DWORD PTR [40303F]         ; ebx = input_1[0..3] as u32
    00401311 MOVSX EDX,BYTE PTR [EAX+40351F]    ; edx = data_40351F[eax] as i8
    00401318 SUB EBX,EDX
    0040131A IMUL EBX,EDX
    0040131D MOV ESI,EBX
    0040131F SUB EBX,EAX
    00401321 ADD EBX,4353543
    00401327 ADD ESI,EBX
    00401329 XOR ESI,EDX                        
    0040132B MOV EAX,4
    00401330 DEC ECX                            ; repeated for length of input_1
    00401331 JNZ SHORT Key4.0040130B            ; jump to loop
    00401333 PUSH ESI
    00401334 PUSH Key4.0040313F                 ; input_2
    00401339 CALL Key4.00401388
    0040133E POP ESI
    0040133F CMP EAX,ESI

p366, Listing 11.2
                                            ; inefficient atoi
    00401388 PUSH EBP
    00401389 MOV EBP,ESP
    0040138B PUSH DWORD PTR [EBP+8]         ; input_2
    0040138E CALL <JMP.&KERNEL32.lstrlenA>
    00401393 PUSH EBX
    00401394 XOR EBX,EBX                    ; ebx = 0
    00401396 MOV ECX,EAX                    ; ecx = strlen(input_2)
    00401398 MOV ESI,DWORD PTR [EBP+8]      ; esi = input_2
outer_loop:
                                            ; for (i = strlen(input_2); i > 0; i--)
    0040139B PUSH ECX
    0040139C XOR EAX,EAX                    ; eax = 0
    0040139E LODS BYTE PTR [ESI]            ; eax = input_2[esi++]
    0040139F SUB EAX,30                     ; eax -= '0'
    004013A2 DEC ECX                        ; if (i - 1 == 0)
    004013A3 JE SHORT Key4.004013AA         ;   jump to inner_loop_exit
inner_loop:
    004013A5 IMUL EAX,EAX,0A                ; for (j = i - 1; j > 0; j--)
    004013A8 LOOPD SHORT Key4.004013A5      ;   eax *= 10, truncated
inner_loop_exit:
    004013AA ADD EBX,EAX                    ; ebx += eax
    004013AC POP ECX
    004013AD LOOPD SHORT Key4.0040139B
outer_loop_exit:
    004013AF MOV EAX,EBX                    ; return ebx
    004013B1 POP EBX
    004013B2 LEAVE
    004013B3 RET 4

p368, KeygenMe-3 keygen, in assembly:
    requirement: 
        - linux environment
        - gcc
        - means to build 32-bit executable with gcc if on 64-bit system
            gcc-multilib on Debian
            glibc-devel.i686 on Redhat
        - nasm 
    move to ./Reversing/chapter_11/KeygenMe-3/
    execute ./build.sh

p370, Defender.exe is not included in any of the archives from the book's website, probably because
modern Windows reports it as malware. Alternative download link:
    http://crackmes.cf/users/eldad_eilam/defender.exe/

p387,
; [EBP-6Ch]: int32 checksum
; [EBP-68h]: size_t i, initialized to length of fn_name
; [EBP-64h]: char *fn_name
loop:
    004035A4 MOV EAX,DWORD PTR [EBP-68]
    004035A7 MOV ECX,DWORD PTR [EBP-68]
    004035AA DEC ECX
    004035AB MOV DWORD PTR [EBP-68],ECX     ; i -= 1
    004035AE TEST EAX,EAX                   ; if (i < 0)
    004035B0 JE SHORT Defender.004035D0     ;   jump to LABEL_1
    004035B2 MOV EAX,DWORD PTR [EBP-64]
    004035B5 ADD EAX,DWORD PTR [EBP-68]
    004035B8 MOVSX ESI,BYTE PTR [EAX]       ; esi = (int32)fn_name[i]
    004035BB MOV EAX,DWORD PTR [EBP-68]     ; eax = i
    004035BE CDQ                            ; edx = SignOf(i)
                                            ; edx:eax is 64-bit SignExtend(i)
    004035BF PUSH 18                        
    004035C1 POP ECX
    004035C2 IDIV ECX
    004035C4 MOV ECX,EDX                    ; ecx = i % 24
    004035C6 SHL ESI,CL                     ; esi = (int32)fn_name[i] << (i % 24)
    004035C8 ADD ESI,DWORD PTR [EBP-6C]
    004035CB MOV DWORD PTR [EBP-6C],ESI     ; checksum += esi
    004035CE JMP SHORT Defender.004035A4    ; jump to loop
    ...
LABEL_1:
    004035D0 CMP DWORD PTR [EBP-6C],39DBA17A    ; if (checksum != 0x39DBA17A)
    004035D7 JNZ SHORT Defender.004035F1        ;   check the next entry in export list of NTDLL.dll

Dump 32-bit Windows system dll exports, their checksum and RVA:
    ./Reversing/chapter_11/ntdll_checksum_dump
    USAGE: EXEC DLL_NAME
requires i686-pc-windows-msvc target for Rust

p388,
__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(
    // current process handle is -1
    [in]      HANDLE    ProcessHandle,
    // rounded down to page boundary when returned
    [in, out] PVOID     *BaseAddress,
    // reverse alignment (number of 0 required for high-order bits)
    [in]      ULONG_PTR ZeroBits,
    // required size, rounded up to page boundary when returned
    [in, out] PSIZE_T   RegionSize,
    // 0x3000 = MEM_COMMIT | MEM_RESERVE, memory committed and zeroed
    [in]      ULONG     AllocationType,
    // 0x4 = PAGE_READWRITE
    [in]      ULONG     Protect
);
; [EBP-Ch]: void *baseAddress
; [EBP-10h]: void (*NtAllocateVirtualMemory)
; [EBP-4h]: uint32 regionSize
    0040365F RDTSC                          ; edx:eax = CPU time stamp
    00403661 AND EAX,7FFF0000               ; eax &= 0x7FFF0000
    00403666 MOV DWORD PTR [EBP-C],EAX      ; baseAddress = eax
    00403669 PUSH 4                         ; ULONG Protect
    0040366B PUSH 3000                      ; ULONG AllocationType
    00403670 LEA EAX,DWORD PTR [EBP-4]      
    00403673 PUSH EAX                       ; PSIZE_T RegionSize, &regionSize 
    00403674 PUSH 0                         ; ULONG_PTR ZeroBits
    00403676 LEA EAX,DWORD PTR [EBP-C]
    00403679 PUSH EAX                       ; PVOID *BaseAddress, &baseAddress
    0040367A PUSH -1                        ; HANDLE ProcessHandle
    0040367C CALL DWORD PTR [EBP-10]

p391,
; [EBP+8h]: void *NTDLLBaseAddress
; [EBP-C8h]: size_t PEHeaderOffset
; [EBP-D8h]: size_t NumberOfExportEntries
; [EBP-Ch]: void *baseAddress
    004038FD MOV EAX,DWORD PTR [EBP-C8]
    00403903 MOV ESI,DWORD PTR [EBP+8]                  ; esi = NTDLLBaseAddress
    00403906 ADD ESI,DWORD PTR [EAX+2C]                 ; esi = start of code section of NTDLL
    00403909 MOV EAX,DWORD PTR [EBP-D8]                 ; eax = number of export entries in NTDLL
    0040390F MOV EDX,DWORD PTR [EBP-C]                  ; edx = base address of allocation
    00403912 LEA EDI,DWORD PTR [EDX+EAX*8+8]            ; edi = edx + 8 byte for each import entry
    00403916 MOV EAX,ECX
    00403918 SHR ECX,2                                  ; memcpy(edi, esi, eax)
                                                        ; allocation is aligned to page boundary
    0040391B REP MOVS DWORD PTR ES:[EDI],DWORD PTR [ESI]; therefore this is valid memory access
    0040391D MOV ECX,EAX
    0040391F AND ECX,3
    00403922 REP MOVS BYTE PTR ES:[EDI],BYTE PTR [ESI]

p395, 0x006DEF20 is the checksum of "ZwDelayExecution", not "NtDelayExecution"

p397, Listing 11.8
// shoud be the same to NtDelayExecution
ZwDelayExecution(
    [in]    BOOLEAN         Alertable,
    [in]    PLARGE_INTEGER  DelayInterval 
);
struct ExportEntry {
    uint32 checksum;
    size_t rva;
}
; [EBP-8h]: timestamp before_call;
; [EBP-18h]: timestamp after_call;
; [EBP-44h]: void *delay_address;
; [EBP-4Ch]: LARGE_INTEGER delay_interval;
; [EBP-50h]: ExportEntry *delay_entry;
; [EBP-54h]: void *exit_address;
; [EBP-58h]: ExportEntry *exit_entry;
; [EBP-60h]: timestamp elapsed;
; DS:[406000]: ExportEntry *START_OF_ENTRY_LIST;
; DS:[40601C]: void *NTDLL_BASE_ADDRESS;
;   addresses randomized every run
begin:
    00402FFE XOR EAX,EAX
    00403000 INC EAX                            ; eax = 1
    00403001 JE Defender.004030C7               ; fake branch
    00403007 RDTSC
    00403009 MOV DWORD PTR SS:[EBP-8],EAX
    0040300C MOV DWORD PTR SS:[EBP-4],EDX       ; before_call = now
    0040300F MOV EAX,DWORD PTR DS:[406000]
    00403014 MOV DWORD PTR SS:[EBP-50],EAX      ; delay_entry = START_OF_ENTRY_LIST
delay_search_loop:
    00403017 MOV EAX,DWORD PTR SS:[EBP-50]
    0040301A CMP DWORD PTR DS:[EAX],0           ; if (delay_entry.checksum == 0)
    0040301D JE SHORT Defender.00403046         ;   jump to delay_search_not_found
    0040301F MOV EAX,DWORD PTR SS:[EBP-50]
    00403022 CMP DWORD PTR DS:[EAX],6DEF20      ; if (delay_entry is not ZwDelayExecution)
    00403028 JNZ SHORT Defender.0040303B        ;   jump to delay_not_equal
    0040302A MOV EAX,DWORD PTR SS:[EBP-50]
    0040302D MOV ECX,DWORD PTR DS:[40601C]
    00403033 ADD ECX,DWORD PTR DS:[EAX+4]
    00403036 MOV DWORD PTR SS:[EBP-44],ECX      ; delay_address = NTDLL_BASE_ADDRESS + delay_entry.rva 
    00403039 JMP SHORT Defender.0040304A        ; jump to delay_search_found
delay_not_equal:
    0040303B MOV EAX,DWORD PTR SS:[EBP-50]
    0040303E ADD EAX,8 
    00403041 MOV DWORD PTR SS:[EBP-50],EAX      ; delay_entry += 1
    00403044 JMP SHORT Defender.00403017        ; jump to loop
delay_search_not_found:
    00403046 AND DWORD PTR SS:[EBP-44],0        ; delay_address = NULL
delay_search_found:
    0040304A AND DWORD PTR SS:[EBP-4C],0        ; 
    0040304E AND DWORD PTR SS:[EBP-48],0
    00403052 LEA EAX,DWORD PTR SS:[EBP-4C]      ; eax = &delay_interval
    00403055 PUSH EAX                           ; PLARGE_INTEGER DelayInterval
    00403056 PUSH 0                             ; BOOLEAN Alertable
    00403058 CALL DWORD PTR SS:[EBP-44]         ; ZwDelayExecution
                                                ; if not found, call into 0x0
                                                ; which is segmentation error
                                                ; will terminate the process?
    0040305B RDTSC
    0040305D MOV DWORD PTR SS:[EBP-18],EAX      ; after_call = now
    00403060 MOV DWORD PTR SS:[EBP-14],EDX
    00403063 MOV EAX,DWORD PTR SS:[EBP-18]
    00403066 SUB EAX,DWORD PTR SS:[EBP-8]
    00403069 MOV ECX,DWORD PTR SS:[EBP-14]
    0040306C SBB ECX,DWORD PTR SS:[EBP-4]
    0040306F MOV DWORD PTR SS:[EBP-60],EAX      ; elapsed = after_call - before_call
    00403072 MOV DWORD PTR SS:[EBP-5C],ECX
    00403075 JNZ SHORT Defender.00403080        ; if (elapsed >= 2^32 cycle)
                                                ;   jump to long_enough
    00403077 CMP DWORD PTR SS:[EBP-60],77359400 ; if (elapsed <= 0x77359400 cycle)
    0040307E JBE SHORT Defender.004030C2        ;   jump to too_short
long_enough:
    00403080 MOV EAX,DWORD PTR DS:[406000]      
    00403085 MOV DWORD PTR SS:[EBP-58],EAX      ; exit_entry = START_OF_ENTRY_LIST 
exit_search_loop:
    00403088 MOV EAX,DWORD PTR SS:[EBP-58]
    0040308B CMP DWORD PTR DS:[EAX],0           ; if (exit_entry.checksum = 0)
    0040308E JE SHORT Defender.004030B7         ;   jump to exit_not_found
    00403090 MOV EAX,DWORD PTR SS:[EBP-58]
    00403093 CMP DWORD PTR DS:[EAX],1BF08AE     ; if (exit_entry is not NtTerminateProcess)
    00403099 JNZ SHORT Defender.004030AC        ;   jump to exit_not_equal
    0040309B MOV EAX,DWORD PTR SS:[EBP-58]
    0040309E MOV ECX,DWORD PTR DS:[40601C]
    004030A4 ADD ECX,DWORD PTR DS:[EAX+4]
    004030A7 MOV DWORD PTR SS:[EBP-54],ECX      ; exit_address = NTDLL_BASE_ADDRESS + exit_entry.rva 
    004030AA JMP SHORT Defender.004030BB        ; jump to exit_found
exit_not_equal:
    004030AC MOV EAX,DWORD PTR SS:[EBP-58]
    004030AF ADD EAX,8                          
    004030B2 MOV DWORD PTR SS:[EBP-58],EAX      ; exit_entry += 1 
    004030B5 JMP SHORT Defender.00403088        ; jump to exit_search_loop
exit_not_found:
    004030B7 AND DWORD PTR SS:[EBP-54],0        ; exit_address = NULL
exit_found:
    004030BB PUSH 0                             ; NTSTATUS ExitStatus
    004030BD PUSH -1                            ; HANDLE ProcessHandle
                                                ; -1 is current process
    004030BF CALL DWORD PTR SS:[EBP-54]         ; NtTerminateProcess
too_short:
    004030C2 JMP Defender.00402FFE              ; jump to begin

p401,
    004041E2 MOV EAX,Defender.004041FD      ; address to exit
    004041E7 MOV DWORD PTR DS:[4034D6],EAX  ; rewrite immediate value of a push
    004041ED MOV DWORD PTR SS:[EBP-8],0
    004041F4 JMP Defender.00403401          ; jump to 0040346D, the re-encryption 
                                            ; at the end jump to value pushed by 4034D6
                                            ; which is rewritten to exit
    004041F9 LODS DWORD PTR DS:[ESI]
    004041FA DEC EDI
    004041FB ADC AL,0F2
exit:
    004041FD POP EDI
    004041FE POP ESI
    004041FF POP EBX
    00404200 LEAVE
    00404201 RETN

p402,
LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(
    [in] LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
);
typedef LPTOP_LEVEL_EXCEPTION_FILTER LONG (*)(LPEXCEPTION_POINTERS)
    should return
        0x1:        EXCEPTION_EXECUTE_HANDLER
        0xFFFFFFFF: EXCEPTION_CONTINUE_EXECUTION
        0x0:        EXCEPTION_CONTINUE_SEARCH
; DS:[406004]: ExportEntry KERNEL32_ENTRY_LIST;
; DS:[406014]: void *KERNEL32_BASE_ADDRESS;
;   randomized every run
    00404202 MOV EAX,DWORD PTR DS:[406004]  ; the same api search loop 
                                            ; looking for SetUnhandledExceptionFilter
    00404207 MOV ECX,EAX
    00404209 MOV EAX,DWORD PTR DS:[EAX]
    0040420B JMP SHORT Defender.00404219    ; test_next
loop:
    0040420D CMP EAX,66B8EBBB
    00404212 JE SHORT Defender.00404227     ; found
    00404214 ADD ECX,8
    00404217 MOV EAX,DWORD PTR DS:[ECX]
test_next:
    00404219 TEST EAX,EAX
    0040421B JNZ SHORT Defender.0040420D    ; loop
    0040421D XOR ECX,ECX
call:
    0040421F PUSH Defender.0040322E         ; LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    00404224 CALL ECX
    00404226 RETN
found:
    00404227 MOV ECX,DWORD PTR DS:[ECX+4]
    0040422A ADD ECX,DWORD PTR DS:[406014]
    00404230 JMP SHORT Defender.0040421F    ; call

p406,
; 64-bit left shift
    00401681 CMP CL,40                      ; if (cl >= 64)
    00401684 JNB SHORT Defender.0040169B    ;   jump to zeroing
    00401686 CMP CL,20                      ; if (cl >= 32)
    00401689 JNB SHORT Defender.00401691    ;   jump to extend_shift
    0040168B SHLD EDX,EAX,CL                ; edx:eax = edx:eax << cl
    0040168E SHL EAX,CL
    00401690 RETN
extend_shift: 
    00401691 MOV EDX,EAX                    ; edx = eax
    00401693 XOR EAX,EAX                    ; eax = 0
    00401695 AND CL,1F
    00401698 SHL EDX,CL                     ; edx <<= (cl % 32)
    0040169A RETN
zeroing:
    0040169B XOR EAX,EAX                    ; edx:eax = 0
    0040169D XOR EDX,EDX
    0040169F RETN

Each encrypted function has the exact same structure:
    rewrite imm in PPJ to start of encrypted code
    decrypt / decrypt switch
        if 0 jump to encryption, if 1 flow into decryption
    decryption
        jump to PPJ at the end
    encryption
    PPJ: push imm -> pop eax -> jmp eax
    encrypted code
    rewrite imm in PPJ to exit
    jump to PPJ
    exit
by patching the conditional jump following encrypt / decrypt switch to unconditional jump to PPJ,
the entire procedure of encryption / decryption would be skipped:
    rewrite imm in PPJ to start of encrypted code
    jump to PPJ 
    PPJ: push imm -> pop eax -> jmp eax sequence
    encrypted code
    rewrite imm in PPJ to exit
    jump to PPJ
    exit
for some reason Ghidra has two output options for a jump instruction and one of them is invalid:
    jmp 0x00401e2a
    e9 d1 00 00 00  // valid
    66 e9 d2 00     // invalid
however this rewrite alters the behavior of Defender.exe as the decryption procedure for certain
blocks are part of the key verification. After the rewrite any 16-character hex number would be
valid serial number for any user name. 

An automated tool that
    - decrypts code section
    - (can be configured to leave critical key verification section encrypted)
    - skip encryption / decryption procedure
    - neutralizes kill thread
is located at:
    ./Reversing/chapter_11/defender_decrypt/

Defender.exe keygen:
    ./Reversing/chapter_11/defender_keygen/

12. Reversing .NET 
// I have only vague idea about C# from some entry-level experience with it back in ~2010, this part
// may be horribly wrong

p428, J# discontinued in 2007, the current Microsoft product line on .NET platform is:
    C#, Java but invented by Microsoft
    F#, Haskell but invented by Microsoft
    Visual Basic
and unlike JVM, 3rd parties have shown barely any interest in developing their own language on this
platform.

p433, Listing 12.1
    .entrypoint
    .maxstack 2
    .locals init (int32 V_0)
    IL_0000: ldc.i4.1           ; a special instruction that pushes 1i32 onto stack
                                ; MSIL has such special instructions up to ldc.i4.8
    IL_0001: stloc.0            ; Int32 V_0 = 0
    IL_0002: br.s IL_000e       ; jump to while
loop:
    IL_0004: ldloc.0            ; Int32 value
    IL_0005: call void [mscorlib]System.Console::WriteLine(int32)
                                ; polymorphism by function overloading
                                ; call consumes parameters on stack
    IL_000a: ldloc.0
    IL_000b: ldc.i4.1
    IL_000c: add                ; V_0 += 1
                                ; add consumes operands on stack
    IL_000d: stloc.0
while:
    IL_000e: ldloc.0
    IL_000f: ldc.i4.s 10
    IL_0011: ble.s IL_0004      ; if (V_0 <= 10) jump to loop
    IL_0013: ret

p436, Listing 12.2
    .entrypoint
    .maxstack 2
    .locals init (class LinkedList V_0,
    int32 V_1,
    class StringItem V_2)
    IL_0000: newobj instance void LinkedList::.ctor()
    IL_0005: stloc.0            ; V_0 = LinkedList::.ctor()
    IL_0006: ldc.i4.1
    IL_0007: stloc.1            ; V_1 = 1
    IL_0008: br.s IL_002b       ; jump to while
loop:
    IL_000a: ldstr “item”
    IL_000f: ldloc.1 
    IL_0010: box [mscorlib]System.Int32
    IL_0015: call string [mscorlib]System.String::Concat(object, object)
                                ; left to right parameter order  
    IL_001a: newobj instance void StringItem::.ctor(string)
    IL_001f: stloc.2            ; V_2 = StringItem::.ctor(System.String::Concat("item", &V_1))
    IL_0020: ldloc.0            ; LinkedList this
    IL_0021: ldloc.2            ; ListItem
    IL_0022: callvirt instance void LinkedList::AddItem(class ListItem)
                                ; call virtual (runtime dispatch through VTable) method
                                ; `this` object is implicit first parameter 
    IL_0027: ldloc.1
    IL_0028: ldc.i4.1
    IL_0029: add
    IL_002a: stloc.1            ; V_1 += 1
while:
    IL_002b: ldloc.1
    IL_002c: ldc.i4.s 10
    IL_002e: ble.s IL_000a      ; if (V_1 <= 10) jump to loop
    IL_0030: ldloc.0
    IL_0031: callvirt instance void LinkedList::Dump()
                                ; deconstructor
    IL_0036: ret

in C# there's 3 forms of polymorphism:
    subtyping
    parametric (generic)
    function overloading
MSIL has native support for subtyping as demonstrated in this chapter
overloaded functions are compiled to their own symbols
generic functions with value type as a parameter is monomorphized, while all reference types are
treated as the same:
    https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generics-in-the-run-time

p439, Listing 12.4
.method public hidebysig instance void AddItem(class ListItem NewItem) cil managed
{
    .maxstack 2
    IL_0000: ldarg.1
    IL_0001: ldarg.0
    IL_0002: ldfld class ListItem LinkedList::ListHead
                                ; pop this
                                ; push this.ListHead
    IL_0007: stfld class ListItem ListItem::Next
                                ; pop NewItem
                                ; NewItem.Next = this.ListHead
    IL_000c: ldarg.0
    IL_000d: ldfld class ListItem LinkedList::ListHead
    IL_0012: brfalse.s IL_0020  ; if (this.ListHead == null) jump to empty_list
    IL_0014: ldarg.0
    IL_0015: ldfld class ListItem LinkedList::ListHead
    IL_001a: ldarg.1
    IL_001b: stfld class ListItem ListItem::Prev
                                ; this.ListHead.Prev = NewItem
empty_list:
    IL_0020: ldarg.0
    IL_0021: ldarg.1
    IL_0022: stfld class ListItem LinkedList::ListHead
                                ; this.ListHead = NewItem
    IL_0027: ret
}

p440, Listing 12.4
.method public hidebysig instance void Dump() cil managed
{
    .maxstack 1
    .locals init (class ListItem V_0)
    IL_0000: ldarg.0
    IL_0001: ldfld class ListItem LinkedList::ListHead
    IL_0006: stloc.0            ; V_0 = this.ListHead
    IL_0007: br.s IL_0016       ; jump to while
loop:
    IL_0009: ldloc.0
    IL_000a: callvirt instance void ListItem::Dump()
                                ; V_0.Dump()
                                ; even with GC some type requires manual destruction 
                                ; see https://learn.microsoft.com/en-us/dotnet/api/system.idisposable
    IL_000f: ldloc.0
    IL_0010: ldfld class ListItem ListItem::Next
    IL_0015: stloc.0            ; V_0 = V_0.Next
while:
    IL_0016: ldloc.0
    IL_0017: brtrue.s IL_0009   ; if (V_0 != null) jump to loop
    IL_0019: ret
                                ; LinkedList itself will be collected by GC
}

p446, Listing 12.6
instance void M0(class C0 PARAM_1) cil managed
{
// Code size: 46 bytes
    .maxstack 8
    IL_0000: ldarg.1
    IL_0001: ldarg.0
    IL_0002: ldfld class C0 C1::F0
    IL_0007: br.s IL_0017           ; jump to LABEL_0
LABEL_2:
    IL_0009: ldarg.0
    IL_000a: ldfld class C0 C1::F0
    IL_000f: ldarg.1
    IL_0010: stfld class C0 C0::F0  ; PARAM_1.F0 = this.F0
    IL_0015: br.s IL_0026           ; jump to LABEL_1
LABEL_0:
    IL_0017: stfld class C0 C0::F1  ; PARAM_1.F1 = this.F0
    IL_001c: ldarg.0
    IL_001d: ldfld class C0 C1::F0
    IL_0022: brfalse.s IL_0026      ; if (this.F0 == null) jump to LABEL_1
    IL_0024: br.s IL_0009           ; jump to LABEL_2
LABEL_1:
    IL_0026: ldarg.0
    IL_0027: ldarg.1
    IL_0028: stfld class C0 C1::F0  ; this.F0 = PARAM_1
    IL_002d: ret
}

p448, Listing 12.7
instance void a() cil managed
{
    // Code size: 36 bytes
    .maxstack 1
    .locals init(class d V_0)
    IL_0000: ldarg.0
    IL_0001: ldfld class d b::a
    IL_0006: stloc.0                        ; V_0 = this.a
    IL_0007: br.s IL_0009                   ; jump to while
while:
    IL_0009: ldloc.0
    IL_000a: brtrue.s IL_0011               ; if (V_0 != null) jump to loop
    IL_000c: br IL_0023                     ; jump to exit
loop:
    IL_0011: ldloc.0
    IL_0012: callvirt instance void d::a()  ; V_0.a()
    IL_0017: ldloc.0
    IL_0018: ldfld class d d::b
    IL_001d: stloc.0                        ; V_0 = V_0.b
    IL_001e: br IL_0009                     ; jump to while
exit:
    IL_0023: ret
}

13. Decompilation
p466, Data-flow analysis, chapter 9 of dragon book discusses the implementation of it

p473, there's still one difference between a struct and a bunch of local variables: the order of
them. C compilers are allowed to reorder local variables but are not allowed to reorder fields of a
struct, which means a struct defined on stack may exhibit certain variable order or otherwise
inefficient padding between variables.