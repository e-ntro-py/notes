Useful links:
    - https://www.wiley.com/en-us/Reversing%3A+Secrets+of+Reverse+Engineering+-p-9780764574818
        Errata and other book resources 
    - https://www.felixcloutier.com/x86/index.html
        x86_64 instruction reference
    - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
        x86_64 cheat sheet
    - https://wiki.osdev.org/
        OSDev wiki

2. Low-level software
p43, Errata: `char szWelcome` should be `char *szWelcome`
when declared as
    char *szWelcome = " .. "
the string will appear in .data section of the ELF executable, however
    const char *szWelcome = " .. "
will appear in (more approperate) .rodata section of the executable.
both compiled with non-optimizing gcc 8.3.0, content of data sections can be printed with 
    readelf -x [.data|.rodata] <FILE_PATH>

p45, x86_64 architecture additionally have 8 general purpose registers
    r8, r9, .., r15
the corresponding lower 32/16/8-bit register names are 
    r8d, r9d, .., r15d // d -> double (word)
    r8w, r9w, .., r15w // w -> a word, as in Intel 8086, the chip that kicked off x86
    r8b, r9b, .., r15b // b -> byte
the original 8 general purpose registers are extended to 64-bit as
    eax -> rax, ebx -> rbx, ..

p50, another common arithmetic instruction used by most optimized compilers is
    LEA, <mem>, <reg>
which write the _address_ of <mem> to <reg>, because of how expressive x86 memory address
expressions are LEA can be used to compute a multiply and up to two additions as a single operation,
for example 
    LEA, [RBX + RSI * 8], EDI
computes (RBX + 8 * RSI) and store it in EDI

p50, TEST instruction is emitted more frequently by gcc, while CMP performs a subtraction TEST 
performs a bitwise AND on the two operands

the EFLAGS register can be directly manipulated by x86 instructions:
    LAHF:   load flags into AH (9 - 16th least significant bits of RAX)
    SAHF:   set flags into AH
    PUSHF:  push flags onto stack
    POPF:   pop flags from stack into ELFAGS register
interestingly the first two instructions are removed in 64-bit mode for the first few 64-bit product
lines by Intel and AMD but later put back

p53, "DWORD PTR" is a size directive, it indicates the size of the data pointed by the memory
address therefore forces the operand to be treated as a pointer to data of certain size, in this
case
    push DWORD PTR [esp + 0x24]
pushes 32 bit (a DWORD) pointed by [esp + 0x24] to the stack. The four size directives in x86 are
    QWORD (64-bit), DWORD (32-bit), WORD (16-bit) and BYTE (8-bit)

p59, the gcc options producing only non-preprocessed listing file is
    gcc -E -fdirectives-only -o <LISTING_PATH> <SOURCE_PATH>
the rustc options producing assembly file is
    rustc --emit asm -C llvm-args="--x86-asm-syntax=intel" <SOURCE_PATH>

3. Windows Fundamentals
Win32 APIs _used to_ follow a cryptic flavor of the Hungarian notation:
    https://learn.microsoft.com/en-us/windows/win32/learnwin32/windows-coding-conventions

p72, narrator: "He didn't update his book." 
Good news is most of the innovative 64-bit desktop architectures didn't survive the competition.
One of the two modern architecture supported by modern Windows, x86_64, is strictly backward
compatible with x86, hence this book is still relevant after all these years.

p73, the speed gap between drives and physical memory narrowed quite a lot recently, a cutting edge
NVMe SSD operates at 7GB/s reading, only a magnitude lower than high end DDR5 memory (~70GB/s), as a
result SSDs are much more feasible as paging storages now.

p88, found an in-depth explanation of the initialization process, including calls into the native
APIs, but not sure whether it's describing Windows NT or another OS with a similar API since the
author referenced multiple times actual source code paths to these APIs which shouldn't be
available:
    https://www.cs.miami.edu/home/burt/journal/NT/processinit.html

p91, "Microsoft wonâ€™t be so concerned about developers using the native API and will soon publish
some level of documentation for it." They didn't.

p91, Zw has no meaning, it's chosen solely to avoid name conflict:
    https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/what-does-the-zw-prefix-mean-

p96, the first method is the ordinary dynamic linking, the second method requires the programmer to
manually load the dll with LoadLibrary then search the header with GetProcAddress, also the callee
must be explicitly exported with __declspec(dllexport) keyword or a DEF file.

p101, reference of PE format:
    https://learn.microsoft.com/en-us/windows/win32/debug/pe-format
Thread Local Storage Table: each thread when initialized is assigned a TLS (Thread Local Storage)
    data area, a TLS index and an entry in the TLS array pointing to its TLS data area, for each
    variable declared as 
        // C
        __declspec (thread) int x = 0;
        // Rust
        thread_local! { 
            // currently immutable only because of lifetime complications
            static x: i32 = 0;
        }
    there's a TLS data object at some fixed offset in the TLS data area, the same binary code
    therefore is able to access different memory location based on the current thread.

p105, that means exception would be thousands of times slower than return code as exception handling
has to go through the system call interface. It's always 

p107, line by line explanation of the code:
00411F8A push   ExceptionHandler
    push the pointer to the exception handler onto stack
00411F8F mov    eax, dword ptr fs:[00000000h]
    fs:[00000000h] fetches location 0x0 from the x86 FS segment instead of the default ds segment
    ([<ADDRESS>] is shorthand of ds:[<ADDRESS>]), the FS segment doesn't have hardware defined
    meaning, in WinNT FS:[0x0] points to the current head of the exception handler list
00411F95 push   eax
    push the old head to the stack
00411F96 mov    dword ptr fs:[0], esp
    stack in x86 grows downwards, the current state of stack is:
        esp+0x0     Ptr32   FS:[0x0] ;old head
        esp+0x4     Ptr32   ExceptionHandler
    thus esp points to a valid _EXCEPTION_REGISTRATN_RECORD struct


p107, again
0411F83 push 0FFFFFFFFh
00411F85 push 425090h
    addresses to two different exception handlers 
00411F8A push offset @ILT+420(__except_handler3) (4111A9h)
    __except_handler3 is part of the C++ runtime, therefore address to it is located in the ILT
    (import lookup table)
00411F8F mov eax,dword ptr fs:[00000000h]
00411F95 push eax
    push old head
00411F96 mov dword ptr fs:[0],esp
    the current state of stack is:
        esp+0x0     Ptr32   FS:[0x0] ;old head
        esp+0x4     Ptr32   __except_handler3
        esp+0x8     Ptr32   425090h
        esp+0xc     Ptr32   0FFFFFFFFh
    __except_handler3 when called would somehow delegate exceptions to the two exception handlers

4. Reversing Tools
The major addition to the tool scene is Ghidra released by NSA in 2019, an open-source and free
alternative to IDA pro. It's a nearly complete toolkit of reverse engineering: disassembly,
decompilation, debugging, patching, header dumping, etc. Its decompiler can incrementally improve
the output on user inputs including type hints, data layouts and loop structure.
Video series using Ghidra to reverse engineer WannaCry ransomware:
    part 1: https://www.youtube.com/watch?v=Sv8yu12y5zM
    part 2: https://www.youtube.com/watch?v=Q90uZS3taG0
    part 3: https://www.youtube.com/watch?v=ru5VzUigKqw

wrestool is a command-line tool to list and extract resources (embedded binaries) from PE
executables.

llvm-readobj from LLVM toolchain is a tool similar to readelf but supports a range of executable
formats, including PE32/PE32+ on WinNT and Mach-O on OSX.

5. Beyond the Documentation
p147, x86 real and protected mode memory segments:
    CS: code segment, pointed by CS register
    DS: data segment, default, points to heap
    SS: stack segment, manipulated by PUSH and POP, pointed by ESP and EBP
    ES: extra segment, used by string instructions (e.g STOS and MOVS)
    FS: no hardware use, points to TIB on 32-bit WinNT
    GS: no hardware use, points to TIB on 64-bit WinNT
on x86_64 however, base of all segments but FS and GS are _ignored_ and treated as 0

p147, Errata: cdecl and stdcall has the same parameter order right-to-left.
https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions
identify x86 calling conventions
cdecl: RET has no operand
    all parameters on stack
    parameters on stack pushed right-to-left
    caller restores stack
fastcall: ECX or EDX are used before initialization in function body
    first two parameters passed in ECX and EDX, rest on stack
    parameters on stack pushed right-to-left
    callee restores the stack
stdcall: RET has operand & is not fastcall
    all parameters on stack
    parameters on stack pushed right-to-left
    callee restores stack
thiscall: always decorated with class name and parameter type
    this pointer passed via ECX
    parameters on stack pushed right-to-left
    callee restores stack
fastcc: anything goes (https://llvm.org/docs/LangRef.html#callingconv)
    calling convention used by LLVM for non-interoperable code, uses _whatever trick_ possible for
    faster code, ABI unstable

x86_64 has only two calling conventions (https://wiki.osdev.org/Calling_Conventions): 
SystemV X86_64 (every platform besides Windows):
    RDI, RSI, RDX, RCX, R8, R9 then stack
    parameters on stack pushed right-to-left
    caller restores stack
    return value in RAX and RDX 
Microsoft x64:
    RCX, RDX, R8, R9 then stack
    parameters on stack pushed right-to-left
    caller restores stack
    return value in RAX 

p147, RtlInitializeGenericTable:
    7C921A39 MOV EDI,EDI
        https://devblogs.microsoft.com/oldnewthing/20110921-00/?p=9583
        a two-byte NOP inserted as a hot-patch point, replaced by a 2-byte jmp instruction when the
        function is hot-patched
    7C921A3B PUSH EBP
    7C921A3C MOV EBP,ESP
        prologue, store and set up ebp
        state of the stack:
            esp+0x0     OLD_EBP
            esp+0x4     RETURN_ADDRESS
            esp+0x8     PARAM_1
            ...
    7C921A3E MOV EAX,DWORD PTR SS:[EBP+8]
        EAX = PARAM_1
    7C921A41 XOR EDX,EDX
        EDX = 0
    7C921A43 LEA ECX,DWORD PTR DS:[EAX+4]
        ECX = PARAM_1 + 0x4
    7C921A46 MOV DWORD PTR DS:[EAX],EDX
        [PARAM_1] = 0
        PARAM_1 is a pointer
    7C921A48 MOV DWORD PTR DS:[ECX+4],ECX
        [PARAM_1+0x8] = PARAM_1 + 0x4
    7C921A4B MOV DWORD PTR DS:[ECX],ECX
        [PARAM_1+0x4] = PARAM_1 + 0x4
    7C921A4D MOV DWORD PTR DS:[EAX+C],ECX
        [PARAM_1+0xC] = PARAM_1 + 0x4
    7C921A50 MOV ECX,DWORD PTR SS:[EBP+C]
    7C921A53 MOV DWORD PTR DS:[EAX+18],ECX
        [PARAM_1+0x18] = PARAM_2
    7C921A56 MOV ECX,DWORD PTR SS:[EBP+10]
    7C921A59 MOV DWORD PTR DS:[EAX+1C],ECX
        [PARAM_1+0x1C] = PARAM_3
    7C921A5C MOV ECX,DWORD PTR SS:[EBP+14]
    7C921A5F MOV DWORD PTR DS:[EAX+20],ECX
        [PARAM_1+0x20] = PARAM_4
    7C921A62 MOV ECX,DWORD PTR SS:[EBP+18]
    7C921A65 MOV DWORD PTR DS:[EAX+14],EDX
        [PARAM_1+0x14] = 0
    7C921A68 MOV DWORD PTR DS:[EAX+10],EDX
        [PARAM_1+0x10] = 0
    7C921A6B MOV DWORD PTR DS:[EAX+24],ECX
        [PARAM_1+0x24] = PARAM_5
    7C921A6E POP EBP
    7C921A6F RET 14
        epilogue
this function initializes a structure that looks like:
    struct TABLE
    {
        UNKNOWN4        Member1; // = 0
        UNKNOWN_PTR32   Member2; // = &Member2
        UNKNOWN_PTR32   Member3; // = &Member2
        UNKNOWN_PTR32   Member4; // = &Member2
        UNKNOWN4        Member5; // = 0
        UNKNOWN4        Member6; // = 0
        UNKNOWN4        Member7; // = PARAM_2
        UNKNOWN4        Member8; // = PARAM_3
        UNKNOWN4        Member9; // = PARAM_4
        UNKNOWN4        Member10; // = PARAM_5
    }
Ghidra is able to automatically deduct the above type definition from the code of
RtlInitializeGenericTable, amazing

p152, RtlNumberGenericTableElements:
    7C923FD2 PUSH EBP
    7C923FD3 MOV EBP,ESP
        prologue
    7C923FD5 MOV EAX,DWORD PTR [EBP+8]
        EAX = PARAM_1
    7C923FD8 MOV EAX,DWORD PTR [EAX+14]
        EAX = *(PARAM_1 + 0x14)
    7C923FDB POP EBP
    7C923FDC RET 4
        EAX is returned
Member6 (PARAM_1 + 0x14) is the number of elements in the table, its type should be UInt32.

p152, RtlIsGenericTableEmpty:
    7C92715B PUSH EBP
    7C92715C MOV EBP,ESP
        prologue
    7C92715E MOV ECX,DWORD PTR [EBP+8]
        ECX = PARAM_1
    7C927161 XOR EAX,EAX
        EAX = 0
    7C927163 CMP DWORD PTR [ECX],EAX
    7C927165 SETE AL
        if (*PARAM_1 == 0) EAX = 1;
    7C927168 POP EBP
    7C927169 RET 4
        return EAX
Member1 is a pointer, non-null when the table has elements.

p154, void* RtlGetElementGenericTable(TABLE *Table, UInt32 index):
    7C9624E0 PUSH EBP
    7C9624E1 MOV EBP,ESP                    ; prologue
    7C9624E3 MOV ECX,DWORD PTR [EBP+8]      ; ECX = Table
    7C9624E6 MOV EDX,DWORD PTR [ECX+14]     ; EDX = Table->TotalElements
    7C9624E9 MOV EAX,DWORD PTR [ECX+C]      ; EAX = Table->LastElementFound
    7C9624EC PUSH EBX
    7C9624ED PUSH ESI                       ; callee saved registers
    7C9624EE MOV ESI,DWORD PTR [ECX+10]     ; ESI = Table->LastIndexFound
    7C9624F1 PUSH EDI                       ; callee saved registers
    7C9624F2 MOV EDI,DWORD PTR [EBP+C]      ; EDI = index
    7C9624F5 CMP EDI,-1
    7C9624F8 LEA EBX,DWORD PTR [EDI+1]      ; EBX = index + 1
    7C9624FB JE SHORT ntdll.7C962559        ; SHORT i.e. intramodule jump
                                            ; if (index == 0xFFFFFFFF)
                                            ;   jump to error_exit
    7C9624FD CMP EBX,EDX                    ; if (index + 1 > Table->TotalElements)
    7C9624FF JA SHORT ntdll.7C962559        ;   jump to error_exit
    7C962501 CMP ESI,EBX                    ; if (Table->LastIndexFound == index + 1) {
    7C962503 JE SHORT ntdll.7C962554        ;   jump to skip_header
                                            ; if (Table->LastIndexFound < index + 1) {
    7C962505 JBE SHORT ntdll.7C96252B       ;   jump to forward_search_1
    7C962507 MOV EDX,ESI                    ; EDX = Table->LastIndexFound
    7C962509 SHR EDX,1                      ; EDX = Table->LastIndexFound / 2
    7C96250B CMP EBX,EDX                    ; if (index + 1 <= Table->LastIndexFound / 2)
    7C96250D JBE SHORT ntdll.7C96251B       ;   jump to forward_search_2
    7C96250F SUB ESI,EBX                    ; ESI = Table->LastIndexFound - index - 1
                                            ; if (Table->LastIndexFound == index + 1)
    7C962511 JE SHORT ntdll.7C96254E        ;   jump to set_cache
loop_1:                                     ; while (ESI > 0) {
    7C962513 DEC ESI                        ;   ESI = ESI - 1
    7C962514 MOV EAX,DWORD PTR [EAX+4]      ;   EAX = EAX->PrevElement
                                            ; Table->LastElementFound points to a 3-pointer header structure, 
                                            ; EAX+0x4 points to the second entry of the 3 pointers,
                                            ; these structures form a linked list 
    7C962517 JNZ SHORT ntdll.7C962513       ; }
    7C962519 JMP SHORT ntdll.7C96254E       ; jump to set_cache
forward_search_2:
    7C96251B TEST EBX,EBX                   
    7C96251D LEA EAX,DWORD PTR [ECX+4]      ; EAX = Table->LastElement
    7C962520 JE SHORT ntdll.7C96254E        ; if (index + 1 == 0) jump to set_cache
    7C962522 MOV EDX,EBX                    ; EDX = index + 1
loop_4:                                     ; while (EDX > 0) {
    7C962524 DEC EDX                        ;   EDX -= 1
    7C962525 MOV EAX,DWORD PTR [EAX]        ;   EAX = EAX->NextElement
    7C962527 JNZ SHORT ntdll.7C962524       ; follow the first pointer in 3-pointer header
                                            ; the linked list must be circular
                                            ; } 
    7C962529 JMP SHORT ntdll.7C96254E       ; jump to set_cache
forward_search_1:
    7C96252B MOV EDI,EBX                    ; EDI = index + 1
    7C96252D SUB EDX,EBX                    ; EDX = Table->TotalElements - index - 1
    7C96252F SUB EDI,ESI                    ; EDI = index + 1 - Table->LastIndexFound
                                            ; distance from index to the last found element
    7C962531 INC EDX                        ; EDX = Table->TotalElements - index
                                            ; distance from index to the last element in table
    7C962532 CMP EDI,EDX                    ; if (EDI > EDX)
    7C962534 JA SHORT ntdll.7C962541        ;   jump to backward_search_1
    7C962536 TEST EDI,EDI                   ; if (EDI == 0)
    7C962538 JE SHORT ntdll.7C96254E        ;   jump to set_cache
loop_3:                                     ; while (EDI > 0) {
    7C96253A DEC EDI                        ;   EDI -= 1
    7C96253B MOV EAX,DWORD PTR [EAX]        ;   EAX = EAX->NextElement
                                            ; follow the first pointer in the 3-pointer structure
    7C96253D JNZ SHORT ntdll.7C96253A       ; }
    7C96253F JMP SHORT ntdll.7C96254E       ; jump to set_cache
backward_search_1;
    7C962541 TEST EDX,EDX                   
    7C962543 LEA EAX,DWORD PTR [ECX+4]      ; EAX = Table->LastElement
    7C962546 JE SHORT ntdll.7C96254E        ; if (EDX == 0) jump to set_cache
loop_2:                                     ; while (EDX > 0) {
    7C962548 DEC EDX                        ;   EDX -= 1;
    7C962549 MOV EAX,DWORD PTR [EAX+4]      ;   EAX = EAX->PrevElement
    7C96254C JNZ SHORT ntdll.7C962548       ; follow the second pointer in the 3-pointer header
                                            ; }
set_cache:
    7C96254E MOV DWORD PTR [ECX+C],EAX      ; Table->LastElementFound = EAX
    7C962551 MOV DWORD PTR [ECX+10],EBX     ; Table->LastIndexFound = EBX
skip_header:
    7C962554 ADD EAX,0C                     ; EAX = EAX + 0xC, skips the 3-pointer header
    7C962557 JMP SHORT ntdll.7C96255B       ; jump to exit
error_exit:
    7C962559 XOR EAX,EAX                    ; EAX = NULL
exit:
    7C96255B POP EDI                        ; epilogue
    7C96255C POP ESI                        ; restore callee saved registers
    7C96255D POP EBX                        
    7C96255E POP EBP                        
    7C96255F RET 8                          
high level description of void* RtlGetElementGenericTable(TABLE *Table, UInt32 index):
    if index + 1 is in range [0, Table->LastIndexFound / 2]:
        traverse forward from Table->LastElement
    if index + 1 is in range (Table->LastIndexFound / 2, Table->LastIndexFound]:
        traverse backward from Table->LastElementFound
    if index + 1 is in range (Table->LastIndexFound, Table->TotalElements]:
        if index + 1 is closer to Table->LastIndexFound:
            traverse forward from Table->LastElementFound
        if index + 1 is closer to Table->TotalElements
            traverse backward from Table->LastElement
    set Table->LastElementFound, Table->LastIndexFound to the search results
    return pointer to the data section of the listed list node found

p169, UNKNOWN4 RtlInsertElementGenericpTable {
    TABLE *pTable,
    PVOID ElementData,
    UInt32 ElementLength,
    UInt8 *pResult,
}
    7C924DC0 PUSH EBP                   ; prologue
    7C924DC1 MOV EBP,ESP            
    7C924DC3 PUSH EDI
    7C924DC4 MOV EDI,DWORD PTR [EBP+8]  ; EDI = pTable, 1st parameter
    7C924DC7 LEA EAX,DWORD PTR [EBP+8]  ; EAX = EBP + 0x8
    7C924DCA PUSH EAX                   ; 3rd parameter
    7C924DCB PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C924DCE CALL ntdll.7C92147B
    7C924DD3 PUSH EAX                   ; return value, 6th parameter
    7C924DD4 PUSH DWORD PTR [EBP+8]     ; mutated by ntdll.7C92147B, 5th parameter
    7C924DD7 PUSH DWORD PTR [EBP+14]    ; pResult, 4th parameter
    7C924DDA PUSH DWORD PTR [EBP+10]    ; ElementLength, 3rd parameter
    7C924DDD PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C924DE0 PUSH EDI                   ; pTable, 1st parameter
    7C924DE1 CALL ntdll.7C924DF0        ; return value returned
    7C924DE6 POP EDI                    ; epilogue
    7C924DE7 POP EBP
    7C924DE8 RET 10

p171, int RtlLocateNodeGenericpTable(
    TABLE *pTable, 
    PVOID DataToLocate, 
    NODE **ppNodeFound
)
                                        ; EDI = pTable, passed in register
    7C92147B MOV EDI,EDI                ; hot patch point
    7C92147D PUSH EBP                   ; prologue
    7C92147E MOV EBP,ESP
    7C921480 PUSH ESI
    7C921481 MOV ESI,DWORD PTR [EDI]    ; pNode = pTable->Root
    7C921483 TEST ESI,ESI               ; if (pTable->Root == NULL)
    7C921485 JE ntdll.7C924E8C          ;   jump to error
loop_1:                                 
                                        ; pNode is changed every loop
    7C92148B LEA EAX,DWORD PTR [ESI+18] ; EAX = pNode->data
    7C92148E PUSH EAX                   ; 3rd parameter
    7C92148F PUSH DWORD PTR [EBP+8]     ; DataToLocate, 2nd parameter
    7C921492 PUSH EDI                   ; pTable, 1st parameter
    7C921493 CALL DWORD PTR [EDI+18]    ; pTable->Comparator (Member_7)
    7C921496 TEST EAX,EAX               ; if (comparison_result == 0)
    7C921498 JE ntdll.7C924F14          ;   jump to right_branch
    7C92149E CMP EAX,1                  ; if (comparison_result != 1)
    7C9214A1 JNZ SHORT ntdll.7C9214BB   ;   jump to set_ret_1
    7C9214A3 MOV EAX,DWORD PTR [ESI+8]  ; EAX = pNode->LeftChild
    7C9214A6 TEST EAX,EAX               ; if (EAX != NULL)
    7C9214A8 JNZ ntdll.7C924F22         ;   jump to follow_right_branch
    7C9214AE PUSH 3
pop_ret:
    7C9214B0 POP EAX                    ; possible return values are 0, 1, 2, 3
                                        ; 0: error code
                                        ; 1: equal
                                        ; 2: greater (DataToLocate > pNode->data)
                                        ; 3: lesser
set_out_var:
    7C9214B1 MOV ECX,DWORD PTR [EBP+C]  ; ECX = ppNodeFound
    7C9214B4 MOV DWORD PTR [ECX],ESI    ; *ppNodeFound = pNode
exit:
    7C9214B6 POP ESI                    ; epilogue
    7C9214B7 POP EBP
    7C9214B8 RET 8
set_ret_1:
    7C9214BB XOR EAX,EAX
    7C9214BD INC EAX                    ; EAX = 1
    7C9214BE JMP SHORT ntdll.7C9214B1   ; jump to set_out_var
error:
    7C924E8C XOR EAX,EAX                ; EAX = 0
    7C924E8E JMP ntdll.7C9214B6         ; jump to exit
right_branch:
    7C924F14 MOV EAX,DWORD PTR [ESI+4]  ; EAX = pNode->RightChild
    7C924F17 TEST EAX,EAX               ; if (EAX != NULL)
    7C924F19 JNZ SHORT ntdll.7C924F22   ;   jump to follow_right_branch
    7C924F1B PUSH 2
    7C924F1D JMP ntdll.7C9214B0         ; jump to pop_ret
follow_right_branch:
    7C924F22 MOV ESI,EAX                ; pNode = pNode->RightChild
    7C924F24 JMP ntdll.7C92148B         ; jump to loop_1

p180, RtlRealInsertElementWorker
UNKNOWN RtlRealInsertElementWorker {
    TABLE *pTable,
    PVOID ElementData,
    UInt32 ElementSize,
    UInt8 *pResult,
    NODE *pNode,
    UInt32 SearchResult,
}
    7C924DF0 MOV EDI,EDI                ; prologue
    7C924DF2 PUSH EBP                   
    7C924DF3 MOV EBP,ESP
    7C924DF5 CMP DWORD PTR [EBP+1C],1   
    7C924DF9 PUSH EBX
    7C924DFA PUSH ESI
    7C924DFB PUSH EDI
    7C924DFC JE ntdll.7C935D5D          ; if (SearchResult == 1)
                                        ;   jump to splay_parent
    7C924E02 MOV EDI,DWORD PTR [EBP+10] ; EDI = ElementSize
    7C924E05 MOV ESI,DWORD PTR [EBP+8]  ; ESI = pTable
    7C924E08 LEA EAX,DWORD PTR [EDI+18] ; EAX = ElementSize + 0x18
                                        ; 0x18 is size of node header? 
    7C924E0B PUSH EAX                   ; ElementSize + 0x18, 2nd parameter
    7C924E0C PUSH ESI                   ; pTable, 1st parameter
    7C924E0D CALL DWORD PTR [ESI+1C]    ; pTable->Allocator (Member 8)
    7C924E10 MOV EBX,EAX                ; EBX = (Node *)return_value
    7C924E12 TEST EBX,EBX               ; if (node == NULL)
    7C924E14 JE ntdll.7C94D4BE          ;   jump to set_presult_false
    7C924E1A AND DWORD PTR [EBX+4],0    ; *(EBX + 0x4) = 0u32
    7C924E1E AND DWORD PTR [EBX+8],0    ; *(EBX + 0x8) = 0u32
    7C924E22 MOV DWORD PTR [EBX],EBX    ; *EBX = EBX
    7C924E24 LEA ECX,DWORD PTR [ESI+4]  ; ECX = &pTable->LLHead
    7C924E27 MOV EDX,DWORD PTR [ECX+4]  ; EDX = pTable->Member3
    7C924E2A LEA EAX,DWORD PTR [EBX+C]  ; EAX = EBX + 0xC
    7C924E2D MOV DWORD PTR [EAX],ECX    ; *(EBX + 0xC) = &pTable->LLHead
    7C924E2F MOV DWORD PTR [EAX+4],EDX  ; *(EBX + 0x10) = pTable->Member3
    7C924E32 MOV DWORD PTR [EDX],EAX    ; *pTable->Member3 = EBX + 0xC
    7C924E34 MOV DWORD PTR [ECX+4],EAX  ; pTable->Member3 = EBX + 0xC
    7C924E37 INC DWORD PTR [ESI+14]     ; pTable->TotalElements += 1
    7C924E3A CMP DWORD PTR [EBP+1C],0   ; if (SearchResult == 0)
    7C924E3E JE SHORT ntdll.7C924E88    ;   jump to set_root
    7C924E40 CMP DWORD PTR [EBP+1C],2
    7C924E44 MOV EAX,DWORD PTR [EBP+18] ; EAX = pNode
    7C924E47 JE ntdll.7C924F0C          ; if (SearchResult == 2)
                                        ;   jump to right_child
    7C924E4D MOV DWORD PTR [EAX+8],EBX  ; pNode->LeftChild = EBX
set_parent:
    7C924E50 MOV DWORD PTR [EBX],EAX    ; EBX->Parent = pNode
memcpy:
    7C924E52 MOV ESI,DWORD PTR [EBP+C]  ; ESI = ElementData
    7C924E55 MOV ECX,EDI
    7C924E57 MOV EAX,ECX                ; EAX = ElementSize
    7C924E59 SHR ECX,2                  ; ECX = ElementSize / 4
    7C924E5C LEA EDI,DWORD PTR [EBX+18] ; EDI = &pNode->data
    7C924E5F REP MOVS DWORD PTR ES:[EDI],DWORD PTR [ESI]
                                        ; for (; ECX > 0; ECX--) {
                                        ;   *(UInt32 *)EDI = *(UInt32 *)ESI
                                        ;   EDI += 4
                                        ;   ESI += 4
                                        ; }
    7C924E61 MOV ECX,EAX
    7C924E63 AND ECX,3                  ; ECX = ElementSize % 4
    7C924E66 REP MOVS BYTE PTR ES:[EDI],BYTE PTR [ESI]
                                        ; for (; ECX > 0; ECX--) {
                                        ;   *EDI = *(BYTE *)ESI
                                        ;   EDI += 1
                                        ;   ESI += 1
                                        ; }
    7C924E68 PUSH EBX                   ; pNewNode, 1st paremter
call_splay:
    7C924E69 CALL ntdll.RtlSplay        ; EAX = RETURN_VALUE
    7C924E6E MOV ECX,DWORD PTR [EBP+8]  ; ECX = pTable
    7C924E71 MOV DWORD PTR [ECX],EAX    ; pTable->Root = RETURN_VALUE
    7C924E73 MOV EAX,DWORD PTR [EBP+14] ; EAX = pResult
    7C924E76 TEST EAX,EAX               ; if (pResult != NULL)
    7C924E78 JNZ ntdll.7C935D4F         ;   jump to set_presult_true
set_return_value:
    7C924E7E LEA EAX,DWORD PTR [EBX+18] ; EAX = pNewNode->data
exit:
    7C924E81 POP EDI                    ; epilogue
    7C924E82 POP ESI
    7C924E83 POP EBX
    7C924E84 POP EBP
    7C924E85 RET 18
set_root:
    7C924E88 MOV DWORD PTR [ESI],EBX    ; pTable->Root = EBX
    7C924E8A JMP SHORT ntdll.7C924E52   ; jump to memcpy
    7C924E8C XOR EAX,EAX
    7C924E8E JMP ntdll.7C9214B6
right_child:
    7C924F0C MOV DWORD PTR [EAX+4],EBX  ; pNode->RightChild = EBX
    7C924F0F JMP ntdll.7C924E50         ; jump to set_parent
splay_parent:
    ; not given
    ; set EBX = pNode then jump to call_splay
set_presult_true:
    ; not given
    ; set *pResult = TRUE then jump to set_return_value
set_presult_false:
    7C94D4BE MOV EAX,DWORD PTR [EBP+14] ; EAX = pResult
    7C94D4C1 TEST EAX,EAX               ; if (pResult == NULL)
    7C94D4C3 JE SHORT ntdll.7C94D4C7    ;   jump to return_null
    7C94D4C5 MOV BYTE PTR [EAX],BL      ; *pResult = FALSE
return_null:
    7C94D4C7 XOR EAX,EAX                ; EAX = NULL
    7C94D4C9 JMP ntdll.7C924E81         ; jump to exit

p185, Errata: ECX = ElementSize / 4

p190, RtlLookupElementGenericTable
    7C9215BB PUSH EBP                   ; prologue
    7C9215BC MOV EBP,ESP 
    7C9215BE LEA EAX,DWORD PTR [EBP+C]  ; EAX = EBP + 0xC
    7C9215C1 PUSH EAX                   ; 4th parameter, output
    7C9215C2 LEA EAX,DWORD PTR [EBP+8]  ; EAX = EBP + 0x8
    7C9215C5 PUSH EAX                   ; 3rd parameter, output
    7C9215C6 PUSH DWORD PTR [EBP+C]     ; PARAM_2, 2nd parameter
    7C9215C9 PUSH DWORD PTR [EBP+8]     ; PARAM_1, 1st parameter
    7C9215CC CALL ntdll.7C9215DA        
    7C9215D1 POP EBP                    ; epilogue
    7C9215D2 RET 8

p192, ntdll.7C9215DA
PVOID RtlLookupElementGenericTableWorker(
    TABLE *pTable,
    PVOID ElementData, 
    NODE **ppNode,
    int *SearchResult,
)
    7C9215DA MOV EDI,EDI                ; prologue
    7C9215DC PUSH EBP           
    7C9215DD MOV EBP,ESP
    7C9215DF PUSH ESI
    7C9215E0 MOV ESI,DWORD PTR [EBP+10] ; ESI = ppNode
    7C9215E3 PUSH EDI
    7C9215E4 MOV EDI,DWORD PTR [EBP+8]  ; EDI = pTable, 1st parameter
    7C9215E7 PUSH ESI                   ; ppNode, 3rd parameter
    7C9215E8 PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C9215EB CALL ntdll.7C92147B        ; RtlLocateNodeGenericpTable
    7C9215F0 TEST EAX,EAX
    7C9215F2 MOV ECX,DWORD PTR [EBP+14] ; ECX = SearchResult
    7C9215F5 MOV DWORD PTR [ECX],EAX    ; *SearchResult = RETURN_VALUE
    7C9215F7 JE SHORT ntdll.7C9215FE    ; if (RETURN_VALUE == 0)
                                        ;   jump to return_null
    7C9215F9 CMP EAX,1                  ; if (RETURN_VALUE == 1)
    7C9215FC JE SHORT ntdll.7C921606    ;   jump to splay
return_null:
    7C9215FE XOR EAX,EAX                ; EAX = NULL
exit:
    7C921600 POP EDI                    ; epilogue
    7C921601 POP ESI
    7C921602 POP EBP
    7C921603 RET 10
splay:
    7C921606 PUSH DWORD PTR [ESI]       ; ppNode, 1st parameter
    7C921608 CALL ntdll.RtlSplay
    7C92160D MOV DWORD PTR [EDI],EAX    ; pTable->Root = RETURN_VALUE
    7C92160F MOV EAX,DWORD PTR [ESI]
    7C921611 ADD EAX,18                 ; EAX = *ppNode + 0x18
                                        ; points to data section
    7C921614 JMP SHORT ntdll.7C921600   ; jump to exit

p193, BOOLEAN RtlDeleteElementGenericTable(
    TABLE *pTable,
    PVOID ElementData,
)
    7C924FFF MOV EDI,EDI                ; prologue
    7C925001 PUSH EBP
    7C925002 MOV EBP,ESP
    7C925004 PUSH EDI
    7C925005 MOV EDI,DWORD PTR [EBP+8]  ; EDI = pTable, 1st parameter
    7C925008 LEA EAX,DWORD PTR [EBP+C]  ; EAX = &ElementData
    7C92500B PUSH EAX                   ; 3rd parameter
    7C92500C PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C92500F CALL ntdll.7C92147B        ; RtlLocateNodeGenericpTable
                                        ; ElementData is overwritten with parent node header 
                                        ; rename ElementData -> pNode
                                        ; there's a 0x18 byte minimal length requirement for data?
    7C925014 TEST EAX,EAX               ; if (searchResult == 0)
    7C925016 JE SHORT ntdll.7C92504E    ;   jump to not_found
    7C925018 CMP EAX,1                  ; if (searchResult != 1)
    7C92501B JNZ SHORT ntdll.7C92504E   ;   jump to not_found
    7C92501D PUSH ESI                   ; 
    7C92501E MOV ESI,DWORD PTR [EBP+C]  ; ESI = pNode
    7C925021 PUSH ESI                   ; 2nd parameter 
    7C925022 CALL ntdll.RtlDelete       ; pTable passed in register
                                        ; returns root after splay
    7C925027 MOV DWORD PTR [EDI],EAX    ; pTable->Root = root
                                        ; remove current node from linked list
    7C925029 MOV EAX,DWORD PTR [ESI+C]  ; EAX = pNode->LLEntry->NextElement
    7C92502C MOV ECX,DWORD PTR [ESI+10] ; ECX = pNode->LLEntry->PrevElement
    7C92502F MOV DWORD PTR [ECX],EAX    ; *pNode->LLEntry->PrevElement = pNode->LLEntry->NextElement
    7C925031 MOV DWORD PTR [EAX+4],ECX  ; *pNode->LLEntry->NextElement->PrevElement = pNode->LLEntry->PrevElement
    7C925034 DEC DWORD PTR [EDI+14]     ; pTable->TotalElements -= 1
    7C925037 AND DWORD PTR [EDI+10],0   ; pTable->LastIndexFound = 0
    7C92503B PUSH ESI                   ; ElementData, 2nd parameter
    7C92503C LEA EAX,DWORD PTR [EDI+4]  
    7C92503F PUSH EDI                   ; pTable, 1st parameter
    7C925040 MOV DWORD PTR [EDI+C],EAX
    7C925043 CALL DWORD PTR [EDI+20]    ; pTable->Deallocator
    7C925046 MOV AL,1                   ; EAX = TRUE
exit_1:
    7C925048 POP ESI                    ; epilogue
exit_2:
    7C925049 POP EDI
    7C92504A POP EBP
    7C92504B RET 8
not_found:
    7C92504E XOR AL,AL                  ; EAX = FALSE
    7C925050 JMP SHORT ntdll.7C925049   ; jump to exit_2

continuously updated type definitions:
struct TABLE
{
    Node            *Member1;
    ListEntry       LLHead;
    ListEntry       *LastElementFound;
    UInt32          *LastIndexFound;
    UInt32          TotalElements;
    Comparator      *Comparator;
    Allocator       *Allocator;
    Deallocator     *Deallocator;
    UNKNOWN4        Member10;
}
struct ListEntry {
    ListEntry       *NextElement;
    ListEntry       *PrevElement;
}
struct Node {
    Node            *Parent;        // 0x0
    Node            *RightChild;    // 0x4
    Node            *LeftChild;     // 0x8
    ListEntry       LLEntry;        // 0xC
    UNKNOWN4        PARAM_5;        // 0x14
    char            data[];         // 0x18
}
// return value of Comparator is very likely an enum
// enum Ordering {
//  GT = 0;
//  LT = 1;
//  EQ = 2;
// }
typedef UInt32 (* Comparator)(TABLE *, PVOID, PVOID);
typedef PVOID (* Allocator)(TABLE *, UInt32);
typedef void (* Deallocator)(TABLE *, PVOID);