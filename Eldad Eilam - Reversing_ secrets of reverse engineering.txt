Useful links:
    - https://www.wiley.com/en-us/Reversing%3A+Secrets+of+Reverse+Engineering+-p-9780764574818
        Errata and other book resources 
    - https://www.felixcloutier.com/x86/index.html
        x86_64 instruction reference
    - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
        x86_64 cheat sheet
    - https://wiki.osdev.org/
        OSDev wiki

2. Low-level software
p43, Errata: `char szWelcome` should be `char *szWelcome`
when declared as
    char *szWelcome = " .. "
the string will appear in .data section of the ELF executable, however
    const char *szWelcome = " .. "
will appear in (more approperate) .rodata section of the executable.
both compiled with non-optimizing gcc 8.3.0, content of data sections can be printed with 
    readelf -x [.data|.rodata] <FILE_PATH>

p45, x86_64 architecture additionally have 8 general purpose registers
    r8, r9, .., r15
the corresponding lower 32/16/8-bit register names are 
    r8d, r9d, .., r15d // d -> double (word)
    r8w, r9w, .., r15w // w -> a word, as in Intel 8086, the chip that kicked off x86
    r8b, r9b, .., r15b // b -> byte
the original 8 general purpose registers are extended to 64-bit as
    eax -> rax, ebx -> rbx, ..

p50, another common arithmetic instruction used by most optimized compilers is
    LEA, <mem>, <reg>
which write the _address_ of <mem> to <reg>, because of how expressive x86 memory address
expressions are LEA can be used to compute a multiply and up to two additions as a single operation,
for example 
    LEA, [RBX + RSI * 8], EDI
computes (RBX + 8 * RSI) and store it in EDI

p50, TEST instruction is emitted more frequently by gcc, while CMP performs a subtraction TEST 
performs a bitwise AND on the two operands

the EFLAGS register can be directly manipulated by x86 instructions:
    LAHF:   load flags into AH (9 - 16th least significant bits of RAX)
    SAHF:   set flags into AH
    PUSHF:  push flags onto stack
    POPF:   pop flags from stack into ELFAGS register
interestingly the first two instructions are removed in 64-bit mode for the first few 64-bit product
lines by Intel and AMD but later put back

p53, "DWORD PTR" is a size directive, it indicates the size of the data pointed by the memory
address therefore forces the operand to be treated as a pointer to data of certain size, in this
case
    push DWORD PTR [esp + 0x24]
pushes 32 bit (a DWORD) pointed by [esp + 0x24] to the stack. The four size directives in x86 are
    QWORD (64-bit), DWORD (32-bit), WORD (16-bit) and BYTE (8-bit)

p59, the gcc options producing only non-preprocessed listing file is
    gcc -E -fdirectives-only -o <LISTING_PATH> <SOURCE_PATH>
the rustc options producing assembly file is
    rustc --emit asm -C llvm-args="--x86-asm-syntax=intel" <SOURCE_PATH>

3. Windows Fundamentals
Win32 APIs _used to_ follow a cryptic flavor of the Hungarian notation:
    https://learn.microsoft.com/en-us/windows/win32/learnwin32/windows-coding-conventions

p72, narrator: "He didn't update his book." 
Good news is most of the innovative 64-bit desktop architectures didn't survive the competition.
One of the two modern architecture supported by modern Windows, x86_64, is strictly backward
compatible with x86, hence this book is still relevant after all these years.

p73, the speed gap between drives and physical memory narrowed quite a lot recently, a cutting edge
NVMe SSD operates at 7GB/s reading, only a magnitude lower than high end DDR5 memory (~70GB/s), as a
result SSDs are much more feasible as paging storages now.

p88, found an in-depth explanation of the initialization process, including calls into the native
APIs, but not sure whether it's describing Windows NT or another OS with a similar API since the
author referenced multiple times actual source code paths to these APIs which shouldn't be
available:
    https://www.cs.miami.edu/home/burt/journal/NT/processinit.html

p91, "Microsoft wonâ€™t be so concerned about developers using the native API and will soon publish
some level of documentation for it." They didn't.

p91, Zw has no meaning, it's chosen solely to avoid name conflict:
    https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/what-does-the-zw-prefix-mean-

p96, the first method is the ordinary dynamic linking, the second method requires the programmer to
manually load the dll with LoadLibrary then search the header with GetProcAddress, also the callee
must be explicitly exported with __declspec(dllexport) keyword or a DEF file.

p101, reference of PE format:
    https://learn.microsoft.com/en-us/windows/win32/debug/pe-format
Thread Local Storage Table: each thread when initialized is assigned a TLS (Thread Local Storage)
    data area, a TLS index and an entry in the TLS array pointing to its TLS data area, for each
    variable declared as 
        // C
        __declspec (thread) int x = 0;
        // Rust
        thread_local! { 
            // currently immutable only because of lifetime complications
            static x: i32 = 0;
        }
    there's a TLS data object at some fixed offset in the TLS data area, the same binary code
    therefore is able to access different memory location based on the current thread.

p105, that means exception would be thousands of times slower than return code as exception handling
has to go through the system call interface.

p107, line by line explanation of the code:
00411F8A push   ExceptionHandler
    push the pointer to the exception handler onto stack
00411F8F mov    eax, dword ptr fs:[00000000h]
    fs:[00000000h] fetches location 0x0 from the x86 FS segment instead of the default ds segment
    ([<ADDRESS>] is shorthand of ds:[<ADDRESS>]), the FS segment doesn't have hardware defined
    meaning, in WinNT FS:[0x0] points to the current head of the exception handler list
00411F95 push   eax
    push the old head to the stack
00411F96 mov    dword ptr fs:[0], esp
    stack in x86 grows downwards, the current state of stack is:
        esp+0x0     Ptr32   FS:[0x0] ;old head
        esp+0x4     Ptr32   ExceptionHandler
    thus esp points to a valid _EXCEPTION_REGISTRATN_RECORD struct


p107, again
0411F83 push 0FFFFFFFFh
00411F85 push 425090h
    address to two different exception handlers 
00411F8A push offset @ILT+420(__except_handler3) (4111A9h)
    __except_handler3 is part of the C++ runtime, therefore addresss to it is located in the ILT
    (import lookup table)
00411F8F mov eax,dword ptr fs:[00000000h]
00411F95 push eax
    push old head
00411F96 mov dword ptr fs:[0],esp
    the current state of stack is:
        esp+0x0     Ptr32   FS:[0x0] ;old head
        esp+0x4     Ptr32   __except_handler3
        esp+0x8     Ptr32   425090h
        esp+0xc     Ptr32   0FFFFFFFFh
    __except_handler3 when called somehow delegates exceptions to the two exception handlers
    registered

