Useful links:
    - https://www.felixcloutier.com/x86/index.html
        x86_64 instruction reference
    - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
        x86_64 cheat sheet
    - https://wiki.osdev.org/
        OSDev wiki

2. Low-level software
p43, Errata: `char szWelcome` should be `char *szWelcome`
when declared as
    char *szWelcome = " .. "
the string will appear in .data section of the ELF executable, however
    const char *szWelcome = " .. "
will appear in (more approperate) .rodata section of the executable.
both compiled with non-optimizing gcc 8.3.0, content of data sections can be printed with 
    readelf -x [.data|.rodata] <FILE_PATH>

p45, x86_64 architecture additionally have 8 general purpose registers
    r8, r9, .., r15
the corresponding lower 32/16/8-bit register names are 
    r8d, r9d, .., r15d // d -> double (word)
    r8w, r9w, .., r15w // w -> a word, as in Intel 8086, the chip that kicked off x86
    r8b, r9b, .., r15b // b -> byte
the original 8 general purpose registers are extended to 64-bit as
    eax -> rax, ebx -> rbx, ..

p50, another common arithmetic instruction used by most optimized compilers is
    LEA, <mem>, <reg>
which write the _address_ of <mem> to <reg>, because of how expressive x86 memory address
expressions are LEA can be used to compute a multiply and up to two additions as a single operation,
for example 
    LEA, [RBX + RSI * 8], EDI
computes (RBX + 8 * RSI) and store it in EDI

p50, TEST instruction is emitted more frequently by gcc, while CMP performs a subtraction TEST 
performs a bitwise AND on the two operands

the EFLAGS register can be directly manipulated by x86 instructions:
    LAHF:   load flags into AH (9 - 16th least significant bits of RAX)
    SAHF:   set flags into AH
    PUSHF:  push flags onto stack
    POPF:   pop flags from stack into ELFAGS register
interestingly the first two instructions are removed in 64-bit mode for the first few 64-bit product
lines by Intel and AMD but later put back

p53, "DWORD PTR" is a size directive, it indicates the size of the data pointed by the memory
address therefore forces the operand to be treated as a pointer to data of certain size, in this
case
    push DWORD PTR [esp + 0x24]
pushes 32 bit (a DWORD) pointed by [esp + 0x24] to the stack. The four size directives in x86 are
    QWORD (64-bit), DWORD (32-bit), WORD (16-bit) and BYTE (8-bit)

p59, the gcc options producing only non-preprocessed listing file is
    gcc -E -fdirectives-only -o <LISTING_PATH> <SOURCE_PATH>