Chapter 1
1.1.1
a compiler transforms the program (source file) in one language to another language 
a interpreter directly executes the program in one language

1.1.2
a.  by transforming directly to machine code, the program produced by a compiler usually runs faster than interpreted
    add a new backend to a compiler is usually easier than porting a whole interpreter to a new target platform
        especially when the target platform is some microcontroller which is not powerful enough to run the interpreter
        (lacking memory / storage, etc.)
b.  a basic interpreter is easiler to write compared to a basic compiler
        (in the sense that an interpreter don't have to consider the structure of the target language)
    the source code is cross-platform among platforms on which the interpreter is implemented
    by personal experience today a compiler can produce almost equally good error messages compared to an interpreter
    the structure of the program is controlled by the interpreter, makes certain techniques easier than compiled lang
        e.g. hot reloading in javascript, a C++ equivalent has to compile sources at runtime

1.1.3
today assembly code provides quite a lot abstraction over machine language
the output program tends to be more meaningful and compact, also a little bit more compatibility

1.1.4
C is usually the first high-level language a platform will ever support
    if a language can be translated to C it can be executed on any platform that supports C
C has much simpler structure than most of the high-level languages
many languages are influenced by C and bears some degree of resemblance to C, the translation will be easier

1.1.5
expand macros 
transfer tags to literal memory locations
transfer numerial constants from base 10 to hex
translate instructions to machine op code
do some obvious optimizations (is the compiler produced low quality assembly code, which is unlikely)

1.3.1
imperative: C, Cobol, Fortran, Perl 
declarative: Lisp, ML
von Neumann: all of them
object-oriented: C++, Java, Python, VB
functional: Lisp, ML
third-generation: all of them
fourth-generation: none
scripting: Perl, Python