//  unsolved: 
//      3.4.9.d 
//      4.2.8.c

Chapter 1
1.1.1
a compiler transforms the program (source file) in one language to another language 
a interpreter directly executes the program in one language

1.1.2
a.  by transforming directly to machine code, the program produced by a compiler usually runs faster than interpreted
    add a new backend to a compiler is usually easier than porting a whole interpreter to a new target platform
        especially when the target platform is some microcontroller which is not powerful enough to run the interpreter
        (lacking memory / storage, etc.)
b.  a basic interpreter is easiler to write compared to a basic compiler
        (in the sense that an interpreter doesn't have to consider the structure of the target language)
    the source code is cross-platform among platforms on which the interpreter is implemented
    by personal experience today a compiler can produce almost equally good error messages compared to an interpreter
    the structure of the program is controlled by the interpreter, makes certain techniques easier than compiled lang
        e.g. hot reloading in javascript, a C++ equivalent has to compile sources at runtime

1.1.3
today assembly code provides quite a lot abstraction over machine language
the output program tends to be more meaningful and compact, also a little bit more compatible

1.1.4
C is usually the first high-level language a platform will ever support
if a language can be translated to C it can be executed on any platform that supports C
C has much simpler structure than most of the high-level languages
many languages are influenced by C and bears some degree of resemblance to C, the translation will be easier

1.1.5
expand macros 
transfer tags to literal memory locations
transfer numerial constants from base 10 to hex
translate instructions to machine op code
do some obvious optimizations (if the compiler produced low quality assembly code, which is unlikely)

1.3.1
imperative: C, Cobol, Fortran, Perl 
declarative: Lisp, ML
von Neumann: all of them
object-oriented: C++, Java, Python, VB
functional: Lisp, ML
third-generation: all of them
fourth-generation: none
scripting: Perl, Python

1.6.1
w = 13, x = 11, y = 13, z = 11

1.6.2
w = 9, x = 7, y = 13, z = 11

1.6.3
B1.w: B1, B2
B1.x: B1
B1.y: B1, B2, B3, B4
B1.z: B1, B4
B2.x: B2
B2.z: B2, B3
B4.w: B4, B5
B4.x: B4, B5
other declarations have a scope consists of only the block they belongs to

1.6.4
3
2

Chapter 2
2.2.1
a.  S -> SS* -> SS+S* -> aa+S* -> aa+a*
b.  S---S---S---a
    |   |
    |   ----S---a
    |   |
    |   ----+
    |
    ----S---a
    |
    ----*
c.  all expressions in postfix notation with a single digit a and two operators + and *

2.2.2
a.  0^n1^n for n >= 1
    if 0^n1^n can be generated from S, the last step must be 0^(n-1)011^(n-1) as it is the only terminal rule
    replace S -> 01 by S -> 0S1 -> 0011 then 0^(n+1)1^(n+1) can also be generated
    conversely, assume for all string T with length <= n generated by S, T ∈ {0^k1^k | k >= 1}
    for string of length n+2, S -> 0S1 ∈ {0^k1^k | k >= 1}
b.  prefix version of 2.2.1 by symmetry
c.  any number of correctly paired parentheses
    assume for string with <= n pair of correctly paired parentheses can be generated from S
    let T be a string with n+1 pair of correctly paired parentheses
    T must start with (, and first left parenthesis must be closed somewhere into T,
    hence T = (T0)T1, where T0 and T1 are string of correctly paired parentheses with smaller size
    by induction T0 and T1 can be generated from S
    also S -> S(S)S -> ε(T0)T1, so T can be generated from S
    conversely, let L be the set of strings of correctly paired parentheses
    induct on height of parse tree, S -> S(S)S is also correctly paired, so S(S)S ∈ L
d.  any string with equal number of a and b
    assume any string with length <= 2n and equal number of a and b can be generated from S
    let T be a string with length 2(n+1) with equal number of a and b
    if T starts with a:
        let a(T) and b(T) denote the number of a and b in the string T
        let Ti be the prefix of T with length i
        let k be the smallest index that a(Tk) = b(Tk),
        k must exist since T = T2n+2 and a(T) = b(T)
        T[k] must be b:
            define a function f(i) = a(Ti) - b(Ti), 0 <= i <= k
            if T[k] = a, f(k-1) = -1, f(1) = 1
            |f(i+1) - f(i)| <= 1, the value of f(i) can change at most by 1 for two consecutive indices
            so there must be some 1 < i < k-1 where f(i) = 0, k is not the smallest index with a(Tk) = b(Tk)
        therefore T = aT1bT2 where both T1 and T2 has equal number of a and b
        T can be generated by the rule S -> aSbS
    if T starts with b: symmetric
    conversely, induct on height of parse tree, let L = {T | T is a string with equal number of a and b}
    S -> aSbS ∈ L
    S -> bSaS ∈ L
    S -> ε ∈ L
e.  replace space with *, * with some arbitrary unary operator (e.g. negate)
    an ambiguous grammar for infix arithmetic expressions

2.2.3
a is not ambiguous:
    there are only one non-terminating rule with only one non-terminating symbol
b is not ambiguous:
    prefix (and postfix) arithmetic expressions have fixed order of evaluation
c is ambiguous:
    ()() can be generated by 
        S -> S(S)S -> ε(ε)S -> ()(), or
        S -> S(S)S -> S(ε)ε -> ()()
d is ambiguous:
    abab can be generated by
        S -> aSbS -> aSb -> abSaSb -> abab, or
        S -> aSbS -> abS -> abaSbS -> abab
e is ambiguous:
    no precedence is specified, S + SS can be parsed as (S + S)S or S + (SS)

2.2.4
a.  S -> S S + | S S - | S S * | S S / | digit
    justified  by text
b.  S -> S , id | id
    justified by text
c.  S -> id , S | id
    justified by text
d.  expr -> expr + term | expr - term | term
    term -> term * factor | term / factor | factor
    factor -> id | num | ( expr )
    justified by text
e.  expr -> expr + term | expr - term | term
    term -> term * unary | term / unary | unary
    unary -> - factor | + factor | factor
    factor -> id | num | ( expr )

2.2.5
a.  induct on the height of parse tree, let L = {b | b = 0 mod 3}
    num -> 11 ∈ L
    num -> 1001 ∈ L
    num -> num 0
        let num -> B0, by induction B = 0 mod 3
        B0 = B * 2 = 0 mod 3
    num -> num num
        let num -> B0B1, by induction B0 = B1 = 0 mod 3
        B0B1 = B0 * 2^n + B1 = 0 mod 3
b.  no, 3^10 = 1110011010101001 cannot be generated
    tested in https://web.stanford.edu/class/archive/cs/cs103/cs103.1156/tools/cfg/

2.2.6
up to 3999
https://en.wikipedia.org/wiki/Roman_numerals
ε is not a legal roman numeral and there's no zero in roman numerial
S   -> TN H E O | HN E O | EN O | ON
T   -> TN | ε
TN  -> M | MM | MMM
H   -> HN | ε
HN  -> C | CC | CCC | CD | D | DC | DCC | DCCC | CM
E   -> EN | ε
EN  -> X | XX | XXX | XL | L | LX | LXX | LXXX | XC
O   -> ON | ε
ON  -> I | II | III | IV | V | VI | VII | VIII | IX

2.3.1
expr -> expr1 + term        expr.t = '+' || expr1.t || term.t
expr -> expr1 - term        expr.t = '-' || expr1.t || term.t
expr -> term                expr.t = term.t
term -> term * factor       term.t = '*' || term.t || factor.t
term -> term / factor       term.t = '/' || term.t || factor.t
term -> factor              term.t = factor.t
factor -> id                factor.t = id.t
factor -> num               factor.t = num.t
factor -> ( expr )          factor.t = expr.t

2.3.2
// added parentheses to each expression so precedence no longer matters
expr -> expr1 expr2 +       expr.t = '(' || expr1.t || '+' || expr2.t || ')'
expr -> expr1 expr2 -       expr.t = '(' || expr1.t || '-' || expr2.t || ')'
expr -> expr1 expr2 *       expr.t = '(' || expr1.t || '*' || expr2.t || ')'
expr -> expr1 expr2 /       expr.t = '(' || expr1.t || '/' || expr2.t || ')'
expr -> factor              expr.t = factor.t
factor -> id                factor.t = id.t
factor -> num               factor.t = num.t

2.3.3
since it will be tidious to list them all
let T, H, E, O be the mapping between decimal digits and roman digits in different positions
e.g. T(1) = M, H(3) = CCC, O(4) = IV
again this grammar cannot generate 0 as there's no representation of 0 in roman numeral
S -> ND1D2D3        S.t = T(N.t) || H(D1.t) || E(D2.t) || O(D3.t)
S -> ND1D2          S.t = H(N.t) || E(D1.t) || O(D2.t)
S -> ND             S.t = E(N.t) || O(D.t)
S -> N              S.t = O(N.t)
D -> N              D.t = N.t
D -> 0              D.t = 0
N -> 1 .. 9         N.t = 1 .. 9

2.3.4
S   -> TN H E O | HN E O | EN O | ON                    S.t     = TN.t + H.t + E.t + O.t | HN.t + E.t + O.t | ...
T   -> TN | ε                                           T.t     = TN.t | 0
TN  -> M | MM                                           TN.t    = 1000 | 2000
H   -> HN | ε                                           H.t     = HN.t | 0
HN  -> C | CC | CCC | CD | D | DC | DCC | DCCC | CM     HN.t    = 100 ... 900
E   -> EN | ε                                           E.t     = EN.t | 0
EN  -> X | XX | XXX | XL | L | LX | LXX | LXXX | XC     EN.t    = 10 ... 90
O   -> ON | ε                                           O.t     = ON.t | 0
ON  -> I | II | III | IV | V | VI | VII | VIII | IX     ON.t    = 1 ... 9

2.3.5
expr -> expr1 expr2 +       expr.t = '+' || expr1.t || expr2.t
expr -> expr1 expr2 -       expr.t = '-' || expr1.t || expr2.t
expr -> expr1 expr2 *       expr.t = '*' || expr1.t || expr2.t
expr -> expr1 expr2 /       expr.t = '/' || expr1.t || expr2.t
expr -> factor              expr.t = factor.t
factor -> id                factor.t = id.t
factor -> num               factor.t = num.t

2.4.1
./Dragon_Book/chapter_2/parsers
tested against strings generated by https://web.stanford.edu/class/archive/cs/cs103/cs103.1156/tools/cfg/
a.  trivial
b.  the grammar is left-recursive, it is first transformed to:
        R -> (R)R | ε
c.  two of the productions share the same lookahead symbol '0'
    look ahead two tokens instead of 1 to distinguish the two cases

2.6.1 - 2.6.3
./Dragon_Book/chapter_2/lexer

2.8.1
./Dragon_Book/chapter_2/codegen

2.8.2
it may automatically insert a conversion from integer to boolean value
three address code is special in the sense that it has concrete definition of boolean values
while most assembly languages have conditional jump instructions that branches on numbers, or relation between numbers
so the grammar of C is more natural

3.1.1
./Dragon_Book/chapter_3/lexers/src/simple_c.rs
<Ty, "float">
<Id, "limitedSquare">
<Punctuation, "(">
<Id, "x">
<Punctuation, ")">
<Ty, "float">
<Id, "x">
<Punctuation, ";">
<Punctuation, "{">
<Keyword, "return">
<Punctuation, "(">
<Id, "x">
<Operator, "<=">
<Operator, "-">
<Constant(10.0), "10.0">
<Operator, "||">
<Id, "x">
<Operator, ">=">
<Constant(10.0), "10.0">
<Punctuation, ")">
<Operator, "?">
<Constant(100.0), "100">
<Operator, ":">
<Id, "x">
<Operator, "*">
<Id, "x">
<Punctuation, ";">
<Punctuation, "}">

3.1.2
./Dragon_Book/chapter_3/lexers/src/html.rs
<Text, "Here is a photo of ">
<Start("B"), "<B>">
<Text, "my house">
<End("B"), "</B>">
<Text, ":\n">
<Start("P"), "<P>">
//  a lexer of HTML supposedly cannot and should not distinguish between void and start tag
//  that requires further information that's only available during parsing
<Start("IMG"), "<IMG SRC = \"house.gif\">">
<Start("BR"), "<BR>">
<Text, "\nSee ">
<Start("A"), "<A HREF = \"morePix.html\">">
<Text, "More Pictures">
<End("A"), "</A>">
<Text, " if you\nliked that one.">
<Start("P"), "<P>">

3.3.1
a.  i.  https://en.cppreference.com/w/c/language/translation_phases
        the source code can be written in any character set that's supported by the compiler
        then the source code is translated in phase 1 of compilation to a character set of 96 characters:
            a) 5 whitespace characters (space, horizontal tab, vertical tab, form feed, new-line)
            b) 10 digit characters from '0' to '9'
            c) 52 letters from 'a' to 'z' and from 'A' to 'Z'
            d) 29 punctuation characters: _ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " ’
    ii. C99: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf 6.4.4.1
        integer-constant: 
            decimal-constant integer-suffix?
            octal-constant integer-suffix?
            hexadecimal-constant integer-suffix?
        decimal-constant:
            nonzero-digit
            decimal-constant digit
        octal-constant:
            0   // what
            octal-constant octal-digit
        hexadecimal-constant:
            hexadecimal-prefix hexadecimal-digit
            hexadecimal-constant hexadecimal-digit
        hexadecimal-prefix: 0x | 0X
        nonzero-digit: [1-9]
        octal-digit: [0-7]
        hexadecimal-digit: [0-9a-fA-F]
        integer-suffix:
            unsigned-suffix long-suffix?
            unsigned-suffix long-long-suffix
            long-suffix unsigned-suffix?
            long-long-suffix unsigned-suffix?
        unsigned-suffix: u | U
        long-suffix: l | L
        long-long-suffix: ll | LL
        http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf 6.4.4.2
        floating-constant:
            decimal-floating-constant
            hexadecimal-floating-constant
        decimal-floating-constant:
            fractional-constant exponent-part? floating-suffix?
            digit-sequence exponent-part floating-suffix?
        hexadecimal-floating-constant:
            hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part floating-suffix?
            hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part floating-suffix?
        fractional-constant:
            digit-sequence? . digit-sequence
            digit-sequence .
        exponent-part:
            e sign? digit-sequence
            E sign? digit-sequence
        sign: + | -
        digit-sequence:
            digit
            digit-sequence digit
        hexadecimal-fractional-constant:
            hexadecimal-digit-sequence? . hexadecimal-digit-sequence
            hexadecimal-digit-sequence .
        binary-exponent-part:
            p sign? digit-sequence
            P sign? digit-sequence
        hexadecimal-digit-sequence:
            hexadecimal-digit
            hexadecimal-digit-sequence hexadecimal-digit
            floating-suffix: f | F | l | L
    iii.C99: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf 6.4.2
        identifier:
            identifier-nondigit
            identifier identifier-nondigit
            identifier digit
        identifier-nondigit:
            nondigit
            universal-character-name
            other implementation-defined characters
        nondigit: [a-zA-Z_]
        universal-character-name:
            \u hex-quad
            \U hex-quad hex-quad
        hex-quad:
            hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
        digit: [0-9]
b.  i.  https://en.cppreference.com/w/cpp/language/translation_phases
        additionally supports unicode characters
    ii. integer literal: https://en.cppreference.com/w/cpp/language/integer_literal
        additionally supports binary literals
        binary-constant:
            binary-literal integer-suffix?
        binary-literal: (0b | 0B) (0 | 1)+
        float literal: https://en.cppreference.com/w/cpp/language/floating_literal
        totally different from C99
        floating-constant:
            digit-sequence exponent suffix?
            digit-sequence . exponent? suffix?
            digit-sequence? . digit-sequence exponent?
            0x | 0X hex-digit-sequence exponent suffix? // since C++17
            0x | 0X hex-digit-sequence . exponent suffix? // since C++17
            0x | 0X hex-digit-sequence? . hex-digit-sequence exponent suffix? // since C++17
        digit-sequence: [0-9]+
        exponent: 
            e | E exponent-sign? digit-sequence
            p | P exponent-sign? digit-sequence // since C++17
        exponent-sign: + | -
        suffix: f | F | l | L
        hex-digit-sequence: [0-9a-fA-F]+
    iii.https://en.cppreference.com/w/cpp/language/identifiers
        additionally supports most unicode characters
c.  i.  C# 5.0: https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-334.pdf 7.1
        unicode in utf-8 encoding
    ii. https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-334.pdf 7.4.5.3
        integer-literal::
            decimal-integer-literal
            hexadecimal-integer-literal
        decimal-integer-literal::
            decimal-digits integer-type-suffix?
        decimal-digits::
            decimal-digit
            decimal-digits decimal-digit
        decimal-digit:: [0-9]
        integer-type-suffix:: u | U | l | L | (u | U) (l | L) | (l | L) (u | U)
        hexadecimal-integer-literal::
            0x hex-digits integer-type-suffix?
            0X hex-digits integer-type-suffix?
        hex-digits::
            hex-digit
            hex-digits hex-digit
        hex-digit:: [0-9a-fA-F]
        //  C# has real literals instead of float literals
        https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-334.pdf 7.4.5.4
        real-literal::
            decimal-digits . decimal-digits exponent-part? real-type-suffix?
            . decimal-digits exponent-part? real-type-suffix?
            decimal-digits exponent-part real-type-suffix?
            decimal-digits real-type-suffix
        exponent-part::
            e sign? decimal-digits
            E sign? decimal-digits
        sign:: + | -
        //  m | M indicates decimal type, a precise base-10 representation of fractional numbers in C#
        real-type-suffix:: f | F | d | D | m | M
    iii.https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-334.pdf 7.4.3
        identifier::
            available-identifier
            @ identifier-or-keyword
        available-identifier::
            An identifier-or-keyword that is not a keyword
        identifier-or-keyword::
            identifier-start-character identifier-part-characters?
        identifier-start-character::
            letter-character
            underscore-character
        underscore-character::
            _ (the underscore character U+005F)
            A unicode-escape-sequence representing the character U+005F
        identifier-part-characters::
            identifier-part-character
            identifier-part-characters identifier-part-character
        identifier-part-character::
            letter-character
            decimal-digit-character
            connecting-character
            combining-character
            formatting-character
        letter-character::
            A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl
            A unicode-escape-sequence representing a character of classes Lu, Ll, Lt, Lm, Lo, or Nl
        combining-character::
            A Unicode character of classes Mn or Mc
            A unicode-escape-sequence representing a character of classes Mn or Mc
        decimal-digit-character::
            A Unicode character of the class Nd
            A unicode-escape-sequence representing a character of the class Nd
        connecting-character::
            A Unicode character of the class Pc
            A unicode-escape-sequence representing a character of the class Pc
        formatting-character::
            A Unicode character of the class Cf
            A unicode-escape-sequence representing a character of the class Cf
d.  i.  FORTRAN 90: http://www2.southeastern.edu/Academics/Faculty/kyang/Cmps401/P1Fortran/Resources/N692.pdf 3.1
        (1) Control characters (“newline”, for example)
        (2) Graphic characters
            (a) Letters: [A-Z], case insensitive
            (b) Digits: [0-9]
            (c) Underscore: _
            (d) Special characters: space : = ! + " - % * & / ; ( < ) > , ? . $ ’             
            (e) Other characters (only in character / string constants, comments and input / output records)
    ii. http://www2.southeastern.edu/Academics/Faculty/kyang/Cmps401/P1Fortran/Resources/N692.pdf 4.3.1.1
        signed-int-literal-constant:
            sign? int-literal-constant
            boz-literal-constant
        int-literal-constant:
            digit-string (_ kind-param)?
        digit-string: [0-9]+
        kind-param:
            digit-string 
            scalar-int-constant-name // dependent on platform (e.g. "SHORT")
        sign: + | -
        boz-literal-constant:   // in certain statements, must be non-negative
            binary-constant
            octal-constant
            hex-constant
        binary-constant: B (' (0 | 1)+ ')?
        octal-constant: O (' [0-7]+ ')?
        hex-constant: Z (' [0-8A-F]+ ')?
        http://www2.southeastern.edu/Academics/Faculty/kyang/Cmps401/P1Fortran/Resources/N692.pdf 4.3.1.2
        signed-real-literal-constant:
            sign? real-literal-constant
        real-literal-constant:
            significand (exponent-letter exponent)? (_ kind_param)?
            digit-string exponent-letter exponent (_ kind_param)?
        significand:
            digit-string . digit-string?
            . digit-string
        exponent-letter: E | D
        exponent:
            signed-digit-string
        signed-digit-string: sign? digit-string
        FORTRAN 90 also supports complex constant
    iii.FORTRAN 90: http://www2.southeastern.edu/Academics/Faculty/kyang/Cmps401/P1Fortran/Resources/N692.pdf 3.2.2
        called "name" instead of "identifer"
        name: 
            [A-Z] alphanumeric-character*
        alphanumeric-character: [0-9A-Z_]   // called alphanumeric but includes underscore
e.  i.  Java SE 11: https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.1
        unicode in utf-16 encoding
    ii. https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.1
        IntegerLiteral:
            DecimalIntegerLiteral 
            HexIntegerLiteral 
            OctalIntegerLiteral 
            BinaryIntegerLiteral
        DecimalIntegerLiteral:
            DecimalNumeral IntegerTypeSuffix?
        HexIntegerLiteral:
            HexNumeral IntegerTypeSuffix?
        OctalIntegerLiteral:
            OctalNumeral IntegerTypeSuffix?
        BinaryIntegerLiteral:
            BinaryNumeral IntegerTypeSuffix?
        IntegerTypeSuffix: l | L
        DecimalNumeral:
            0 
            NonZeroDigit Digits?
            NonZeroDigit Underscores Digits
        NonZeroDigit: [1-9]
        Digits:
            Digit 
            Digit DigitsAndUnderscores? Digit
        Digit:
            0 
            NonZeroDigit
        DigitsAndUnderscores:
            DigitOrUnderscore {DigitOrUnderscore}
            DigitOrUnderscore:
            Digit 
            _
        Underscores: _+
        HexNumeral:
            0 x HexDigits 
            0 X HexDigits
        HexDigits:
            HexDigit 
            HexDigit HexDigitsAndUnderscores? HexDigit
        HexDigit: [0-9a-fA-F]
        HexDigitsAndUnderscores:
            HexDigitOrUnderscore+
        HexDigitOrUnderscore:
            HexDigit 
            _
        OctalNumeral:
            0 OctalDigits 
            0 Underscores OctalDigits
        OctalDigits:
            OctalDigit 
            OctalDigit OctalDigitsAndUnderscores? OctalDigit
        OctalDigit: [0-7]
        OctalDigitsAndUnderscores:
            OctalDigitOrUnderscore+
        OctalDigitOrUnderscore:
            OctalDigit 
            _
        BinaryNumeral:
            0 b BinaryDigits 
            0 B BinaryDigits
        BinaryDigits:
            BinaryDigit 
            BinaryDigit BinaryDigitsAndUnderscores? BinaryDigit
        BinaryDigit: 0 | 1
        BinaryDigitsAndUnderscores:
            BinaryDigitOrUnderscore+
        BinaryDigitOrUnderscore:
            BinaryDigit 
            _
        https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.2
        FloatingPointLiteral:
            DecimalFloatingPointLiteral 
            HexadecimalFloatingPointLiteral
        DecimalFloatingPointLiteral:
            Digits . Digits? ExponentPart? FloatTypeSuffix? 
            . Digits ExponentPart? FloatTypeSuffix? 
            Digits ExponentPart FloatTypeSuffix? 
            Digits ExponentPart? FloatTypeSuffix
        ExponentPart:
            ExponentIndicator SignedInteger
            ExponentIndicator: e | E
        SignedInteger:
            Sign? Digits
        Sign: + | -
        FloatTypeSuffix: f | F | d | D
        HexadecimalFloatingPointLiteral:
            HexSignificand BinaryExponent FloatTypeSuffix?
        HexSignificand:
            HexNumeral .? 
            0 x HexDigits? . HexDigits 
            0 X HexDigits? . HexDigits
        BinaryExponent:
            BinaryExponentIndicator SignedInteger
        BinaryExponentIndicator: p | P
    iii.https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.8
        Identifier:
            IdentifierChars but not a Keyword or BooleanLiteral or NullLiteral
        IdentifierChars:
            JavaLetter JavaLetterOrDigit*
        JavaLetter:
            any Unicode character that is a "Java letter"
        JavaLetterOrDigit:
            any Unicode character that is a "Java letter-or-digit"
f.  i.  ANSI Common Lisp: http://cvberry.com/downloads/cl-ansi-standard-draft-w-sidebar.pdf 2.1.3
        96 in total
        (a) Non-graphic character NEWLINE
        (b) Graphic character SPACE
        (c) Letters: [a-zA-Z]
        (b) Digits: [0-9]
        (c) Special characters: ! $ " ’ ( ) , _ - . / : ; ? + < = > # % & * @ [ \ ] { | } ‘ ^ ~
    ii. http://cvberry.com/downloads/cl-ansi-standard-draft-w-sidebar.pdf 2.3.1
        numeric-token:
            integer
            ratio
            float
        integer:
            sign? decimal-digit+ decimal-point
            sign? digit+
        ratio:
            sign? digit+ slash digit+
        float:
            sign? decimal-digit* decimal-point decimal-digit+ exponent?
            sign? decimal-digit+ (decimal-point decimal-digit*)? exponent
        exponent:
            exponent-marker sign? digit+
        sign: + | -
        slash: /
        decimal-point: .
        exponent-marker: e | E | d | D | f | F | l | L | s | S
        decimal-digit: [0-9]
        digit: [0-9a-zA-Z] 
        // common lisp supports up to base-36, the radix of the input is controlled by a macro character
        // e.g. #O10 = 8, #B1101 = 13
        // common lisp also supports complex number in a similar way
        // e.g. #C(3 -5)
    iii.http://cvberry.com/downloads/cl-ansi-standard-draft-w-sidebar.pdf 2.3.4
        "Any token that is not a potential number, does not contain a package marker, and does not consist
        entirely of dots will always be interpreted as a symbol"
        that means all of the following are valid symbols in common lisp:
            FROBBOZ
            frobboz
            fRObBoz
            unwind-protect
            +$
            1+
            +1
            pascal
            file.rel.43
            \(
            \+1
            +\1
            \frobboz
            3.14159265\s0
            3.14159265\S0
            3.14159265s0
            APL\\360
            apl\\360
            \(b^2\)\ -\ 4*a*c
            \(\b^2\)\ -\4*\a*\c
            |"|
            |(b^2) - 4*a*c|
            |frobboz|
            |APL\360|
            |APL\\360|
            |apl\\360|
            |\|\||
            |(B^2) - 4*A*C|
            |(b^2) - 4*a*c|
g.  i.  SQL 2011: https://jakewheat.github.io/sql-overview/sql-2011-foundation-grammar.html#_5_1_sql_terminal_character
        <SQL language character>:
            <simple Latin letter>
            <digit>
            <SQL special character>
        <simple Latin letter>: [a-zA-Z]
        <digit>: [0-9]
        <SQL special character>: // details omitted
            <space>
            <double quote>
            <percent>
            <ampersand>
            <quote>
            <left paren>
            <right paren>
            <asterisk>
            <plus sign>
            <comma>
            <minus sign>
            <period>
            <solidus>
            <colon>
            <semicolon>
            <less than operator>
            <equals operator>
            <greater than operator>
            <question mark>
            <left bracket>
            <right bracket>
            <circumflex>
            <underscore>
            <vertical bar>
            <left brace>
            <right brace>
    ii. https://jakewheat.github.io/sql-overview/sql-2011-foundation-grammar.html#signed-numeric-literal
        <signed numeric literal>: 
            <sign>? <unsigned numeric literal>
        <sign>: + | -
        <unsigned numeric literal>:
            <exact numeric literal>
            <approximate numeric literal> 
        <exact numeric literal>:
            <unsigned integer> (. <unsigned integer>?)?
            . <unsigned integer>
        <unsigned integer>:
            <digit>+
        <approximate numeric literal>:
            <mantissa> E <exponent>
        <mantissa>:
            <exact numeric literal>
        <exponent>:
            <signed integer>
        <signed integer>:
            <sign>? <unsigned integer>
    iii.https://jakewheat.github.io/sql-overview/sql-2011-foundation-grammar.html#_5_4_names_and_identifiers
        <SQL language identifier>:
            <SQL language identifier start> <SQL language identifier part>*
        <SQL language identifier start>:
            <simple Latin letter>
        <SQL language identifier part>:
            <simple Latin letter>
            <digit>
            <underscore>
// one more
h.  i.  Rust https://doc.rust-lang.org/reference/input-format.html
        unicode in utf-8 encoding
    ii. https://doc.rust-lang.org/reference/tokens.html#integer-literals
        INTEGER_LITERAL:
            ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) INTEGER_SUFFIX?
        DEC_LITERAL:
            DEC_DIGIT (DEC_DIGIT|_)*
        TUPLE_INDEX:
            0 | NON_ZERO_DEC_DIGIT DEC_DIGIT*
        BIN_LITERAL:
            0b (BIN_DIGIT|_)* BIN_DIGIT (BIN_DIGIT|_)*
        OCT_LITERAL:
            0o (OCT_DIGIT|_)* OCT_DIGIT (OCT_DIGIT|_)*
        HEX_LITERAL:
            0x (HEX_DIGIT|_)* HEX_DIGIT (HEX_DIGIT|_)*
        BIN_DIGIT: [0-1]
        OCT_DIGIT: [0-7]
        DEC_DIGIT: [0-9]
        NON_ZERO_DEC_DIGIT: [1-9]
        HEX_DIGIT: [0-9 a-f A-F]
        INTEGER_SUFFIX:
            u8 | u16 | u32 | u64 | u128 | usize | i8 | i16 | i32 | i64 | i128 | isize
        FLOAT_LITERAL:
            DEC_LITERAL . (not immediately followed by ., _ or an identifier)
            DEC_LITERAL FLOAT_EXPONENT
            DEC_LITERAL . DEC_LITERAL FLOAT_EXPONENT?
            DEC_LITERAL (. DEC_LITERAL)? FLOAT_EXPONENT? FLOAT_SUFFIX
        FLOAT_EXPONENT:
            (e|E) (+|-)? (DEC_DIGIT|_)* DEC_DIGIT (DEC_DIGIT|_)*
        FLOAT_SUFFIX:
            f32 | f64
    iii.https://doc.rust-lang.org/reference/identifiers.html
        IDENTIFIER:
            NON_KEYWORD_IDENTIFIER | RAW_IDENTIFIER
        NON_KEYWORD_IDENTIFIER: 
            IDENTIFIER_OR_KEYWORD Except a strict or reserved keyword
        IDENTIFIER_OR_KEYWORD:
            [a-zA-Z] [a-zA-Z0-9_]*
            _ [a-z A-Z 0-9 _]+
        RAW_IDENTIFIER: 
            r# IDENTIFIER_OR_KEYWORD Except crate, extern, self, super, Self

3.3.2
a.  string consists of a and b delimited by two a
b.  any string consists of a and b
c.  any string consists of a and b, followed by aaa, aab, aba or abb
d.  any string from {a, b} with exactly 3 b
e.  double -> (aa|bb)*:
        strings consists of aa and bb
    a sequence of doubles intervened by an even number of ab or ba    

3.3.3
a.  n + 1
b.  n + 1
c.  n - 1
d.  depends on the string
    at most n(n+1)/2 if all characters are distinct
    at least n + 1 if all characters are the same
e.  depends on the string
    at most 2^n if all charactersr are distinct
    at least n + 1 if all characters are the same

3.3.4
(s|S)(e|E)(l|L)(e|E)(c|C)(t|T)

3.3.5
a.  define \l = [a-z]
    \l*a\l*e\l*i\l*o\l*u\l*
b.  a*b*c*d* ... z*
c.  define
        quoted -> " [^"]* "
        stars -> \*+[^\/]
        other -> [^"*]
    \/\* (\*?quoted | stars | other)* \*?\*\/
d.  as there is always language-preserving transition from regex -> NFA -> DFA -> regex
    define:
        f(i) -> [0-9]*i[0-9]*i[0-9]*
    r = f(0) | ... | f(9) is the language with repeating digits
    the complement of r can be represented by a regex somehow
    by transforming r to a DFA, take the complement and transform to regex again
e.  again define:
        f(i) -> [0-9]*i[0-9]*i[0-9]*
    let g(i, j) be the regular expression of f(i) ∩ f(j)
    r = ∪(i != j)g(i, j)
f.  a corresponding DFA (can be previewd on http://ivanzuzak.info/noam/webapps/fsm2regex/):
        #states
        eaeb
        eaob
        oaeb
        oaob
        #initial
        eaeb
        #accepting
        eaob
        #alphabet
        a
        b
        #transitions
        eaeb:a>oaeb
        eaeb:b>eaob
        eaob:a>oaob
        eaob:b>eaeb
        oaeb:a>eaeb
        oaeb:b>oaob
        oaob:a>eaob
        oaob:b>oaeb
    which can be translated to the following regex:
        (a(bb)*a|(b|a(bb)*ba)(a(a|b(bb)*ba))*(b|ab(bb)*a))*(b|a(bb)*ba)(a(a|b(bb)*ba))*(ε|a(a|b(bb)*ba))
g.  define 
        piece -> [KQRBNS]?
        rank -> [1-8]
        file -> [a-h]
        capture -> x
        pos -> file rank
    piece (rank | file | pos)? capture? pos
    // may match impossible moves, e.g. Ba1xa8
    // the regular expression for correct moves will be very tedious to write
h.  a corresponding DFA:
        #states
        s
        a1
        b1
        b2
        #initial
        s
        #accepting
        s
        a1
        b1
        #alphabet
        a
        b
        #transitions
        s:a>a1
        s:b>s
        a1:a>a1
        a1:b>b1
        b1:a>a1
        b1:b>b2
        b2:a>b2
        b2:b>b2
    which yields the following regex:
        b*(a((a|ba)*b|(a|ba)*)|b)?
i.  simply change the transition in part h
        b1:a>a1
    to
        b1:a>b1
    b*(a(a*ba*|a*)|b)?

3.3.6
a.  [a-jA-J]
b.  [b-df-hj-mp-tv-z]
c.  [0-9A-F]
d.  [.?!:]

3.3.7
\"\\

3.3.8
[^c] is equivalent to [Σ - {c}]

3.3.9
r{m, n} = ∪(i = m .. n)r{i}
r{i} = r^i

3.3.10
a.  by parsing
    ^ in a character group means complement, otherwise left of a line
b.  by definition in the text, regular expressions always match the input as a whole, ^ and $ are implicit
    a regex r without ^ and $ in regex engines is equivalent to .*r.* in textbook defintion

3.3.11
's', '\c', [s] -> same in regex
* -> .*
? -> .

3.3.12
ea -> a for any a ∈ Σ
_ -> .
% -> .*

3.4.1 - 3.4.2
http://ivanzuzak.info/noam/webapps/fsm2regex/

3.4.3
failure function for abababaab is [0, 0, 1, 2, 3, 4, 5, 1, 2]
failure function for aaaaaa is [0, 1, 2, 3, 4, 5]
failure function for abbaabb is [0, 0, 0, 1, 1, 2, 3]

3.4.4 - 3.4.5
refer CLRS 32.4

3.4.6
abababaab contains an occurrence of ababaa at index 2
abababbaa contains no occurrence of ababaa

3.4.7 - 3.4.8
refer CLRS 32.4

3.4.9
a.  len(sn) = len(sn-1) + len(sn-2)
    len(s1) = 1
    len(s2) = 1
    hence len(sn) is the nth fibonacci number
b.  [0, 0, 1, 1, 2, 3, 2, 3]
c.  [0, 0, 1, 1, 2, 3, 2, 3, 4, 5, 6, 4, 5]
d.  assume for all i < n, the failure function f for si equals to:
        f(1) = f(2) = 0
        f(j) = j - |sk-1| where k is the largest integer that |sk| <= j + 1
    then for sn, trivially f(1) = 0, f(2) = 0
    let P(s, i) be the prefix of s with length i
    if j <= |sn-1|
        P(sn, j) = P(sn-1, j), f(j) for sn = f(j) for sn-1
        by induction, f(j) = j - |sk-1|, where k is the largest integer that |sk| <= j + 1
    if |sn| - 2 >= j > |sn-1|, k = n - 1
        define C(s) to be the function to swap places of the last two characters of s
        inductively prove that C(sn) = C(sn-1sn-2) = sn-2sn-1:
            C(s3) = C(ab) = ba = s1s2
            C(s4) = C(aba) = aab = s2s3
            for n >= 4, C(sn+2) = C(sn+1sn) = sn+1C(sn) = snsn-1sn-2sn-1 = snsn+1
        P(sn, j)
        = sn-1P(sn-2, j)
        = sn-2 || sn-3 || P(sn-2, j - |sn-1|)
        as C(sn-2 || sn-3) = sn-3 || sn-2, j <= |sn| - 2, sn-3 || P(sn-2, j - |sn-1|) is a prefix of P(sn, j)
        f(j) >= j - |sn-1| + |sn-3| = j - |sn-2|
    if j = |sn| - 1, k = n, j - |sn-1| = |sn-2| - 1
        sn = sn-1 || sn-2 = sn-2 || sn-3 || sn-2
        P(sn, j) = sn-2 || sn-3 || P(sn-2, |sn-2| - 1)
        f(j) >= |sn-2| - 1
    if j = |sn|, k = n, j - |sn-1| = |sn-2|
        similar
    //  have no idea how to prove the <= direction
e.  never since sk is a prefix of sk+1

3.4.10
./Dragon_Book/chapter_3/aho-corasick/src/lib.rs#failure_trie
cloned from the original paper of Aho and Corasick: https://cr.yp.to/bib/1975/aho.pdf

3.4.11
a.  Transitions:
        δ(0, a) = 1
        δ(1, b) = 4
        δ(1, a) = 2
        δ(2, a) = 3
        δ(4, a) = 5
        δ(5, b) = 8
        δ(5, a) = 6
        δ(6, a) = 7
        δ(8, a) = 9
        δ(9, a) = 10
        δ(10, a) = 11
    Failure function:
        [0, 0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7]
b.  Transitions:
        δ(0, f) = 4
        δ(0, l) = 11
        δ(0, a) = 1
        δ(1, l) = 2
        δ(2, l) = 3
        δ(4, a) = 5
        δ(5, l) = 6
        δ(5, t) = 8
        δ(6, l) = 7
        δ(8, a) = 9
        δ(9, l) = 10
        δ(11, a) = 16
        δ(11, l) = 12
        δ(12, a) = 13
        δ(13, m) = 14
        δ(14, a) = 15
        δ(16, m) = 17
        δ(17, e) = 18
    Failure function:
        [0, 0, 11, 12, 0, 1, 2, 3, 0, 1, 2, 0, 11, 16, 17, 1, 1, 0, 0]
c.  Transitions:
        δ(0, i) = 7
        δ(0, p) = 1
        δ(0, t) = 11
        δ(1, i) = 2
        δ(1, e) = 5
        δ(2, p) = 3
        δ(3, e) = 4
        δ(5, t) = 6
        δ(5, r) = 17
        δ(7, t) = 8
        δ(8, e) = 9
        δ(9, m) = 10
        δ(11, e) = 12
        δ(12, m) = 13
        δ(13, p) = 14
        δ(14, e) = 15
        δ(15, r) = 16
        δ(17, p) = 18
        δ(18, e) = 19
        δ(19, t) = 20
        δ(20, u) = 21
        δ(21, a) = 22
        δ(22, l) = 23
    Failure function:
        [0, 0, 7, 1, 5, 0, 11, 0, 11, 12, 13, 0, 0, 0, 1, 5, 17, 0, 1, 5, 6, 0, 0, 0]

3.4.12
as Aho & Corasick described in their paper, it's basically a breadth first search of the trie tree
bfs takes time linear to the number of vertices
which in turn is smaller or equal to the number of characters in patterns

3.5.1
a.  while { return(WHILE); }
b.  change "<>" to "!="
c.  letter [A-Za-z_]
d.  string "(\\\\|\\"|[^\"])*"
    {string} { yylval = (int) installString(); return(STRING); }
    (int) installString() {/* puts string constants to a seperate table */}

//  as there's no binding for lex in Rust
//  will write a subset of pest-compatible PEG (hopefully confirms to regular language) instead
3.5.2
tokens = { (spaces | other)* }
spaces = { space+ }
space = { " " | "\n" | "\t" }
other = { (!space ~ ANY)+ }
./Dragon_Book/chapter_3/lexers/src/whitespace.rs

3.5.3
reuse the simple c lexer from 3.1.1
./Dragon_Book/chapter_3/lexers/src/simple_c.rs#stripe_float

3.5.4
tokens = { token* }
token = { conso_word | vowel_word | other }
conso_word = { consonant ~ ASCII_ALPHA* }
vowel_word = { vowel ~ ASCII_ALPHA* }
other = { (!ASCII_ALPHA ~ ANY)+ }
vowel = { "a" | "e" | "i" | "o" | "u" | "A" | "E" | "I" | "O" | "U" }
consonant = { !vowel ~ ASCII_ALPHA }
./Dragon_Book/chapter_3/lexers/src/pig_latin.rs

3.5.5
tokens = { (keyword | id)* }
//  ^ before a string literal in PEG makes that string case-insensitive
keyword = { ^"select" | ^"from" | ^"where" }
id = { ASCII_ALPHA ~ ASCII_ALPHANUMERIC* }
//  before putting the identifer into the symbol table, it has to be transformed to all lower or upper case

3.6.1
refer CLRS 32.4

3.6.2
http://ivanzuzak.info/noam/webapps/fsm2regex/

3.6.3
./Dragon_Book/chapter_3/nfa
All paths:
[0, 0, 0, 0, 0]
[0, 0, 1, 1, 1]
[0, 1, 1, 1, 1]
[0, 1, 0, 0, 0]
[0, 1, 2, 0, 0]
[0, 1, 2, 2, 3]
[0, 1, 2, 2, 0]
[0, 1, 2, 2, 2]
aabb is accepted

3.6.4
./Dragon_Book/chapter_3/nfa
All paths:
[0, 3, 2, 2, 0]
[0, 3, 2, 2, 1]
[0, 3, 2, 2, 2]
[0, 3, 2, 2, 3]
[0, 3, 2, 1, 0]
[0, 3, 2, 1, 2]
[0, 3, 2, 1, 1]
[0, 3, 2, 1, 3]
[0, 3, 1, 1, 2]
[0, 3, 1, 1, 3]
[0, 3, 1, 1, 1]
[0, 3, 1, 1, 0]
[0, 3, 1, 2, 2]
[0, 3, 1, 2, 1]
[0, 3, 1, 2, 0]
[0, 3, 1, 2, 3]
[0, 0, 2, 2, 2]
[0, 0, 2, 2, 0]
[0, 0, 2, 2, 3]
[0, 0, 2, 2, 1]
[0, 0, 2, 1, 0]
[0, 0, 2, 1, 1]
[0, 0, 2, 1, 3]
[0, 0, 2, 1, 2]
[0, 0, 1, 1, 0]
[0, 0, 1, 1, 1]
[0, 0, 1, 1, 3]
[0, 0, 1, 1, 2]
[0, 0, 1, 2, 2]
[0, 0, 1, 2, 0]
[0, 0, 1, 2, 3]
[0, 0, 1, 2, 1]
aabb is accepted

3.6.5
./Dragon_Book/chapter_3/nfa
a.  δ(0, a) = {0, 1}
    δ(0, b) = {0}
    δ(1, a) = {1, 2}
    δ(1, b) = {1}
    δ(2, ε) = {0}
    δ(2, a) = {2}
    δ(2, b) = {2, 3}
b.  δ(0, a) = {1}
    δ(0, ε) = {3}
    δ(1, b) = {2}
    δ(1, ε) = {0}
    δ(2, b) = {3}
    δ(2, ε) = {1}
    δ(3, a) = {0}
    δ(3, ε) = {2}
c.  δ(0, ε) = {1, 3}
    δ(1, a) = {2}
    δ(2, a) = {2}
    δ(3, b) = {4}
    δ(4, b) = {4}

3.7.1
./Dragon_Book/chapter_3/nfa
a.  set [0, 1, 3] in nfa corresponds to state 0 in dfa
    set [4] in nfa corresponds to state 2 in dfa
    set [2] in nfa corresponds to state 1 in dfa
    δ(0, b) = {2}
    δ(0, a) = {1}
    δ(1, a) = {1}
    δ(2, b) = {2}
b.  set [0, 1] in nfa corresponds to state 1 in dfa
    set [0] in nfa corresponds to state 0 in dfa
    set [0, 1, 2, 3] in nfa corresponds to state 3 in dfa
    set [0, 1, 2] in nfa corresponds to state 2 in dfa
    δ(0, a) = {1}
    δ(0, b) = {0}
    δ(1, a) = {2}
    δ(1, b) = {1}
    δ(2, b) = {3}
    δ(2, a) = {2}
    δ(3, b) = {3}
    δ(3, a) = {2}
c.  //  all states are reachable from any other state through ε-transitions alone
    set [0, 1, 2, 3] in nfa corresponds to state 0 in dfa
    δ(0, a) = {0}
    δ(0, b) = {0}

3.7.2
./Dragon_Book/chapter_3/nfa
a.  {0}
    {1, 0}
    {2, 1, 0}
    {3, 0, 2, 1}
    {3, 1, 2, 0}
b.  {3, 1, 0, 2}
    {1, 3, 0, 2}
    {1, 0, 3, 2}
    {0, 2, 3, 1}
    {2, 3, 1, 0}

3.7.3
the original design (./Dragon_Book/chapter_3/nfa) doesn't cope well with Thompson's construction
./Dragon_Book/chapter_3/simple-regex
works for a subset of regex which confirms to the grammar below:
    union = { concat ~ ("|" ~ union)? }
    concat = { kleene ~ concat? }
    kleene = { factor ~ star? }
    factor = { ASCII_ALPHANUMERIC | empty | "(" ~ union ~ ")" }
    empty = { "ε" }
    star = { "*" }
a.  Transitions:
        δ(0, b) = 2
        δ(0, a) = 1
        δ(1, b) = 2
        δ(1, a) = 1
        δ(2, b) = 2
        δ(2, a) = 1
    Final states: {0, 1, 2}
b.  Transitions:
        δ(0, a) = 1
        δ(0, b) = 2
        δ(1, b) = 2
        δ(1, a) = 4
        δ(2, b) = 3
        δ(2, a) = 1
        δ(3, b) = 3
        δ(3, a) = 1
        δ(4, a) = 4
        δ(4, b) = 2
    Final states: {0, 1, 2, 3, 4}
c.  Transitions:
        δ(0, a) = 1
        δ(0, b) = 2
        δ(1, b) = 2
        δ(1, a) = 1
        δ(2, b) = 3
        δ(2, a) = 1
        δ(3, b) = 3
        δ(3, a) = 1
    Final states: {0, 1, 2, 3}
d.  Transitions:
        δ(0, b) = 2
        δ(0, a) = 1
        δ(1, b) = 3
        δ(1, a) = 1
        δ(2, b) = 2
        δ(2, a) = 1
        δ(3, b) = 4
        δ(3, a) = 1
        δ(4, a) = 5
        δ(4, b) = 6
        δ(5, a) = 5
        δ(5, b) = 7
        δ(6, a) = 5
        δ(6, b) = 6
        δ(7, a) = 5
        δ(7, b) = 8
        δ(8, b) = 6
        δ(8, a) = 5
    Final states: {4, 5, 6, 7, 8}

3.8.1
//  dfa contains a transition for each characters in the alphabet
//  the machine tends to be huge due to the alphabet of 52 letters and 10 digits 
//  for simplicity reduce alphabet to those used in keywords and digits "01"
./Dragon_Book/chapter_3/simple-regex
nfa:δ(0, ε) = {1, 5}
    δ(5, ε) = {6, 8}
    δ(8, f) = {9}
    δ(9, ε) = {10}
    δ(10, ε) = {11}
    δ(11, ε) = {12, 18}
    18: ID
    δ(18, ε) = {19}
    δ(12, ε) = {13, 15}
    δ(15, f) = {16}
    δ(16, ε) = {17}
    δ(17, ε) = {12, 18}
    δ(13, i) = {14}
    δ(14, ε) = {17}
    δ(6, i) = {7}
    δ(7, ε) = {10}
    δ(1, i) = {2}
    δ(2, ε) = {3}
    δ(3, f) = {4}
    4: IF
    δ(4, ε) = {19}
    Final state: 19
dfa:Transitions:
        δ(0, i) = 1
        δ(0, f) = 2
        1: {"ID"}
        δ(1, f) = 5
        δ(1, i) = 3
        2: {"ID"}
        δ(2, f) = 4
        δ(2, i) = 3
        3: {"ID"}
        δ(3, i) = 3
        δ(3, f) = 4
        4: {"ID"}
        δ(4, i) = 3
        δ(4, f) = 4
        5: {"ID", "IF"}
        δ(5, f) = 4
        δ(5, i) = 3
    Final states: {1, 2, 3, 4, 5}

3.8.2
//  still huge even while alphabet is restricted to "whilen01"
./Dragon_Book/chapter_3/simple-regex
nfa:δ(0, ε) = {1, 11, 19}
    δ(19, ε) = {20, 22}
    δ(22, ε) = {23, 25}
    δ(25, ε) = {26, 28}
    δ(28, ε) = {29, 31}
    δ(31, ε) = {32, 34}
    δ(34, n) = {35}
    δ(35, ε) = {36}
    δ(36, ε) = {37}
    δ(37, ε) = {38}
    δ(38, ε) = {39}
    δ(39, ε) = {40}
    δ(40, ε) = {41}
    δ(41, ε) = {42, 72}
    72: ID
    δ(72, ε) = {73}
    δ(42, ε) = {43, 65}
    δ(65, ε) = {66, 68}
    δ(68, 1) = {69}
    δ(69, ε) = {70}
    δ(70, ε) = {71}
    δ(71, ε) = {42, 72}
    δ(66, 0) = {67}
    δ(67, ε) = {70}
    δ(43, ε) = {44, 46}
    δ(46, ε) = {47, 49}
    δ(49, ε) = {50, 52}
    δ(52, ε) = {53, 55}
    δ(55, ε) = {56, 58}
    δ(58, n) = {59}
    δ(59, ε) = {60}
    δ(60, ε) = {61}
    δ(61, ε) = {62}
    δ(62, ε) = {63}
    δ(63, ε) = {64}
    δ(64, ε) = {71}
    δ(56, e) = {57}
    δ(57, ε) = {60}
    δ(53, l) = {54}
    δ(54, ε) = {61}
    δ(50, i) = {51}
    δ(51, ε) = {62}
    δ(47, h) = {48}
    δ(48, ε) = {63}
    δ(44, w) = {45}
    δ(45, ε) = {64}
    δ(32, e) = {33}
    δ(33, ε) = {36}
    δ(29, l) = {30}
    δ(30, ε) = {37}
    δ(26, i) = {27}
    δ(27, ε) = {38}
    δ(23, h) = {24}
    δ(24, ε) = {39}
    δ(20, w) = {21}
    δ(21, ε) = {40}
    δ(11, w) = {12}
    δ(12, ε) = {13}
    δ(13, h) = {14}
    δ(14, ε) = {15}
    δ(15, e) = {16}
    δ(16, ε) = {17}
    δ(17, n) = {18}
    18: WHEN
    δ(18, ε) = {73}
    δ(1, w) = {2}
    δ(2, ε) = {3}
    δ(3, h) = {4}
    δ(4, ε) = {5}
    δ(5, i) = {6}
    δ(6, ε) = {7}
    δ(7, l) = {8}
    δ(8, ε) = {9}
    δ(9, e) = {10}
    10: WHILE
    δ(10, ε) = {73}
    Final state: 73
dfa:Transitions:
        δ(0, h) = 2
        δ(0, e) = 5
        δ(0, l) = 4
        δ(0, i) = 3
        δ(0, w) = 1
        δ(0, n) = 6
        1: {"ID"}
        δ(1, e) = 11
        δ(1, 1) = 14
        δ(1, 0) = 13
        δ(1, w) = 7
        δ(1, l) = 10
        δ(1, i) = 9
        δ(1, n) = 12
        δ(1, h) = 15
        2: {"ID"}
        δ(2, e) = 11
        δ(2, 1) = 14
        δ(2, 0) = 13
        δ(2, w) = 7
        δ(2, l) = 10
        δ(2, i) = 9
        δ(2, n) = 12
        δ(2, h) = 8
        3: {"ID"}
        δ(3, e) = 11
        δ(3, 1) = 14
        δ(3, 0) = 13
        δ(3, w) = 7
        δ(3, l) = 10
        δ(3, i) = 9
        δ(3, n) = 12
        δ(3, h) = 8
        4: {"ID"}
        δ(4, e) = 11
        δ(4, 1) = 14
        δ(4, 0) = 13
        δ(4, w) = 7
        δ(4, l) = 10
        δ(4, i) = 9
        δ(4, n) = 12
        δ(4, h) = 8
        5: {"ID"}
        δ(5, e) = 11
        δ(5, 1) = 14
        δ(5, 0) = 13
        δ(5, w) = 7
        δ(5, l) = 10
        δ(5, i) = 9
        δ(5, n) = 12
        δ(5, h) = 8
        6: {"ID"}
        δ(6, e) = 11
        δ(6, 1) = 14
        δ(6, 0) = 13
        δ(6, w) = 7
        δ(6, l) = 10
        δ(6, i) = 9
        δ(6, n) = 12
        δ(6, h) = 8
        7: {"ID"}
        δ(7, w) = 7
        δ(7, h) = 8
        δ(7, i) = 9
        δ(7, l) = 10
        δ(7, n) = 12
        δ(7, 1) = 14
        δ(7, 0) = 13
        δ(7, e) = 11
        8: {"ID"}
        δ(8, w) = 7
        δ(8, h) = 8
        δ(8, i) = 9
        δ(8, l) = 10
        δ(8, n) = 12
        δ(8, 1) = 14
        δ(8, 0) = 13
        δ(8, e) = 11
        9: {"ID"}
        δ(9, w) = 7
        δ(9, h) = 8
        δ(9, i) = 9
        δ(9, l) = 10
        δ(9, n) = 12
        δ(9, 1) = 14
        δ(9, 0) = 13
        δ(9, e) = 11
        10: {"ID"}
        δ(10, w) = 7
        δ(10, h) = 8
        δ(10, i) = 9
        δ(10, l) = 10
        δ(10, n) = 12
        δ(10, 1) = 14
        δ(10, 0) = 13
        δ(10, e) = 11
        11: {"ID"}
        δ(11, w) = 7
        δ(11, h) = 8
        δ(11, i) = 9
        δ(11, l) = 10
        δ(11, n) = 12
        δ(11, 1) = 14
        δ(11, 0) = 13
        δ(11, e) = 11
        12: {"ID"}
        δ(12, w) = 7
        δ(12, h) = 8
        δ(12, i) = 9
        δ(12, l) = 10
        δ(12, n) = 12
        δ(12, 1) = 14
        δ(12, 0) = 13
        δ(12, e) = 11
        13: {"ID"}
        δ(13, w) = 7
        δ(13, h) = 8
        δ(13, i) = 9
        δ(13, l) = 10
        δ(13, n) = 12
        δ(13, 1) = 14
        δ(13, 0) = 13
        δ(13, e) = 11
        14: {"ID"}
        δ(14, w) = 7
        δ(14, h) = 8
        δ(14, i) = 9
        δ(14, l) = 10
        δ(14, n) = 12
        δ(14, 1) = 14
        δ(14, 0) = 13
        δ(14, e) = 11
        15: {"ID"}
        δ(15, e) = 17
        δ(15, n) = 12
        δ(15, 0) = 13
        δ(15, h) = 8
        δ(15, i) = 16
        δ(15, l) = 10
        δ(15, 1) = 14
        δ(15, w) = 7
        16: {"ID"}
        δ(16, h) = 8
        δ(16, w) = 7
        δ(16, 0) = 13
        δ(16, i) = 9
        δ(16, l) = 19
        δ(16, e) = 11
        δ(16, n) = 12
        δ(16, 1) = 14
        17: {"ID"}
        δ(17, h) = 8
        δ(17, w) = 7
        δ(17, 0) = 13
        δ(17, i) = 9
        δ(17, l) = 10
        δ(17, e) = 11
        δ(17, n) = 18
        δ(17, 1) = 14
        18: {"ID", "WHEN"}
        δ(18, i) = 9
        δ(18, 0) = 13
        δ(18, 1) = 14
        δ(18, n) = 12
        δ(18, e) = 11
        δ(18, w) = 7
        δ(18, h) = 8
        δ(18, l) = 10
        19: {"ID"}
        δ(19, w) = 7
        δ(19, e) = 20
        δ(19, i) = 9
        δ(19, l) = 10
        δ(19, n) = 12
        δ(19, 1) = 14
        δ(19, h) = 8
        δ(19, 0) = 13
        20: {"WHILE", "ID"}
        δ(20, i) = 9
        δ(20, 0) = 13
        δ(20, l) = 10
        δ(20, n) = 12
        δ(20, 1) = 14
        δ(20, h) = 8
        δ(20, w) = 7
        δ(20, e) = 11
    Final states: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}

3.8.3
nearly all dfa in this chapter
e.g. a dfa for the literal string "abb" in an alphabet Σ = [a-zA-Z0-9]
with explicit dead state the dfa has at least 5 * 62 transitions 
with implicit dead state the dfa contains only 3 transitions

3.8.4
trace the states of the first lexeme dfa during the processing of a string
for each accepted state on the stack (from top to bottom), run another lookahead dfa
filter out if the second dfa failed
./Dragon_Book/chapter_3/simple-regex/src/dfa.rs

3.9.1
c1?     true            firstpos(c1)
c1+     nullable(c1)    firstpos(c1)

3.9.2
./Dragon_Book/chapter_3/simple-regex
a.  Transitions:
        δ(0, a) = 0
        δ(0, b) = 0
    Final states: {0}
b.  Transitions:
        δ(0, b) = 0
        δ(0, a) = 0
    Final states: {0}
c.  Transitions:
        δ(0, b) = 0
        δ(0, a) = 0
    Final states: {0}
d.  Transitions:
        δ(0, a) = 1
        δ(0, b) = 0
        δ(1, a) = 1
        δ(1, b) = 2
        δ(2, a) = 1
        δ(2, b) = 3
        δ(3, b) = 3
        δ(3, a) = 4
        δ(4, a) = 4
        δ(4, b) = 5
        δ(5, a) = 4
        δ(5, b) = 3
    Final states: {3, 4, 5}

3.9.3
refer 3.9.2

3.9.4
./Dragon_Book/chapter_3/simple-regex
a.  Transitions:
        δ(0, b) = 0
        δ(0, a) = 2
        δ(1, b) = 0
        δ(1, a) = 2
        δ(2, b) = 1
        δ(2, a) = 3
        δ(3, a) = 3
        δ(3, b) = 1
    Final states: {1, 3}
b.  Transitions:
        δ(0, b) = 0
        δ(0, a) = 7
        δ(1, b) = 4
        δ(1, a) = 1
        δ(2, b) = 3
        δ(2, a) = 6
        δ(3, b) = 0
        δ(3, a) = 7
        δ(4, b) = 3
        δ(4, a) = 6
        δ(5, b) = 4
        δ(5, a) = 1
        δ(6, b) = 2
        δ(6, a) = 5
        δ(7, b) = 2
        δ(7, a) = 5
    Final states: {1, 3, 4, 6}
c.  Transitions:
        δ(0, a) = 15
        δ(0, b) = 0
        δ(1, a) = 11
        δ(1, b) = 7
        δ(2, a) = 12
        δ(2, b) = 4
        δ(3, a) = 3
        δ(3, b) = 5
        δ(4, a) = 2
        δ(4, b) = 8
        δ(5, a) = 14
        δ(5, b) = 9
        δ(6, a) = 3
        δ(6, b) = 5
        δ(7, a) = 2
        δ(7, b) = 8
        δ(8, a) = 1
        δ(8, b) = 13
        δ(9, a) = 1
        δ(9, b) = 13
        δ(10, a) = 14
        δ(10, b) = 9
        δ(11, a) = 6
        δ(11, b) = 10
        δ(12, a) = 6
        δ(12, b) = 10
        δ(13, b) = 0
        δ(13, a) = 15
        δ(14, b) = 4
        δ(14, a) = 12
        δ(15, a) = 11
        δ(15, b) = 7
    Final states: {1, 3, 4, 5, 9, 12, 13, 14}
the number of states equals to 2^(the number of (a|b) at the end)

3.9.5
the DFA must remember all characters in the last n places
otherwise there must be two different strings s1 and s2 of length n that:
    after processing s1 and s2, the DFA ends in the same state p
    let i be the last position where s1 and s2 differs
    assume without loss of generality s1[i] = a and s2[i] = b
    take s1[i..] and s2[i..], extend both to length n with identical substring c, get s1' and s2'
        s1' = s1[i .. n] || c, s2' = s2[i .. n] || c
    since s1 and s2 reaches the same state at position n - i, the last i characters are identical
    the DFA must reach the same state p' after processing s1' and s2'
    but s1 ∈ L((a|b)*a(a|b){n-1}), s2 ∉ L((a|b)*a(a|b){n-1}), p' must be both final and non-final

4.2.1
a.  S -> SS* -> SS+S* -> aS+S* -> aa+S* -> aa+a*
b.  S -> SS* -> Sa* -> SS+a* -> Sa+a* -> aa+a*
c.  S---S---S---a
        |   |
        |   S---a
        |   |
        |   +
        |
        S---a
        |
        *
d.  the grammar generates postfix notation which is not ambiguous
e.  see part d

4.2.2
a.  lm: S -> 0S1 -> 00S11 -> 000111
    rm: the same
    S---0
        |
        S---0
        |   |
        1   S---0
            |   |
            1   1
    not ambiguous, only one production with one non-terminal symbol
b.  prefix notation
    similar to 4.2.1
c.  lm: S   -> S(S)S -> (S)S -> (S(S)S)S -> ((S)S)S -> (()S)S 
            -> (()S(S)S)S -> (()(S)S)S -> (()()S)S -> (()()S)S -> (()())S -> (()())
    rm: symmetric
    S---S---ε
        |
        (
        |
        S---S---S---ε
        |   |   |
        )   (   (
        |   |   |
        |   S   S---ε
        |   |   |
        |   )   )
        |   |   |
        |   |   S---ε
        |   |
        |   S---ε
        |
        S---ε
    ambiguous since both S -> (S)S | ε and S -> S(S) | ε can generate all balanced parentheses
d.  lm: S   -> SS -> S*S -> (S)*S -> (S+S)*S -> (a+S)*S -> (a+a)*S -> (a+a)*a
    rm: S   -> SS -> Sa -> S*a -> (S)*a -> (S+S)*a -> (S+a)*a -> (a+a)*a
    S---S---(
        |   |
        |   S---S---a
        |   |   |
        |   |   +
        |   |   |
        |   |   S---a
        |   |
        |   )
        |
        S---a
    ambiguous as both S =>* S+S and S =>* S*S
e.  lm: S   -> (L) -> (L,S) -> (L,S,S) -> (S,S,S) -> ((L),S,S) -> ((L,S),S,S) -> ((S,S),S,S)
            -> ((a,S),S,S) -> ((a,a),S,S) -> ((a,a),a,S) -> ((a,a),a,(L)) -> ((a,a),a,(S)) -> ((a,a),a,(a))
    rm: S   -> (L) -> (L,S) -> (L,(L)) -> (L,(S)) -> (L,(a)) -> (L,S,(a)) -> (L,a,(a)) -> (S,a,(a))
            -> ((L),a,(a)) -> ((L,S),a,(a)) -> ((L,a),a,(a)) -> ((S,a),a,(a)) -> ((a,a),a,(a))
    S---(
        |
        L---L---L---S---(
        |   |   |       |
        |   |   ,       L---L---S---a
        |   |   |       |   |
        |   |   S---a   )   ,
        |   |               |
        |   ,               S---a
        |   |
        |   S---a
        |
        )
    not ambiguous
    the generated strings have natural tree-like structure 
f.  lm: S   -> aSbS -> aaSbSbS -> aabSbS -> aabbS -> aabbaSbS -> aabbabS -> aabbab
    rm: S   -> aSbS -> aSbaSbS -> aSbaSb -> aSbab -> aaSbSbab -> aaSbbab -> aabbab
    S---a
        |
        S---a
        |   |
        |   S---ε
        |   |
        |   b 
        |   | 
        |   S---ε
        |
        b
        |
        S---a
            |
            S---ε
            |
            b 
            |
            S---ε
    ambiguous
    as proved in 2.2.2, this grammar can generate any string with equal number of a and b
    thus ababab can be generated by a parse tree with initial production 
        a(S:baba)b(S:ε)
    or
        a(S:ε)b(S:abab)
g.  unambiguous by the techniques introduced in chapter 2

4.2.3
a.  1*(01+)*, or 
    S       -> ones L | L
    ones    -> 1 ones | 1
    L       -> F L | ε
    F       -> 0 ones
b.  S   -> 0S1 | 1S0 | 0 | 1 | ε
c.  S   -> 0S1S | 1S0S | ε
d.  thanks https://cs.stackexchange.com/questions/16642/
    let La = {w: #a(w) > #b(w)}, Lb = {w: #b(w) > #a(w)}, L= = {w: #a(w) = #b(w)}
    from 2.2.2, L= can be generated by S -> aSbS | bSaS | ε
    lemma: La = L=(aL=)+
        for w ∈ La, denote wi as the prefix of w with length i
        assume for |w| < n, w can be generated by L=(aL=)+
        for |w| = n, define f(w, i) = #a(wi) - #b(wi)
        f(w, 0) = 0, f(w, n) > 0, |f(w, i+1) - f(w, i)| <= 1
        hence there must be some 0 <= i < n that f(w, i) = 0 and f(w, i+1) = 1
        which means wi ∈ L= and w[i+1] = a
        w = wi a suffix, where |suffix| < n and either suffix ∈ La or suffix ∈ L=
        if suffix ∈ La, suffix can be generated by L=(aL=)+, w can be generated by L=aL=(aL=)+ = L=(aL=)+
        if suffix ∈ L=, w can be generated by L=aL= ⊆ L=(aL=)+
        for w ∈ L=(aL=)+, trivially #a(w) > #b(w), w ∈ La
    symmetrically, Lb = L=(bL=)+
    Lab -> La | Lb
    La  -> L= A
    A   -> a L= A | a L=
    Lb  -> L= B
    B   -> b L= B | b L=
    L=  -> aL=bL= | bL=aL= | ε
e.  1*(0|01)*, or
    S       -> ones ZL
    ones    -> 1 ones | ε
    ZL      -> Z ZL | ε
    Z       -> 0 | 01
    if 011 is not a substring of w, each 0 in w is followed by either another 0 or 10
f.  thanks https://stackoverflow.com/questions/50903481/
    let |x| = |y| = n, if x != y, for some position i x[i] != y[i]
    let x[i] = 0, then y[i] = 1, 
        xy  = b^i0b^(n-i-1)b^i1b^(n-i-1)    // b -> 0 | 1
            = b^i0b^ib^(n-i-1)1b^(n-i-1)
            = b^p0b^p b^q1b^q               // p = i, q = n-i-1
    S   -> A B | B A | ε
    A   -> W A W | 0
    B   -> W B W | 1
    W   -> 0 | 1

4.2.4
i.  assume all production with < n pairs of square braces have an equivalent string without square braces
    let A -> α[β]γ, where [β] is the first square brace in the body
    α contains no square braces, γ has a equivalent string γ' without square braces
    A -> αβγ | αγ is equivalent to A -> α[β]γ, which in turn is equivalent to A -> αβγ' | αγ'
ii. A -> {α} is equivalent to A -> α A | ε:
    =>: α^0 = ε ∈ L(A)
        assume for i < n, α^i ∈ L(A)
        a^n = a a^(n-1) ∈ L(aA) ⊆ L(A)
    <=: induct on derivations
        for derivations of length 1, A -> ε ∈ L({α})
        assume for all derivations of length i < n, A =>* w ∈ L({α})
        A => αA ∈ L(α{α}) ⊆ L({α})

4.2.5
// cannot write in bold or italic font in txt file
// will write PEGs to avoid ambiguity
stmt = { "if" ~ expr ~ "then" stmt ~ ("else" stmt)? | "begin" ~ stmtList ~ "end" }
stmtList = { stmt ~ (";" ~ stmtList)? }

4.2.6
+ can be translated to | and *
the character set [a-b] can be expanded in-place

4.2.7
a.  a grammar symbol X is useless if:
        1.  it cannot be generated from the start symbol
        2.  all of its production contains itself (hence no finite sentence can be generated from X)
    case 2 can be detected by inspect all productions of a head
    case 1 can be detected by utilizing a data structure of disjoint sets:
        for all production A -> α, union A and all symbols in α (after removing all case 2 symbols)
        if a symbol X is not in the same set with start symbol S, X cannot be generated
b.  both A, B, 1 are useless:
        A is always recursive
        both B and 1 can only be generated from A

4.2.8
a.  option  -> A1 | A2 | .. | An
    A1      -> a1 | b1
    ...
    An      -> an | bn
b.  let U be the set of categories of options
    define a non-terminal symbol AS for each subset S of U
    for each s ∈ S define a production:
        AS -> s A(S - {s})
    and one more production
        AS -> ε
    AU is the start symbol
    inductively prove that AS generates all permutation of all subset of S
        A∅ -> ε
        assume for some S, for all strict subset S' of S, AS' generates all permutation of all subsets of S'
        =>: for a permutation p of S' ⊆ S, p = s p', where p' is a permutation ⊆ S - {s}  
            there is a production AS -> s A(S - {s})
            p' can be generated by A(S - {s}), p can be generated by AS
        <=: for a production AS -> s A(S - {s})
            A(S - {s}) generates a permutation p' ⊆ S - {s}
            p = s p' is a permutation ⊆ S
    the total length of productions is O(n) for each subset of U and O(1) for each category of option
    there are 2^|U| = 2^n subsets of U, therefore the total length of productions is O(n2^n) + O(n) = O(n2^n)
c.  ?
d.  the total production length can be reduced to O(n^2) if the options can only appear in a fixed order
        S -> ε | A1 | A1 A2 | A1 A2 A3 | ...
    (like in most C-like languages)
    thus it is not practical to allow these options to appear in arbitrary order

4.3.1
//  useful tools: https://mdaines.github.io/grammophone/
a.  no change
b.  no, the grammar is left-recursive
c.  rexpr       -> rterm rexpr'
    rexpr'      -> + rterm rexpr' | ε
    rterm       -> rfactor rterm'
    rterm'      -> rfactor rterm' | ε
    rfactor     -> rprimary rfactor'
    rfactor'    -> * rprimary rfactor' | ε
    rprimary    -> a | b
d.  yes

4.3.2
a.  S   -> S S op | a    
    op  -> + | *
    no, the grammar is left-recursive
    S   -> a S'
    S'  -> S op S' | ε
    op  -> + | *
    yes
b.  S   -> 0 S'
    S'  -> S 1 | 0 1
    yes
    not left-recursive
    yes
c.  no change
    no, the grammar is left-recursive
    S   -> S'
    S'  -> (S) S S' | ε
    yes
d.  no change
    no, the grammar is left-recursive
    S   -> ( L )
    L   -> S L'
    L'  -> , S L' | ε
    yes
e.  no change
    no, the grammar is left-recursive
    bexpr   -> bterm bexpr'
    bexpr'  -> or bterm bexpr' | ε
    bterm   -> bfactor bterm'
    bterm'  -> and bfactor bterm' | ε
    bfactor -> not bfactor | ( bexpr ) | true | false
    yes

4.3.3
thanks https://github.com/fool2fish/dragon-book-exercise-answers/blob/master/ch04/4.3/4.3.md
simplify the grammar:
    replace "if expr then" by "a"
    replace "else" by "b"
    "stmt" -> S, "matchedStmt" -> M, "other" -> c
S   -> aS | M
M   -> aMbS | c
a sentence aacbacbc can be parsed as:
    S => M => aMbS => aaMbSbc => aacbaSbc => aacbaMbc => aacbacbc, or
    S => aS => aaMbS => aacbaMbS => aacbacbM => aacbacbc

4.4.1
a.  S''' -> ε
    S -> "0" S' S''
    S' -> "0" S' "1" S'''
    S' -> "1" S'''
    S'' -> ε
    M[S, "0"]: S -> "0" S' S''
    M[S', "1"]: S' -> "1" S'''
    M[S', "0"]: S' -> "0" S' "1" S'''
    M[S'', $]: S'' -> ε
    M[S''', $]: S''' -> ε
    M[S''', "1"]: S''' -> ε
b.  M[S, "a"]: S -> "a"
    M[S, "*"]: S -> "*" S S
    M[S, "+"]: S -> "+" S S
c.  S' -> ε
    S' -> "(" S ")" S S'
    S -> S'
    not LL(1)
    M[S, (]: S -> S'
    M[S, )]: S -> S'
    M[S, $]: S -> S'
    M[S', (]: S' -> ( S ) S S', S' -> ε
    M[S', )]: S' -> ε
    M[S', $]: S' -> ε
d.  S -> "(" S ")" S'
    S -> "a" S'
    S' -> ε
    S' -> "+" S S'
    S' -> S S'
    S' -> "*" S'
    not LL(1)
    M[S, (]: S -> ( S ) S'
    M[S, a]: S -> a S'
    M[S', (]: S' -> S S', S' -> ε
    M[S', )]: S' -> ε
    M[S', +]: S' -> + S S', S' -> ε
    M[S', *]: S' -> * S', S' -> ε
    M[S', a]: S' -> S' -> S S', S' -> ε
    M[S', $]: S' -> ε
e.  S -> "(" L ")"
    S -> "a"
    L -> S L'
    L' -> ε
    L' -> "," S L'
    Not LL(1)
    M[S, (]: S -> ( L )
    M[S, a]: S -> a
    M[L, (]: L -> S L'
    M[L, a]: L -> S L'
    M[L', )]: L' -> ε
    M[L', ,]: L' -> , S L', L' -> ε
f.  bterm -> bfactor bterm'
    bexpr -> bterm bexpr'
    bterm' -> ε
    bterm' -> "and" bfactor bterm'
    bfactor -> "not" bfactor
    bfactor -> "(" bexpr ")"
    bfactor -> "true"
    bfactor -> "false"
    bexpr' -> ε
    bexpr' -> "or" bterm bexpr'
    Not LL(1)
    M[bexpr, not]: bexpr -> bterm bexpr'
    M[bexpr, true]: bexpr -> bterm bexpr'
    M[bexpr, false]: bexpr -> bterm bexpr'
    M[bexpr, (]: bexpr -> bterm bexpr'
    M[bexpr', or]: bexpr' -> or bterm bexpr', bexpr' -> ε
    M[bexpr', )]: bexpr' -> ε
    M[bterm, (]: bterm -> bfactor bterm'
    M[bterm, not]: bterm -> bfactor bterm'
    M[bterm, true]: bterm -> bfactor bterm'
    M[bterm, false]: bterm -> bfactor bterm'
    M[bterm', and]: bterm' -> and bfactor bterm', bterm' -> ε
    M[bterm', )]: bterm' -> ε
    M[bterm', and]: bterm' -> ε
    M[bterm', or]: bterm' -> ε
    M[bterm', $]: bterm' -> ε
    M[bfactor, (]: bfactor -> ( bexpr )
    M[bfactor, not]: bfactor -> not bfactor
    M[bfactor, true]: bfactor -> true
    M[bfactor, false]: bfactor -> false

4.4.2
left factoring:
    S   -> S S OP | a
    OP  -> + | *
eliminate left recursions:
    S   -> a S'
    S'  -> S OP S' | ε
    OP  -> + | *
replace S with a S':
    S   -> a S'
    S'  -> a S' OP S' | ε
    OP  -> + | *
M[S, "a"]: S -> "a" S'
M[S', "a"]: S' -> "a" S' OP S'
M[S', "+"]: S' -> ε
M[S', "*"]: S' -> ε
M[S', $]: S' -> ε
M[OP, "+"]: OP -> "+"
M[OP, "*"]: OP -> "*"

4.4.3
first of S: {"a"}
follow of S: {"+", "$", "a", "-"}

4.4.4
a.  first of S: {"0"}
    follow of S: {"1", "$"}
b.  first of S: {"*", "a", "+"}
    follow of S: {"+", "*", "a", "$"}
c.  first of S: {"ε", "("}
    follow of S: {")", "(", "$"}
d.  first of S: {"a", "("}
    follow of S: {"(", "a", ")", "+", "*", "$"}
e.  first of S: {"a", "("}
    follow of S: {")", ",", "$"}
    first of L: {"a", "("}
    follow of L: {")", ","}
f.  first of bfactor: {"true", "(", "not", "false"}
    follow of bfactor: {"$", ")", "and", "or"}
    first of bexpr: {"true", "false", "(", "not"}
    follow of bexpr: {")", "or", "$"}
    first of bterm: {"(", "true", "false", "not"}
    follow of bterm: {")", "or", "and", "$"}

4.4.5
a.  ./Dragon_Book/chapter_4/grammars/src/backtrack.rs
    for the input aaaaaa:
    S => aSa => a(aSa)a => aa(aSa)aa => aaa(aSa)aaa => aaaa(aSa)aaaa => aaaaa(aSa)aaaaa => aaaaaa|(aSa)aaaaaa (fail)
                                                                                        => aaaaaa|(aa)aaaaaa (fail)
                                                                     => aaaaa(a|a)aaaaa (fail consuming second a)
                                                    => aaaa(aa)|aaaa (succeed)
                                                    => aaa(aaa|a)aaa (fail consuming second a)
                                     => aaa(aa)a|aa (succeed)
                                     => aa(aaaa)|aa (succeed)
                                     => a(aaaaa|a)a (fail, backtrack to aSa -> aaaa)
             => a(aa)a (succeed)
             => (aaaa) (succeed, terminated)
b.  let i denote the index of the "a" right after the opening parenthesis (1 based)
    on the first failure, i = len(s) + 1
    after other two immediate failures, i = len(s) - 1
    from now on,
        if i > len(s) / 2, the parser will eventually fail and move i to a new position i' where
            i - i' = len(s) + 1 - (i + 1)
                i' = 2i - len(s), or
                i  = (i' + len(s)) / 2
        if i <= len(s) / 2, parse succeeds with the last len(s) - 2i characters discarded
    the string may only be recognized as a whole if at some moment i = len(s) / 2
    work backwards from i' to i, the value of i an iteration before i = len(s) / 2 would have to be 3/4 len(s)
    the series of values of i is len(s)/2 -> 3len(s)/4 -> 7len(s)/8 -> ... -> len(s) - 1
    which means for some integer k, 
        len(s) - 1 = (2^k - 1)len(s) / 2^k
        1 = len(s) / 2^k
        len(s) = 2^k

4.4.6 - 4.4.12
refer Dexter C. Kozen - Automata and Computability

4.5.1
a.  01 in 00(01)11
b.  0S1 in 0(0S1)1

4.5.2
a.  S(SS+)a*+ <= SSa*+
b.  (SS+)a*a+ <= Sa*a+ 
c.  (a)aa*a++ <= Saa*a++

4.5.3
a.  $               000111$
    $0              00111$
    $00             0111$
    $000            111$
    $0001           11$         reduce S -> 01
    $00S            11$
    $00S1           1$          reduce S -> 0S1
    $0S             1$
    $0S1            $           reduce S -> 0S1
    $S
b.  $               aaa*a++$
    $a              aa*a++$     reduce S -> a
    $S              aa*a++$
    $Sa             a*a++$      reduce S -> a
    $SS             a*a++$
    $SSa            *a++$       reduce S -> a
    $SSS            *a++$
    $SSS*           a++$        reduce S -> SS*
    $SS             a++$        
    $SSa            ++$         reduce S -> a
    $SSS            ++$
    $SSS+           +$          reduce S -> SS+
    $SS             +$      
    $SS+            $           reduce S -> SS+
    $S              $

4.6.1
let vp be a function from set of right sentential forms to set of corresponding viable prefixes
trivially vp(A ∪ B) = vp(A) ∪ vp(B)
a.  inductively, let Pn be the set of right-most sentential forms with at most n steps of derivation
        P0 = {S}
        P1 = {S, 01, 0S1} 
    let Tn = {0^k1^k | k ∈ {1 .. n}}, Sn = {0^kS1^k | k ∈ {1 .. n}}
    P0 = T0 ∪ S0 ∪ {S}
    if Pn = Tn ∪ Sn ∪ {S},
        Pn+1    = Pn ∪ {01, 0S1, 0^n+11^n+1, 0^n+1S1^n+1}
                = Tn+1 ∪ Sn+1 ∪ {S}
        vp(Pn)  = vp(Tn) ∪ vp(Sn) ∪ vp({S})
                = 0{,n}1? ∪ 0{,n}(S1?)? ∪ S?
                = 0{,n}S?1?
    as n -> ∞, vp(Pn) = 0*S?1?
b.  induct directly on set of viable prefixes with the following lemma:
    if p is a viable prefix of a right sentential form s with n+1 steps of derivation
    there must be a viable prefix p' of a right sentential form s' with n steps of derivation that
    p is a prefix of p' after expanding the rightmost nonterminal symbol in p' by some production of the grammar
        let s' = αNβ, s = αγ1γ2β, p = αγ1, s' =>rm s
        p' = αN must be a viable prefix otherwise s'' => s' cannot be right-most derivation:
            either s'' => s' expands a nontermial right to N
            or s'' => s' introduces N, which means N is in the middle of a handle
        and p' => pγ2
    let Vn be the set of viable prefixes of right sentential forms with at most n steps of derivation
    V0 = {ε, S}
    V1 = {ε, S, SS+, SS*, a}
    if Vn = S{2,n+1}(+|*)? ∪ {a} ∪ S{1,n}a?
        Vn+1    = Vn ∪ S{3,n+2}(+|*)? ∪ S{2,n}a ∪ S{2,n+1}{+|*}? ∪ S{0,n-1}a?
                = S{2,n+2}(+|*)? ∪ {a} ∪ S{1,n}a?
                = S{2,n+2}(+|*)? ∪ S{0,n}a?
c.  V0 = {ε, S}
    V1 = {ε, S, S(, S(S, S(S))}
    let Sn = S(\(S)^n\)
    if Vn = ∪ prefix(Sn),
        expand right-most S -> ε gives no new viable prefixes
        expand right-most S -> S(S) derives Sn+1 from a prefix of Sn, each prefix of Sn+1 is a viable prefix
        Vn+1 = ∪ prefix(Sn+1)

4.6.2
./Dragon_Book/chapter_4/grammars
Item set 3:
S -> . S S "*"
S -> S . S "*"
S -> S S . "*"
S -> . S S "+"
S -> S . S "+"
S -> S S . "+"
S -> . "a"
Item set 2:
S -> . S S "*"
S -> S . S "*"
S -> . S S "+"
S -> S . S "+"
S -> . "a"
S' -> S .
Item set 0:
S -> . S S "*"
S -> . S S "+"
S -> . "a"
S' -> . S
Item set 5:
S -> S S "*" .
Item set 4:
S -> S S "+" .
Item set 1:
S -> "a" .
ACTION[0, "a"]:
    Shift(1)
ACTION[1, $]:
    Reduce(S -> "a")
ACTION[1, "*"]:
    Reduce(S -> "a")
ACTION[1, "+"]:
    Reduce(S -> "a")
ACTION[1, "a"]:
    Reduce(S -> "a")
ACTION[2, $]:
    Accept
ACTION[2, "a"]:
    Shift(1)
ACTION[3, "*"]:
    Shift(5)
ACTION[3, "+"]:
    Shift(4)
ACTION[3, "a"]:
    Shift(1)
ACTION[4, $]:
    Reduce(S -> S S "+")
ACTION[4, "*"]:
    Reduce(S -> S S "+")
ACTION[4, "+"]:
    Reduce(S -> S S "+")
ACTION[4, "a"]:
    Reduce(S -> S S "+")
ACTION[5, $]:
    Reduce(S -> S S "*")
ACTION[5, "*"]:
    Reduce(S -> S S "*")
ACTION[5, "+"]:
    Reduce(S -> S S "*")
ACTION[5, "a"]:
    Reduce(S -> S S "*")
GOTO(0, S) = 2
GOTO(2, S) = 3
GOTO(3, S) = 3
Is SLR: true

4.6.3
Shifted terminal: "a"
Reduced production: S -> "a"
Shifted terminal: "a"
Reduced production: S -> "a"
Shifted terminal: "*"
Reduced production: S -> S S "*"
Shifted terminal: "a"
Reduced production: S -> "a"
Shifted terminal: "+"
Reduced production: S -> S S "+"

4.6.4
//  skipped since it's not only long and tedious but also fully automated by:
//  ./Dragon_Book/chapter_4/grammars/src/main.rs#report_grammar

4.6.5
./Dragon_Book/chapter_4/grammars
Item set 0:
S -> . A "a" A "b"
S -> . B "b" B "a"
A -> . ε
B -> . ε
S' -> . S
ACTION[0, "a"]:
    Reduce(A -> ε)
    Reduce(B -> ε)
ACTION[0, "b"]:
    Reduce(A -> ε)
    Reduce(B -> ε)

4.6.6
./Dragon_Book/chapter_4/grammars
S -> S A conflicts with S -> A

4.6.7
a.  n production of form S -> Aibi 
    2(n-1) production of form Ai -> ajAi | aj with head Ai
    n different Ai heads, 2n(n-1) + n = 2n^2 - 2n + n = 2n^2 - n productions in total
b.  the string generated by this grammar is αbi, where α is any nonempty string from the alphabet {aj | j != i}
    the LR(0) automaton must remember whether ai appeared so far before the final bi for each i
    hence after subset construction it must have at least 2^n states
    particularly for a viable prefix αaj, Ai -> ajAi and Ai -> aj are valid iff αaj does not contain ai
    let C = {i | ai ∈ U and ai does not appear in αaj}
    for any particular aj there are 2^(n-1) possible different C, all but ∅ corresponds to a different set of items
    over all possible aj there will be n2^(n-1) - n different set of items?
c.  from the argument above, a LR(0) automata will be easy to construct
the number of states in SLR parser can be exponential to the number of productions

4.6.8
a.  δ(S -> . S S +, S) = {S -> S . S +}
    δ(S -> . S S +, ε) = {S -> . S S +, S -> . S S *, S -> . a}
    δ(S -> S . S +, S) = {S -> S S . +}
    δ(S -> S . S +, ε) = {S -> . S S +, S -> . S S *, S -> . a}
    δ(S -> S S . +, +) = {S -> S S + .}
    δ(S -> S S . +, ε) = {S -> . S S +, S -> . S S *, S -> . a}
    δ(S -> . S S *, S) = {S -> S . S *}
    δ(S -> . S S *, ε) = {S -> . S S *, S -> . S S *, S -> . a}
    δ(S -> S . S *, S) = {S -> S S . *}
    δ(S -> S . S *, ε) = {S -> . S S *, S -> . S S *, S -> . a}
    δ(S -> S S . *, *) = {S -> S S * .}
    δ(S -> S S . *, ε) = {S -> . S S *, S -> . S S *, S -> . a}
    δ(S -> . a, a) = {S -> a .}
b.  result of subset construction should be exactly the same to the `items` procedure
c.  the two algorithms have basically the same meaning

4.6.9
Item set 6:
S -> . A S
S -> A . S
S -> . "b"
A -> . S A
A -> S A .
A -> . "a"
Item set 3:
S -> . A S
S -> A . S
S -> . "b"
A -> . S A
A -> . "a"
Item set 5:
S -> . A S
S -> A S .
S -> . "b"
A -> . S A
A -> S . A
A -> . "a"
Item set 7:
S -> . A S
S -> . "b"
A -> . S A
A -> S . A
A -> . "a"
Item set 4:
S -> . A S
S -> . "b"
A -> . S A
A -> S . A
A -> . "a"
S' -> S .
Item set 0:
S -> . A S
S -> . "b"
A -> . S A
A -> . "a"
S' -> . S
Item set 2:
S -> "b" .
Item set 1:
A -> "a" .
ACTION[0, "a"]:
    Shift(1)
ACTION[0, "b"]:
    Shift(2)
ACTION[1, "a"]:
    Reduce(A -> "a")
ACTION[1, "b"]:
    Reduce(A -> "a")
ACTION[2, $]:
    Reduce(S -> "b")
ACTION[2, "a"]:
    Reduce(S -> "b")
ACTION[2, "b"]:
    Reduce(S -> "b")
ACTION[3, "a"]:
    Shift(1)
ACTION[3, "b"]:
    Shift(2)
ACTION[4, $]:
    Accept
ACTION[4, "a"]:
    Shift(1)
ACTION[4, "b"]:
    Shift(2)
ACTION[5, $]:
    Reduce(S -> A S)
ACTION[5, "a"]:
Warning: conflicts
    Shift(1)
    Reduce(S -> A S)
ACTION[5, "b"]:
Warning: conflicts
    Shift(2)
    Reduce(S -> A S)
ACTION[6, "a"]:
Warning: conflicts
    Shift(1)
    Reduce(A -> S A)
ACTION[6, "b"]:
Warning: conflicts
    Shift(2)
    Reduce(A -> S A)
ACTION[7, "a"]:
    Shift(1)
ACTION[7, "b"]:
    Shift(2)
GOTO(0, S) = 4
GOTO(0, A) = 3
GOTO(3, S) = 5
GOTO(3, A) = 3
GOTO(4, S) = 7
GOTO(4, A) = 6
GOTO(5, S) = 7
GOTO(5, A) = 6
GOTO(6, S) = 5
GOTO(6, A) = 3
GOTO(7, S) = 7
GOTO(7, A) = 6
on sequence abab:
    stack       input       action
    [0]         .abab       SHIFT(1)
    [0,1]       a.bab       REDUCE(A -> a)
    [0,3]       a.bab       SHIFT(2)
    [0,3,2]     ab.ab       REDUCE(S -> b)
    [0,3,5]     ab.ab       SHIFT(1) or REDUCE(S -> A S)
route SHIFT(1):
    [0,3,5,1]   aba.b       REDUCE(A -> a)
    [0,3,5,6]   aba.b       SHIFT(2) or REDUCE(A -> S A)
    route SHIFT(2)
        [0,3,5,6,2]     abab.   REDUCE(S -> b)
        [0,3,5,6,5]     abab.   REDUCE(S -> A S)
        [0,3,5,7]       abab.   stuck
    route REDUCE(A -> S A)
        [0,3,3]         aba.b   SHIFT(2)
        [0,3,3,2]       abab.   REDUCE(S -> b)
        [0,3,3,5]       abab.   REDUCE(S -> A S)
        [0,3,5]         abab.   REDUCE(S -> A S)
        [0,4]           abab.   ACCEPT
route REDUCE(S -> A S)
    [0,4]       ab.ab       SHIFT(1)
    [0,4,1]     aba.b       REDUCE(A -> a)
    [0,4,6]     aba.b       SHIFT(2) or REDUCE(A -> S A)
    route SHIFT(2)
        [0,4,6,2]       abab.   REDUCE(S -> b)
        [0,4,6,5]       abab.   REDUCE(S -> A S)
        [0,4,7]         abab.   stuck
    route REDUCE(A -> S A)
        [0,4]           aba.b   SHIFT(2)
        [0,4,2]         abab.   REDUCE(S -> b)
        [0,4,7]         abab.

4.7.1
Item set 6:
a.  [S -> . S S "*", "*"]
    [S -> . S S "*", "+"]
    [S -> . S S "*", "a"]
    [S -> S . S "*", "*"]
    [S -> S . S "*", "+"]
    [S -> S . S "*", "a"]
    [S -> S S . "*", "*"]
    [S -> S S . "*", "+"]
    [S -> S S . "*", "a"]
    [S -> . S S "+", "*"]
    [S -> . S S "+", "+"]
    [S -> . S S "+", "a"]
    [S -> S . S "+", "*"]
    [S -> S . S "+", "+"]
    [S -> S . S "+", "a"]
    [S -> S S . "+", "*"]
    [S -> S S . "+", "+"]
    [S -> S S . "+", "a"]
    [S -> . "a", "*"]
    [S -> . "a", "+"]
    [S -> . "a", "a"]
    Item set 3:
    [S -> . S S "*", "*"]
    [S -> . S S "*", "+"]
    [S -> . S S "*", "a"]
    [S -> S . S "*", "*"]
    [S -> S . S "*", "+"]
    [S -> S . S "*", "a"]
    [S -> S S . "*", "a"]
    [S -> S S . "*", $]
    [S -> . S S "+", "*"]
    [S -> . S S "+", "+"]
    [S -> . S S "+", "a"]
    [S -> S . S "+", "*"]
    [S -> S . S "+", "+"]
    [S -> S . S "+", "a"]
    [S -> S S . "+", "a"]
    [S -> S S . "+", $]
    [S -> . "a", "*"]
    [S -> . "a", "+"]
    [S -> . "a", "a"]
    Item set 1:
    [S -> . S S "*", "*"]
    [S -> . S S "*", "+"]
    [S -> . S S "*", "a"]
    [S -> S . S "*", "a"]
    [S -> S . S "*", $]
    [S -> . S S "+", "*"]
    [S -> . S S "+", "+"]
    [S -> . S S "+", "a"]
    [S -> S . S "+", "a"]
    [S -> S . S "+", $]
    [S -> . "a", "*"]
    [S -> . "a", "+"]
    [S -> . "a", "a"]
    [S' -> S ., $]
    Item set 0:
    [S -> . S S "*", "a"]
    [S -> . S S "*", $]
    [S -> . S S "+", "a"]
    [S -> . S S "+", $]
    [S -> . "a", "a"]
    [S -> . "a", $]
    [S' -> . S, $]
    Item set 8:
    [S -> S S "*" ., "*"]
    [S -> S S "*" ., "+"]
    [S -> S S "*" ., "a"]
    Item set 5:
    [S -> S S "*" ., "a"]
    [S -> S S "*" ., $]
    Item set 9:
    [S -> S S "+" ., "*"]
    [S -> S S "+" ., "+"]
    [S -> S S "+" ., "a"]
    Item set 7:
    [S -> S S "+" ., "a"]
    [S -> S S "+" ., $]
    Item set 4:
    [S -> "a" ., "*"]
    [S -> "a" ., "+"]
    [S -> "a" ., "a"]
    Item set 2:
    [S -> "a" ., "a"]
    [S -> "a" ., $]
b.  set 8 and 5 can be merged
    set 4 and 2 can be merged
    set 9 and 7 can be merged
    set 6 and 3 can be merged

4.7.2 - 4.7.5
skipped

4.8.1
a.  2n + 6
b.  for each reduce / shift conflict (i.e. a set with an item [A -> E θi E .]), let the next symbol be θj
        if i >= j, reduce with production A -> E θi E
        if i < j, shift the terminal symbol
c.  skipped
d.  3n + 6, no conflicts
e.  the ambiguous grammar have fewer sets

4.8.2
skipped
the whole talk about error handling in this chapter feels arbitrary

//  LALRPOP is a LR(1) parser generator of Rust
4.9.1
./Dragon_Book/chapter_4/generated/src/bexpr.lalrpop

4.9.2
./Dragon_Book/chapter_4/generated/src/lists.lalrpop

4.9.3
the grammar is not LR(1), hence cannot be solved by yacc which generates LALR(1) parsers
https://stackoverflow.com/questions/28150012/
it can only be solved with an extension which can recognize all context free languages (e.g. %glr-parser in bison)

4.9.4
./Dragon_Book/chapter_3/simple-regex

5.1.1
//  attributed AST instead of parse tree
./Dragon_Book/chapter_5/translators
a.  Mul.val = 77
        Add.val = 7
            Lit.val = 3
            Lit.val = 4
        Add.val = 11
            Lit.val = 5
            Lit.val = 6
b.  Mul.val = 120
        Mul.val = 6
            Mul.val = 2
                Lit.val = 1
                Lit.val = 2
            Lit.val = 3
        Mul.val = 20
            Lit.val = 4
            Lit.val = 5
c.  Add.val = 118
        Add.val = 113
            Lit.val = 9
            Mul.val = 104
                Lit.val = 8
                Add.val = 13
                    Lit.val = 7
                    Lit.val = 6
        Lit.val = 5

5.1.2
E -> T E'       E'.inh = T.val
                E.val = E'.syn
E' -> + T E'1   E'1.inh = E'.inh + T.val
                E'.syn = E'1.syn
E' -> ε         E'.syn = E'.inh
T -> F T'       T'.inh = F.val
                T.val = T'.syn
T' -> * F T'1   T'1.inh = T'.inh * F.val
                T'.syn = T'1.syn
T' -> ε         T'.syn = T'.inh
F -> ( E )      F.val = E.syn
F -> digit      F.val = digit.lexval

5.1.3
./Dragon_Book/chapter_5/translators
a.  E.val = 77
        T.val = 77
            F.val = 7
                E.val = 7
                    T.val = 3
                        F.val = 3
                        T'.inh = 3, T'.syn = 3
                    E'.inh = 3, E.syn = 7
                        T.val = 4
                            F.val = 4
                            T'.inh = 4, T'.syn = 4
                        E'.inh = 7, E.syn = 7
            T'.inh = 7, T'.syn = 77
                F.val = 11
                    E.val = 11
                        T.val = 5
                            F.val = 5
                            T'.inh = 5, T'.syn = 5
                        E'.inh = 5, E.syn = 11
                            T.val = 6
                                F.val = 6
                                T'.inh = 6, T'.syn = 6
                            E'.inh = 11, E.syn = 11
                T'.inh = 77, T'.syn = 77
        E'.inh = 77, E.syn = 77
b.  E.val = 120
        T.val = 120
            F.val = 1
            T'.inh = 1, T'.syn = 120
                F.val = 2
                T'.inh = 2, T'.syn = 120
                    F.val = 3
                    T'.inh = 6, T'.syn = 120
                        F.val = 20
                            E.val = 20
                                T.val = 20
                                    F.val = 4
                                    T'.inh = 4, T'.syn = 20
                                        F.val = 5
                                        T'.inh = 20, T'.syn = 20
                                E'.inh = 20, E.syn = 20
                        T'.inh = 120, T'.syn = 120
        E'.inh = 120, E.syn = 120
c.  E.val = 118
        T.val = 118
            F.val = 118
                E.val = 118
                    T.val = 9
                        F.val = 9
                        T'.inh = 9, T'.syn = 9
                    E'.inh = 9, E.syn = 118
                        T.val = 104
                            F.val = 8
                            T'.inh = 8, T'.syn = 104
                                F.val = 13
                                    E.val = 13
                                        T.val = 7
                                            F.val = 7
                                            T'.inh = 7, T'.syn = 7
                                        E'.inh = 7, E.syn = 13
                                            T.val = 6
                                                F.val = 6
                                                T'.inh = 6, T'.syn = 6
                                            E'.inh = 13, E.syn = 13
                                T'.inh = 104, T'.syn = 104
                        E'.inh = 113, E.syn = 118
                            T.val = 5
                                F.val = 5
                                T'.inh = 5, T'.syn = 5
                            E'.inh = 118, E.syn = 118
            T'.inh = 118, T'.syn = 118
        E'.inh = 118, E.syn = 118

5.2.1
[1 3 5] 6 7 8 9
2 and 4 can be inserted at any place between the square brackets in order
2 4 1 3 5 6 7 8 9
2 1 4 3 5 6 7 8 9
2 1 3 4 5 6 7 8 9
2 1 3 5 4 6 7 8 9
1 2 4 3 5 6 7 8 9
1 2 3 4 5 6 7 8 9
1 2 3 5 4 6 7 8 9
1 3 2 4 5 6 7 8 9
1 3 2 5 4 6 7 8 9
1 3 5 2 4 6 7 8 9

5.2.2
./Dragon_Book/chapter_5/translators
a.  D (with no attributes)
        T.type = Int
        L.inh = Int
            L.inh = Int
                L.inh = Int
                    id.entry = a
                id.entry = b
            id.entry = c
b.  D (with no attributes)
        T.type = Float
        L.inh = Float
            L.inh = Float
                L.inh = Float
                    L.inh = Float
                        id.entry = w
                    id.entry = x
                id.entry = y
            id.entry = z

5.2.3
a.  not S-attributed, B has a inherit attribute B.i
    L-attributed
    can be computed in preorder like any other L-attributed SDD
b.  not S-attributed due to D.i
    L-attributed
    can be computed in preorder like any other L-attributed SDD
c.  S-attributed
    L-attributed
    can be computed in any bottom-up order like any other S-attributed SDD
d.  contains a dependency cycle A.s -> Bi -> Di -> A.s
    not S or L-attributed

5.2.4
./Dragon_Book/chapter_5/translators/src/decimal.lalrpop
S -> L1 . L2        S.val = L1.nom + L2.nom / L2.denom
S -> L              S.val = L.nom
L -> L1 B           L.nom = L1.nom * 2 + B.lexval
                    L.denom = L1.denom * 2
L -> B              L.nom = B.lexval
                    L.denom = 2
B -> 0              B.lexval = 0
B -> 1              B.lexval = 1

5.2.5
SDD in 5.2.4 is S-attributed

5.2.6
./Dragon_Book/chapter_3/simple-regex
not exactly an SDD but close

5.3.1
a.  E -> E1 + T     E.t = if E1.t == float || T.t == float { float } else { int }
    E -> T          E.t = T.t
    T -> num . num  T.t = float
    T -> num        T.t = int
b.  E -> E1 + T     E.e = E1.e || T.e || "+"
    E -> T          E.e = T.e
    T -> num1 . num2    T.e = num1 + intToFloat(num2) / BASE^len(num2)
    T -> num        T.e = num

5.3.2
define a function paren(node) where
    paren(node) = if node.add {
        "(" || node.e || ")"
    } else {
        node.e
    }
E -> T + E1     E.e = T.e || "+" || E1.e
E -> T          E.e = T.e
                E.add = T.add
T -> F * T1     T.e = paren(F.e) || "*" || paren(T1.e)
                T.add = false
T -> F          T.e = F.e
                T.add = F.add
F -> ( E )      F.e = E.e
                F.add = E.add
F -> id         F.e = id
                F.add = false
F -> num        F.e = num
                F.add = false

5.3.3
E -> T + E1     E.d = new Node('+', T.d, E1.d)
E -> T          E.d = T.d
T -> F * T1     T.d = new Node('+', new Node('*', F, T1.d), new Node('*', F.d, T1))
T -> F          T.d = F.d
F -> ( E )      F.d = E.d
F -> "x"        F.d = new Leaf(num, 1)
F -> num        F.d = new Leaf(num, 0)

5.4.1
by definition of GOTO function on on sets of canonical LR(1) items
the kernel of a set may only contain items in the form of
    (1) A -> αB . β for a single B, or
    (2) S' -> . S, the start item only
in case (1), the grammar symbol of the state is B
in case (2), the grammar symbol of the state is S'

5.4.2
A   -> 0A'
A'  -> {a}BA' | B{b}A' | ε
B   -> 1B'
B'  -> {c}AB' | A{d}B' | ε

5.4.3
inh is inherit, val is synthesis
B   -> 1B'  {B'.inh = 1, B.val = B'.val}
B'  -> 0B'1 {B'1.inh = B'.inh * 2, B'.val = B'1.val}
B'  -> 1B'1 {B'1.inh = B'.inh * 2 + 1, B'.val = B'1.val}
B'  -> ε    {B'.val = B'.inh}

5.4.4
a.  S -> if ( C ) S1 else S2    S1.next = S.next;
                                S2.next = S.next;
                                L1 = new Label();
                                L2 = new Label():
                                C.true = L1;
                                C.false = L2;
                                S.code = C.code || "label" || L1 || S1.code || "label" || L2 || S2.code
b.  S -> do S1 while ( C )      L1 = new Label();
                                L2 = new Label();
                                C.true = L1;
                                C.false = S.next;
                                S1.next = L2;
                                S.code = "label" || L1 || S1.code || "label" || L2 || C.code
c.  S -> '{' L '}'              L.next = S.next
                                S.code = L.code
    L -> L1 S                   La = new Label();
                                S.next = L.next; 
                                L1.next = La;
                                L.code = L1.code || "label" || L1 || S.code
    L -> ε                      L.code = "goto" || L.next

5.4.5
a.  S ->    if (                { L1 = new Label(); L2 = new Label(); C.true = L1; C.false = L2; }
            C)                  { S1.next = S.next; }
            S1 else             { S2.next = S.next; }
            S2                  { S.code = C.code || "label" || L1 || S1.code || "label" || L2 || S2.code; }
b.  S ->    do                  { L1 = new Label(); L2 = new Label(); S1.next = L2; }
            S1 while            { C.true = L1; C.false = S.next; }
            ( C )               { S.code = "label" || L1 || S1.code || "label" || L2 || C.code; }
c.  S ->    '{' L '}'           { L.next = S.next; S.code = L.code; }
    L ->                        { La = new Label(); L1.next = La; }
            L1                  { S.next = L.next; }
            S                   { L.code = L1.code || "label" || L1 || S.code; }
    L ->    ε                   { L.code = "goto" || L.next; }

5.4.6
S -> B                          S.le = B.le
B -> B1 B2                      B.le = B1.le + B2.le
B -> B1 sub B2                  B.le = B1.le + B2.le
B -> ( B1 )                     B.le = B1.le
B -> text                       B.le = getLe(B.ps, text.lexval)
SDT omitted since synthesis attributes can always be computed at the end of the production

5.4.7
B -> B1 sup B2                  B1.ps = B.ps
                                B2.ps = 0.7 * B.ps
                                B.ht = max(B1.ht, B2.ht + 0.6 * B1.ps)
                                B.dp = max(B1.dp, B2.dp - 0.6 * B1.ps)
B ->                            { B1.ps = B.ps; }
    B1 sup                      { B2.ps = 0.7 * B.ps; }
    B2                          { B.ht = max(B1.ht, B2.ht + 0.6 * B1.ps); }
                                { B.dp = max(B1.dp, B2.dp - 0.6 * B1.ps); }

5.5.1
//  only Rust-flavored pseudocode as production of nonterminal C and S are not given in full details
//  assumes consume, Label::new, current_input, print and C being functions with access to some global states
//  consume(s: &str) removes a terminal string prefix s from the input 
//  or throws error if s is not a prefix of the input stream
a.  fn S(next: Label) -> Code {
        consume("if");
        consume("(");
        let l1 = Label::new();
        let l2 = Label::new();
        let c_code = C(l1, l2);
        consume(")");
        let s1_code = S(next);
        consume("else");
        let s2_code = S(next);
        c_code || "label" || l1 || s1_code || "label" || l2 || s2_code
    }
b.  fn S(next: Label) -> Code {
        consume("do");
        let l1 = Label::new();
        let l2 = Label::new();
        let s1_code = S(next);
        let c_code = C(l1, next);
        "label" || l1 || s1_code || "label" || l2 || c_code
    }
c.  //  assume that S has other productions which produces statements
    //  eliminate left recursion:
    //      L   -> SL | ε
    fn S(next: Label) -> Code {
        match current_input() {
            "{" => {
                consume("{");
                let l_code = L(next);
                consume("}");
                l_code
            },
            _ => { /* handling other productions */ },
        }
    }
    fn L(next: Label) -> Code {
        match current_input() {
            _ /* if the next terminal is in FIRST(S) */ => {
                let l1 = Label::new();
                let s_code = S(l1);
                let l_code = L(next);
                s_code || "label" || l1 || l_code
            },
            _ => {
                "goto" || next
            }
        }
    }

5.5.2
a.  fn S(next: Label) {
        consume("if");
        consume("(");
        let l1 = Label::new();
        let l2 = Label::new();
        C(l1, l2);
        print("label" || l1);
        consume(")");
        S(next);
        consume("else");
        print("label" || l2);
        S(next);
    }
b.  fn S(next: Label) {
        consume("do");
        let l1 = Label::new();
        let l2 = Label::new();
        print("label" || l1);
        S(l2);
        print("label" || l2);
        C(l1, next);
    }
c.  //  assume that S has other productions which produces statements
    //  eliminate left recursion:
    //      L   -> SL | ε
    fn S(next: Label) {
        match current_input() {
            "{" => {
                consume("{");
                L(next);
                consume("}");
            },
            _ => { /* handling other productions */ },
        }
    }
    fn L(next: Label) {
        match current_input() {
            _ /* if the next terminal is in FIRST(S) */ => {
                let l1 = Label::new();
                S(l1);
                print("label" || l1);
                L(next);
            },
            _ => {
                print("goto" || next);
            }
        }
    }

5.5.3 - 5.5.5
//  routine, skipped

5.5.6
//  apply left factoring and left recursion elimination
//      S   -> L R
//      R   -> . L | ε
//      L   -> BL'
//      L'  -> BL' | ε
//      B   -> 0 | 1
fn S() -> f64 {
    let (val, _) = L();
    if let Some((nom, denom)) = R() {
        f64::from(val) + f64::from(nom) / f64::from(denom)
    } else {
        f64::from(val)
    }
}
fn R() -> Option<(u32, u32)> {
    if current_input() == "." {
        consume(".");
        Some(L())
    } else {
        None
    }
}
fn L() -> (u32, u32) {
    L'(B(), 2)
}
fn L'(nom: u32, denom: u32) -> (u32, u32) {
    match current_input() {
        "0" | "1" => L'(nom * 2 + B(), denom * 2),
        _ => (nom, denom),
    }
}
fn B() -> u32 {
    match current_input() {
        "0" => {
            consume("0");
            0
        },
        "1" => {
            consume("1");
            1
        },
        _ => panic!(),
    }
}
on-the-fly generation makes no difference as return types have fixed size

6.1.1
top node: 6
0: x
1: y
2: Add(0, 1)
3: Sub(0, 1)
4: Mul(2, 3)
5: Sub(2, 4)
6: Add(5, 4)

6.1.2
a.  top node: 3
    0: a
    1: b
    2: Add(0, 1)
    3: Add(2, 2)
b.  top node: 4
    0: a
    1: b
    2: Add(0, 1)
    3: Add(2, 0)
    4: Add(3, 1)
c.  top node: 5
    0: a
    1: Add(0, 0)
    2: Add(1, 0)
    3: Add(2, 0)
    4: Add(2, 3)
    5: Add(1, 4)

6.2.1
a.  top node: 5
    0: b
    1: Add(0, 3)
    2: a
    3: c
    4: Neg(1)
    5: Add(2, 4)
b.  +   b   c   t0
    neg t0      t1
    +   a   t1  t2
c.  0:  +   b   c
    1:  neg (0) 
    2:  +   a   (1)
d.  straightforward from part c.

6.2.2
i.  a.  0: b
        1: i
        2: c
        3: j
        4: a
        5: Access(0, 1)
        6: Access(2, 3)
        7: Add(5, 6)
        8: Assign(4, 7)
        top node: 8
    b.  []  b   i   t0
        []  c   j   t1
        +   t0  t1  a
    c.  0:  []  b   i
        1:  []  c   j
        2:  +   (0) (1)
        3:  =   a   (2)
    d.  straightforward
ii. a.  0: b
        1: c
        2: d
        3: a
        4: i
        5: Mul(0, 1)
        6: Mul(0, 2)
        7: Sub(5, 6)
        8: Access(3, 4)
        9: Assign(8, 7)
        top node: 9
    b.  *   b   c   t0
        *   b   d   t1
        -   t0  t1  t2
        []  a   i   t3
        =   t2      t3
    c.  0:  *   b   c 
        1:  *   b   d
        2:  -   (0) (1)
        3:  []  a   i
        4:  =   (3) (2)
    d.  straightforward
iii.a.  0: x
        1: f
        2: y
        3: 1
        4: 2
        5: Add(y, 3)
        6: Apply(1, 5)
        7: Add(6, 4)
        8: Assign(0, 7)
        top node: 8
    b.  +       y   1   t0
        param   t0
        call    f       t1
        +       t1  2   x
    c.  0:  +       y   1
        1:  param   (0)
        2:  call    f
        3:  +       (2) 2
        4:  =       x   (3)
    d.  straightforward
iv. a.  0: x
        1: p
        2: y
        3: Deref(1)
        4: Ref(2)
        5: Add(3, 4)
        6: Assign(0, 5)
        top node: 6
    b.  de  p       t0
        &   y       t1
        +   t0  t1  x
    c.  0:  de  p
        1:  &   y
        2:  +   (0) (1)
        3:  =   x   (2)
    d.  straightforward

6.2.3
without conditional instructions:
    if the ith instruction assigns to a variable x the second time
    the original value stored in x is invisible to all the instructions after i in the scope
    replace x with a new unique variable name x' for all instructions after i will not alter the meaning
with conditional instructions:
    informally if x is assigned in two branches of a conditional statement, namely x = y1 and x = y2
    replace the two instructions with x1 = y1 and x2 = y2, add x = φ(x1, x2) at where the two branch joins
    may have to be done during codegen since the exact flow analysis of three address code is very likely undecidable

6.3.1
x: float, offset: 0
p: record {..}, offset: 8
    x: float, offset: 8
    y: float, offset: 16
q: record {..}, offset: 24
    tag: int, offset: 24
    x: float, offset: 28
    y: float, offset: 36

6.3.2
currently the record types in this grammar have no aliases, hence there's no way to name and inherit from a superclass
various implementations of inheritance are discussed in Chapter 18 & 27 in Types and Programming Languages by Pierce

6.4.1
E -> E1 * E2    { E.addr = new Temp();
                  E.code = E1.code || E2.code || gen(E.addr '=' E1.addr '*' E2.addr); }
E -> + E1       { E.addr = E1.addr; // unary + is no-op }

6.4.2
E -> E1 * E2    { E.addr = new Temp();
                  gen(E.addr '=' E1.addr '*' E2.addr); }
E -> + E1       { E.addr = E1.addr; // unary + is no-op }

6.4.3
a.  t0 = i * a.base.width,
    t1 = a [t0],
    t2 = j * b.base.width,
    t3 = b [t2],
    t4 = t1 + t3,
    x = t4
b.  t0 = i * a.dim0,
    t1 = t0 + j,
    t2 = t1 * a.base.width,
    t3 = a [t2],
    t4 = i * b.dim0,
    t5 = t4 + j,
    t6 = t5 * b.base.width,
    t7 = b [t6],
    t8 = t3 + t7,
    x = t8
c.  t0 = i * b.dim0,
    t1 = t0 + j,
    t2 = t1 * b.base.width,
    t3 = b [t2],
    t4 = t3 * a.dim0,
    t6 = k * c.base.width,
    t7 = c [t6],
    t5 = t4 + t7,
    t8 = t5 * a.base.width,
    t9 = a [t8],
    x = t9

6.4.4
L   -> H ]      { L.addr = H.addr; }
H   -> id [ E   { // same to translation rules of L -> id [ E ] in Fig 6.22 }
    -> H , E    { // same to translation rules of L -> L [ E ] in Fig 6.22 }

6.4.5
A[i][j]:
a.  base + ((i - l1) * (h2 - l2 + 1) + j - l2) * w
b.  base + ((j - l2) * (h1 - l1 + 1) + i - l1) * w
let 
    ni =  hi - l1 + 1
    di = ith index
    ij = dj - lj
c.  same to formula 6.6
d.  base + ((... ((ik * nk-1 + ik-1) * nk-2 + ik-2) ...) * n1 + i1) * w

6.4.6
a.  256
b.  748
c.  224

6.4.7
a.  172
b.  316
c.  648

6.4.8
a.  672
b.  112
c.  896

6.4.9
a.  144
b.  384
c.  760

6.5.1
a.  t0  = (short) c
    t1  = s + t0
    x   = (float) t1
b.  t0  = (short) c
    t1  = s + t0
    x   = (int) t1
c.  t0  = (short) c
    t1  = s + t0
    t2  = (short) d
    t3  = t + d 
    t4  = t1 * t3
    x   = (float) t4

6.5.2
E   -> E1 ( E2 )    { // bottom-up
                      E.type = {t | s ∈ E2.type, s -> t ∈ E1.type}; 
                      // top-down
                      if E.unique == NULL {
                        E1.unique = u -> r in { s -> t | t == r, s ∈ E2.type, s -> t ∈ E1.type };
                        E.unique = r;
                        E2.unique = u;
                      } else {
                        E1.unique = u -> r in { s -> t | t == E.unique, s ∈ E2.type, s -> t ∈ E1.type };
                        E2.unique = u;
                      } 
                    }

6.6.1
a.  S -> repeat S1 while ( B )  { loop = new Label();
                                  S1.next = fall;
                                  B.true = loop;
                                  B.false = S.next; 
                                  S.code = gen("label" loop) || S1.code || B.code; }
b.  S -> for ( S1; B; S2 ) S3   { S1.next = fall;
                                  loop = new Label();
                                  end = S.next || new Label();
                                  B.true = fall;
                                  B.false = end;
                                  S2.next = loop;
                                  S3.next = fall;
                                  S.code = S1.code || gen("label" loop) || B.code || S3.code || S2.code;
                                  if S.next != fall {
                                      S.code = S.code || gen("label" end);
                                  }}

6.6.2
B { true = fall, false = S.next || end }
loop:
S1 { next = fall }
B { true = loop, false = S.next }
end:
S -> while ( B ) S1     { loop = new Label();
                          end = new Label();
                          B.true = fall;
                          B.false = S.next || end;
                          S1.next = fall;
                          B.true = loop;
                          B.false = S.next;
                          S.code = gen("label" loop) || B.code || S1.code;
                          if S.next != fall {
                              S.code = S.code || gen("label" end);
                          }}

6.6.3
B1 { true = T1, false = F1 }
T1: t1 = 1;
goto E1;
T2: t1 = 0;
E1: B2 { true = T2, false = F2 }
T2: t2 = 1;
goto E2;
F2: t2 = 0;
E2: IfTrue t1 == t2 goto B.false 
goto B.true 
B -> B1 ^ B2        { T1 = new Label();
                      F1 = new Label();
                      E1 = new Label();
                      B1.true = T1;
                      B1.false = F1;
                      t1 = new Temp();
                      c1 = gen("label" T1)
                          || gen(t1 "=" 1)
                          || gen("goto" E1)
                          || gen("label" F1)
                          || gen(t1 "=" 0)
                          || gen("label" E1);
                      T2 = new Label();
                      F2 = new Label();
                      E2 = new Label();
                      B2.true = T2;
                      B2.false = F2;
                      t2 = new Temp();
                      c2 = gen("label" T2)
                          || gen(t2 "=" 1)
                          || gen("goto" E2)
                          || gen("label" F2)
                          || gen(t2 "=" 0)
                          || gen("label" E2)
                          || gen("IfTrue" t1 "==" t2 B.false)
                          || gen("Goto" B.true);
                      B.code = B1.code || c1 || B2.code || c2

6.6.4
//  errata:
//      http://infolab.stanford.edu/~ullman/dragon/errata.html
//      "x == 1;" => "x = 1;" 
//  adjusted the grammar so || has lower precedence than &&, like in most of the languages
./Dragon_Book/chapter_6/dag
a.  IfFalse a == b goto L2,
    IfTrue c == d goto L1,
    L2: IfFalse e == f goto L0,
    L1: x = 1,
    L0: Noop
b.  IfTrue a == b goto L1,
    IfTrue c == d goto L1,
    IfFalse e == f goto L0,
    L1: x = 1,
    L0: Noop
c.  IfFalse a == b goto L0,
    IfFalse c == d goto L0,
    IfFalse e == f goto L0,
    x = 1,
    L0: Noop

6.6.5
//  routine, skipped

6.6.6
//  if l1 == fall, l1 || l2 == l2
P -> S                      { S.next = fall;
                              P.code = S.code; }
S -> assign                 { S.code = assign.code; }
S -> if ( B ) S1            { end = S.next || new Label();
                              B.true = fall; 
                              B.false = end;
                              S1.next = S.next;
                              S.code = B.code || S1.code;
                              if S.next == fall {
                                  S.code = S.code || gen("label" end);
                              }}
S -> if ( B ) S1 else S2    { end = S.next || new Label();
                              f = new Label();
                              B.true = fall;
                              B.false = f;
                              S1.next = end;
                              S2.next = S.next;
                              S.code = B.code || S1.code || gen("label" f) || S2.code;
                              if S.next == fall {
                                  S.code = S.code || gen("label" end);
                              }}
S -> while ( B ) S1         { loop = new Label();
                              end = S.next || new Label();
                              B.true = fall;
                              B.false = end;
                              S1.next = S.next;
                              S.code = gen("label" loop) || B.code || S1.code;
                              if S.next == fall {
                                  S.code = S.code || gen("label" end);
                              }}
S -> S1 S2                  { S1.next = fall; 
                              S2.next = S.next;
                              S.code = S1.code || S2.code; }
B -> B1 && B2               { f = B.false || new Label();
                              B1.true = fall;
                              B2.true = B.true;
                              B2.false = B.false;
                              B.code = B1.code || B2.code;
                              if B.false == fall {
                                  B.code = B.code || gen("label" f);
                              }}
B -> ! B1                   { // no change }
B -> true                   { if B.true != fall { B.code = gen("goto" B.true); }}
B -> false                  { if B.false != fall { B.code = gen("goto" B.false); }}

6.6.7
6.6.6 is already such a rule 
verified by test ./Dragon_Book/chapter_6/dag/src/symbolic.rs#stmt_test

6.6.8
B -> E1 rel E2              { switch (B.true, B.false)
                              case (fall, fall):
                                // noop
                              case (t, fall);
                                test = gen("IfTrue" E1.addr rel.op E2.addr "goto" t);
                              case (fall, f):
                                test = gen("IfFalse" E1.addr rel.op E2.addr "goto" f);
                                // or gen("if" E1.addr rel.op.rev() E2.addr "goto" f)
                                // if the intermediate code has no IfFalse instruction
                              case (t, f):
                                test = gen("IfTrue" E1.addr rel.op E2.addr "goto" t);
                                    || gen("goto" f); 
                              B.code = E1.code || E2.code || test; }

6.7.1
./Dragon_Book/chapter_6/backpatch
a.  a==b && (c==d || e==f)
    a == b:             truelist = [100], falselist = [101]
    c == d:             truelist = [102], falselist = [103]
    e == f:             truelist = [104], falselist = [105]
    c == d || e == f:   truelist = [102, 104], falselist = [105]
    whole:              truelist = [102, 104], falselist = [101, 105]
    100: if a == b goto 102
    101: goto _
    102: if c == d goto _
    103: goto 104
    104: if e == f goto _
    105: goto _
b.  (a==b || c==d) || e==f
    a == b:             truelist = [100], falselist = [101]
    c == d:             truelist = [102], falselist = [103]
    a == b || c == d:   truelist = [100, 102], falselist = [103]
    e == f:             truelist = [104], falselist = [105]
    whole:              truelist = [100, 102, 104], falselist = [105]
    100: if a == b goto _
    101: goto 102
    102: if c == d goto _
    103: goto 104
    104: if e == f goto _
    105: goto _
c.  (a==b && c==d) && e==f
    a == b:             truelist = [100], falselist = [101]
    c == d:             truelist = [102], falselist = [103]
    a == b && c == d:   truelist = [102], falselist = [101, 103]
    e == f:             truelist = [104], falselist = [105]
    whole:              truelist = [104], falselist = [101, 103, 105]
    100: if a == b goto 102
    101: goto _
    102: if c == d goto 104
    103: goto _
    104: if e == f goto _
    105: goto _

6.7.2
//  E should be replaced by B in the figure?
a.  i1 
b.  i7
c.  i7
d.  i3
e.  i3

6.7.3
a.  S4.next = B3.false
b.  S5.next = merge(B4.false, S2.next)
c.  S6.next = S3.next
d.  S7.next = merge(S4.next, S6.next, N.next)
e.  B1.false

6.8.1
S   -> switch ( E ) CL default S1   { t = E.rvalue;
                                      test = new Label();
                                      default = new Label();
                                      CL.next = S.next;
                                      S1.next = S.next;
                                      test_code = CL.pairs.map((v, l) => gen("case" t v l)).reduce(||);
                                      test_code = gen("label" test) || test_code || gen("goto" default);
                                      S.code = E.code
                                          || gen("goto" test)
                                          || CL.code
                                          || gen("label" default)
                                          || S1.code
                                          || gen("goto" S.next)
                                          || test_code: }
CL  -> CL1 C                        { CL1.next = C.next = CL.next;
                                      CL.code = CL1.code || C.code;
                                      CL.pairs = merge(CL1.pairs, { C.pair }); }
CL  -> C                            { C.next = CL.next;
                                      CL.code = C.code; 
                                      CL.pairs = { C.pair }; }
C   -> case V: S                    { S.next = C.next;
                                      into = new Label();
                                      C.code = gen("label" into) || S.code || gen("goto" C.next);
                                      C.pair = (V.lexval, into); }

7.2.1
./Dragon_Book/chapter_7/calls
a.  q(0,9)
        p(0,9)
        q(0,8)
            p(0,8)
            q(0,0)
            q(1,8)
                p(1,8)
                q(1,7)
                    p(1,7)
                    q(1,1)
                    q(2,7)
                        p(2,7)
                        q(2,6)
                            p(2,6)
                            q(2,2)
                            q(3,6)
                                p(3,6)
                                q(3,5)
                                    p(3,5)
                                    q(3,3)
                                    q(4,5)
                                q(6,6)
                        q(7,7)
                q(8,8)
        q(9,9)
b.  9

7.2.2
./Dragon_Book/chapter_7/calls
a.  q(0,9)
        p(0,9)
        q(0,0)
        q(1,9)
            p(1,9)
            q(1,2)
            q(3,9)
                p(3,9)
                q(3,6)
                    p(3,6)
                    q(3,4)
                    q(5,6)
                q(7,9)
                    p(7,9)
                    q(7,7)
                    q(8,9)
b.  5

7.2.3
./Dragon_Book/chapter_7/calls
a.  f(5)
        f(4)
            f(3)
                f(2)
                    f(1)
                    f(0)
                f(1)
            f(2)
                f(1)
                f(0)
        f(3)
            f(2)
                f(1)
                f(0)
            f(1)
b.  from bottom to above:
    record of f(5) (input n, space of returns s and t, saved machine status)
    record of f(4) (same as above)
    record of f(3) (same as above)
    record of f(2) (same as above)
    record of f(1) (same as above without saved machine status)
c.  record of f(5) (input n, space of returns s and t, saved machine status)
    record of f(3) (same as above)
    record of f(1) (same as above without saved machine status)

7.2.4
in style of figure 7.6
0:  y
1:  g(y)
2:  j and return value from f
3:  x (= j + 1)
4:  f(x)
5:  i
a.  g(y) creates 0 - 3
    f(x) creates 4 - 5
b.  the caller of g(y) writes y
    g(y) writes x and j
    f(x) writes i and the return value on 3
c.  0 - 2: g(y)
    3 - 5: f(x)

7.2.5
12

7.2.6
21

7.3.1
./Dragon_Book/chapter_7/calls
fib0(4)
    fib1(4)
        fib2(4)
            fib1(3)
                fib0(2)
                    fib1(2)
                        fib0(1)
                        fib0(0)
                fib0(1)
            fib1(2)
                fib0(1)
                fib0(0)
 :  fib0(4)
0:  access label: main
 :  fib1(4)
1:  access label: 0
 :  fib2(4)
2:  access label: 1
 :  fib1(3)
3:  access label: 0
 :  fib0(2)
4:  access label: main
 :  fib1(2)
5:  access label: 4
 :  fib0(1)
6:  access label: main

7.3.2
 :  fib0(4)
0:  saved d[2]: null
 :  fib1(4)
1:  saved d[3]: null
 :  fib2(4)
2:  saved d[4]: null
 :  fib1(3)
3:  saved d[3]: 1
 :  fib0(2)
4:  saved d[2]: 0
 :  fib1(2)
5:  saved d[3]: 1
 :  fib0(1)
6:  saved d[2]: 4
d[1] = main
d[2] = 6
d[3] = 5
d[4] = 2

7.4.1
//  with no coalescing
./Dragon_Book/chapter_7/free_space
a.  range: [80, 93], size: 14
    range: [110, 169], size: 60
    range: [170, 219], size: 50
    range: [290, 309], size: 20
    range: [310, 349], size: 40
b.  range: [0, 79], size: 80
    range: [80, 109], size: 30
    range: [110, 169], size: 60
    range: [310, 317], size: 8

7.5.1
./Dragon_Book/chapter_7/ref_count
a.  A: 1
    B: 0
    C: 2
    D: 0
    E: 1
    F: 1
    G: 1
    H: 2
    I: 1
    X: 0
b.  A: 0
    B: 0
    C: 1
    D: 0
    E: 1
    F: 1
    G: 1
    H: 2
    I: 1
    X: 0
c.  A: 1
    B: 1
    C: 0
    D: 1
    E: 2
    F: 0
    G: 2
    H: 1
    I: 1
    X: 0

7.5.2
./Dragon_Book/chapter_7/ref_count
A: 1
B: 1
C: 1
D: 0
E: 3
F: 0
G: 0
H: 1
I: 2
X: 0
Y: 0

7.6.1
//  mark phase in Algorithm 7.12 is simply DFS
//  the steps of a run of DFS depends on how it enumerates neighbours of a vertex
//  which is not specified in the algorithm, hence only results are given here
./Dragon_Book/chapter_7/gc
a.  name: A, offset: 0, size: 100
    name: B, Recycled
    name: C, offset: 100, size: 100
    name: D, Recycled
    name: E, offset: 200, size: 100
    name: F, offset: 300, size: 100
    name: G, offset: 400, size: 100
    name: H, offset: 500, size: 100
    name: I, offset: 600, size: 100
    name: X, offset: 700, size: 100
b.  name: A, offset: 0, size: 100
    name: B, offset: 100, size: 100
    name: C, offset: 200, size: 100
    name: D, offset: 300, size: 100
    name: E, offset: 400, size: 100
    name: F, offset: 500, size: 100
    name: G, offset: 600, size: 100
    name: H, offset: 700, size: 100
    name: I, offset: 800, size: 100
    name: X, offset: 900, size: 100
c.  name: A, offset: 0, size: 100
    name: B, offset: 100, size: 100
    name: C, offset: 200, size: 100
    name: D, Recycled
    name: E, offset: 300, size: 100
    name: F, Recycled
    name: G, Recycled
    name: H, offset: 400, size: 100
    name: I, offset: 500, size: 100
    name: X, offset: 600, size: 100
    name: Y, offset: 700, size: 100
d.  name: A, offset: 0, size: 100
    name: C, Recycled
    name: D, offset: 100, size: 100
    name: E, offset: 200, size: 100
    name: F, offset: 300, size: 100
    name: G, offset: 400, size: 100
    name: H, offset: 500, size: 100
    name: I, offset: 600, size: 100
    name: X, offset: 700, size: 100
    name: Y, offset: 800, size: 100

7.6.2
the sequence can be uniquely determined by the start and end state of an object
Alloc => Alloc:
    Unreached => Unscaned => Scanned => Unreached
Alloc => Recycled:
    Unreached => Free
Rcycled => Rcycled:
    Free

7.6.3
see 7.6.1

7.6.4
the result of 7.6.1 but:
    the offsets starts from 10000 instead of 0
    BFS instead of DFS

7.7.1
Write barrier: put o to Unscanned if o1.o is overwritten and o1 is Scanned
i   A: Unscanned => Scanned
    D, E: Unreached => Unscanned
ii  write barrier
    H: Unreached => Unscanned
iii B: Unscanned => Scanned
    C, E: Unreached => Unscanned
iv  D: Unscanned => Scanned
    G, H: Unreached => Unscanned
v   write barrier
    I: Unreached => Unscanned
{C, D, F, G} are gabages, Free is empty

7.7.2
i   A: Unscanned => Scanned
    D, E: Unreached => Unscanned
ii  Nothing
iii B: Unscanned => Scanned
    E, I: Unreached => Unscanned
iv  D: Unscanned => Scanned
    G, H: Unreached => Unscanned
v   write barrier
    H: Unreached => Unscanned
{C, D, F, G} are gabages, Free = {C}

7.7.3
23, 32, 25 (new car) or 34 (new car)

7.7.4
a.  22, 31, 25 (new car) or 34 (new car)
b.  any car 11 to 13 (new car), preferably 11

7.7.5
reference to o1 is moved to base set
o1 is moved to train 2 or 3 
