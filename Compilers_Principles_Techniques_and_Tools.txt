Chapter 1
1.1.1
a compiler transforms the program (source file) in one language to another language 
a interpreter directly executes the program in one language

1.1.2
a.  by transforming directly to machine code, the program produced by a compiler usually runs faster than interpreted
    add a new backend to a compiler is usually easier than porting a whole interpreter to a new target platform
        especially when the target platform is some microcontroller which is not powerful enough to run the interpreter
        (lacking memory / storage, etc.)
b.  a basic interpreter is easiler to write compared to a basic compiler
        (in the sense that an interpreter don't have to consider the structure of the target language)
    the source code is cross-platform among platforms on which the interpreter is implemented
    by personal experience today a compiler can produce almost equally good error messages compared to an interpreter
    the structure of the program is controlled by the interpreter, makes certain techniques easier than compiled lang
        e.g. hot reloading in javascript, a C++ equivalent has to compile sources at runtime

1.1.3
today assembly code provides quite a lot abstraction over machine language
the output program tends to be more meaningful and compact, also a little bit more compatibility

1.1.4
C is usually the first high-level language a platform will ever support
    if a language can be translated to C it can be executed on any platform that supports C
C has much simpler structure than most of the high-level languages
many languages are influenced by C and bears some degree of resemblance to C, the translation will be easier

1.1.5
expand macros 
transfer tags to literal memory locations
transfer numerial constants from base 10 to hex
translate instructions to machine op code
do some obvious optimizations (is the compiler produced low quality assembly code, which is unlikely)

1.3.1
imperative: C, Cobol, Fortran, Perl 
declarative: Lisp, ML
von Neumann: all of them
object-oriented: C++, Java, Python, VB
functional: Lisp, ML
third-generation: all of them
fourth-generation: none
scripting: Perl, Python

1.6.1
w = 13, x = 11, y = 13, z = 11

1.6.2
w = 9, x = 7, y = 13, z = 11

1.6.3
B1.w: B1, B2
B1.x: B1
B1.y: B1, B2, B3, B4
B1.z: B1, B4
B2.x: B2
B2.z: B2, B3
B4.w: B4, B5
B4.x: B4, B5
other declarations have a scope consists of only the block they belongs to

1.6.4
3
2

Chapter 2
2.2.1
a.  S -> SS* -> SS+S* -> aa+S* -> aa+a*
b.  S---S---S---a
    |   |
    |   ----S---a
    |   |
    |   ----+
    |
    ----S---a
    |
    ----*
c.  all expressions in postfix notation with a single digit a and two operators + and *

2.2.2
a.  0^n1^n for n >= 1
    if 0^n1^n can be generated from S, the last step must be 0^(n-1)011^(n-1) as it is the only terminal rule
    replace S -> 01 by S -> 0S1 -> 0011 then 0^(n+1)1^(n+1) can also be generated
    conversely, assume for all string T with length <= n generated by S, T ∈ {0^k1^k | k >= 1}
    for string of length n+2, S -> 0S1 ∈ {0^k1^k | k >= 1}
b.  prefix version of 2.2.1 by symmetry
c.  any number of correctly paired parentheses
    assume for string with <= n pair of correctly paired parentheses can be generated from S
    let T be a string with n+1 pair of correctly paired parentheses
    T must start with (, and first left parenthesis must be closed somewhere into T,
    hence T = (T0)T1, where T0 and T1 are string of correctly paired parentheses with smaller size
    by induction T0 and T1 can be generated from S
    also S -> S(S)S -> ε(T0)T1, so T can be generated from S
    conversely, let L be the set of strings of correctly paired parentheses
    induct on height of parse tree, S -> S(S)S is also correctly paired, so S(S)S ∈ L
d.  any string with equal number of a and b
    assume any string with length <= 2n and equal number of a and b can be generated from S
    let T be a string with length 2(n+1) with equal number of a and b
    if T starts with a:
        let a(T) and b(T) denote the number of a and b in the string T
        let Ti be the prefix of T with length i
        let k be the smallest index that a(Tk) = b(Tk),
        k must exist since T = T2n+2 and a(T) = b(T)
        T[k] must be b:
            define a function f(i) = a(Ti) - b(Ti), 0 <= i <= k
            if T[k] = a, f(k-1) = -1, f(1) = 1
            |f(i+1) - f(i)| <= 1, the value of f(i) can change at most by 1 for two consecutive indices
            so there must be some 1 < i < k-1 where f(i) = 0, k is not the smallest index with a(Tk) = b(Tk)
        therefore T = aT1bT2 where both T1 and T2 has equal number of a and b
        T can be generated by the rule S -> aSbS
    if T starts with b: symmetric
    conversely, induct on height of parse tree, let L = {T | T is a string with equal number of a and b}
    S -> aSbS ∈ L
    S -> bSaS ∈ L
    S -> ε ∈ L
e.  replace space with *, * with some arbitrary unary operator (e.g. negate)
    an ambiguous grammar for infix arithmetic expressions

2.2.3
a is not ambiguous:
    there are only one non-terminating rule with only one non-terminating symbol
b is not ambiguous:
    prefix (and postfix) arithmetic expressions have fixed order of evaluation
c is ambiguous:
    ()() can be generated by 
        S -> S(S)S -> ε(ε)S -> ()(), or
        S -> S(S)S -> S(ε)ε -> ()()
d is ambiguous:
    abab can be generated by
        S -> aSbS -> aSb -> abSaSb -> abab, or
        S -> aSbS -> abS -> abaSbS -> abab
e is ambiguous:
    no precedence is specified, S + SS can be parsed as (S + S)S or S + (SS)

2.2.4
a.  S -> S S + | S S - | S S * | S S / | digit
    justified  by text
b.  S -> S , id | id
    justified by text
c.  S -> id , S | id
    justified by text
d.  expr -> expr + term | expr - term | term
    term -> term * factor | term / factor | factor
    factor -> id | num | ( expr )
    justified by text
e.  expr -> expr + term | expr - term | term
    term -> term * unary | term / unary | unary
    unary -> - factor | + factor | factor
    factor -> id | num | ( expr )

2.2.5
a.  induct on the height of parse tree, let L = {b | b = 0 mod 3}
    num -> 11 ∈ L
    num -> 1001 ∈ L
    num -> num 0
        let num -> B0, by induction B = 0 mod 3
        B0 = B * 2 = 0 mod 3
    num -> num num
        let num -> B0B1, by induction B0 = B1 = 0 mod 3
        B0B1 = B0 * 2^n + B1 = 0 mod 3
b.  no, 3^10 = 1110011010101001 cannot be generated
    tested in https://web.stanford.edu/class/archive/cs/cs103/cs103.1156/tools/cfg/

2.2.6
up to 3999
https://en.wikipedia.org/wiki/Roman_numerals
ε is not a legal roman numeral and there's no zero in roman numerial
S   -> TN H E O | HN E O | EN O | ON
T   -> TN | ε
TN  -> M | MM | MMM
H   -> HN | ε
HN  -> C | CC | CCC | CD | D | DC | DCC | DCCC | CM
E   -> EN | ε
EN  -> X | XX | XXX | XL | L | LX | LXX | LXXX | XC
O   -> ON | ε
ON  -> I | II | III | IV | V | VI | VII | VIII | IX

2.3.1
expr -> expr1 + term        expr.t = '+' || expr1.t || term.t
expr -> expr1 - term        expr.t = '-' || expr1.t || term.t
expr -> term                expr.t = term.t
term -> term * factor       term.t = '*' || term.t || factor.t
term -> term / factor       term.t = '/' || term.t || factor.t
term -> factor              term.t = factor.t
factor -> id                factor.t = id.t
factor -> num               factor.t = num.t
factor -> ( expr )          factor.t = expr.t

2.3.2
// added parentheses to each expression so precedence no longer matters
expr -> expr1 expr2 +       expr.t = '(' || expr1.t || '+' || expr2.t || ')'
expr -> expr1 expr2 -       expr.t = '(' || expr1.t || '-' || expr2.t || ')'
expr -> expr1 expr2 *       expr.t = '(' || expr1.t || '*' || expr2.t || ')'
expr -> expr1 expr2 /       expr.t = '(' || expr1.t || '/' || expr2.t || ')'
expr -> factor              expr.t = factor.t
factor -> id                factor.t = id.t
factor -> num               factor.t = num.t

2.3.3
since it will be tidious to list them all
let T, H, E, O be the mapping between decimal digits and roman digits in different positions
e.g. T(1) = M, H(3) = CCC, O(4) = IV
again this grammar cannot generate 0 as there's no representation of 0 in roman numeral
S -> ND1D2D3        S.t = T(N.t) || H(D1.t) || E(D2.t) || O(D3.t)
S -> ND1D2          S.t = H(N.t) || E(D1.t) || O(D2.t)
S -> ND             S.t = E(N.t) || O(D.t)
S -> N              S.t = O(N.t)
D -> N              D.t = N.t
D -> 0              D.t = 0
N -> 1 .. 9         N.t = 1 .. 9

2.3.4
S   -> TN H E O | HN E O | EN O | ON                    S.t     = TN.t + H.t + E.t + O.t | HN.t + E.t + O.t | ...
T   -> TN | ε                                           T.t     = TN.t | 0
TN  -> M | MM                                           TN.t    = 1000 | 2000
H   -> HN | ε                                           H.t     = HN.t | 0
HN  -> C | CC | CCC | CD | D | DC | DCC | DCCC | CM     HN.t    = 100 ... 900
E   -> EN | ε                                           E.t     = EN.t | 0
EN  -> X | XX | XXX | XL | L | LX | LXX | LXXX | XC     EN.t    = 10 ... 90
O   -> ON | ε                                           O.t     = ON.t | 0
ON  -> I | II | III | IV | V | VI | VII | VIII | IX     ON.t    = 1 ... 9

2.3.5
expr -> expr1 expr2 +       expr.t = '+' || expr1.t || expr2.t
expr -> expr1 expr2 -       expr.t = '-' || expr1.t || expr2.t
expr -> expr1 expr2 *       expr.t = '*' || expr1.t || expr2.t
expr -> expr1 expr2 /       expr.t = '/' || expr1.t || expr2.t
expr -> factor              expr.t = factor.t
factor -> id                factor.t = id.t
factor -> num               factor.t = num.t

2.4.1
./Dragon_Book/chapter_2/parsers
tested against strings generated by https://web.stanford.edu/class/archive/cs/cs103/cs103.1156/tools/cfg/
a.  trivial
b.  the grammar is left-recursive, it is first transformed to:
        R -> (R)R | ε
c.  two of the productions share the same lookahead symbol '0'
    look ahead two tokens instead of 1 to distinguish the two cases