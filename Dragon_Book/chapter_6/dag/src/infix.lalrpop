use crate::symbolic::{BinOp, UnOp, Expr, Stmt, Stmts, Access, LValue, Assign, Boolean, RelOp};
use std::rc::Rc;

#[LALR] grammar;

pub P: Stmts = {
    <stmts:S*> => Stmts::new(stmts),
}

S: Stmt = {
    <a:A> => Stmt::Assign(a),
}

A: Assign = {
    <lvalue:LV> "=" <rvalue:E> ";" => Assign { lvalue, rvalue },
}

LV: LValue = {
    <id:Id> => LValue::Var(id),
    <l:L> => LValue::Access(l),
}

pub E: Rc<Expr> = {
    <e:E> "+" <t:T> => Expr::bin(BinOp::Add, e, t),
    <e:E> "-" <t:T> => Expr::bin(BinOp::Sub, e, t),
    <t:T> => t,
}

T: Rc<Expr> = {
    <t:T> "*" <f:F> => Expr::bin(BinOp::Mul, t, f),
    <f:F> => f,
}

F: Rc<Expr> = {
    "-" <f:F> => Expr::un(UnOp::Neg, f),
    "+" <f:F> => Expr::un(UnOp::Pos, f),
    <l:L> => Expr::access(l),
    "(" <e:E> ")" => e,
    <id:Id> => Expr::var(id),
}

L: Access = {
    <var:Id> <dims:Dim+> => Access { var, dims },
}

Dim: Rc<Expr> = {
    "[" <e:E> "]" => e,
}

Num: usize = {
    <s:r"\d+"> => s.parse().unwrap(),
}

Id: String = {
    <s:r"[a-zA-Z]\w*"> => s.to_owned(),
}

B: Boolean = {
    <l:B> "||" <r:B> => Boolean::Or(Box::new(l), Box::new(r)),
    <l:B> "&&" <r:B> => Boolean::And(Box::new(l), Box::new(r)),
    "!" <b:B> => Boolean::Not(Box::new(b)),
    <l:E> <op:Rel> <r:E> => Boolean::Rel(op, l, r),
    "true" => Boolean::True,
    "false" => Boolean::False,
}

Rel: RelOp = {
    "==" => RelOp::Eq,
    "!=" => RelOp::Ne,
    ">" => RelOp::Gt,
    ">=" => RelOp::Ge,
    "<" => RelOp::Lt,
    "<=" => RelOp::Le,
}