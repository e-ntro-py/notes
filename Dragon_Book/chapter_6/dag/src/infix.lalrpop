use crate::symbolic::{BinOp, UnOp, Expr, Stmt, Stmts, Access, LValue};
use std::rc::Rc;

#[LALR] grammar;

pub P: Stmts = {
    <stmts:S*> => Stmts::new(stmts),
}

S: Stmt = {
    <lvalue:LV> "=" <rvalue:E> ";" => Stmt { lvalue, rvalue },
}

LV: LValue = {
    <id:Id> => LValue::Var(id),
    <l:L> => LValue::Access(l),
}

pub E: Rc<Expr> = {
    <e:E> "+" <t:T> => Expr::bin(BinOp::Add, e, t),
    <e:E> "-" <t:T> => Expr::bin(BinOp::Sub, e, t),
    <t:T> => t,
}

T: Rc<Expr> = {
    <t:T> "*" <f:F> => Expr::bin(BinOp::Mul, t, f),
    <f:F> => f,
}

F: Rc<Expr> = {
    "-" <f:F> => Expr::un(UnOp::Neg, f),
    "+" <f:F> => Expr::un(UnOp::Pos, f),
    <l:L> => Expr::access(l),
    "(" <e:E> ")" => e,
    <id:Id> => Expr::var(id),
}

L: Access = {
    <var:Id> <dims:Dim+> => Access { var, dims },
}

Dim: Rc<Expr> = {
    "[" <e:E> "]" => e,
}

Num: usize = {
    <s:r"\d+"> => s.parse().unwrap(),
}

Id: String = {
    <s:r"[a-zA-Z]\w*"> => s.to_owned(),
}